[{"title":"开发环境安装杂项","date":"2022-04-18T04:12:51.000Z","path":"2022/04/18/开发环境安装杂项/","text":"1、配置git 生成ssh 配置到github 测试 生成ssh1ssh-keygen -t rsa -C &quot;jiaoqiang2014@163.com&quot; 配置到github在~/.ssh目录下生成id_rsa.pub和id_rsa公钥和私钥。打开公钥，复制到github 1cat /Users/jq/.ssh/id_rsa.pub 测试连接1sudo ssh -T git@github.com 如果显示Hi jiaoqiang2014! You&#39;ve successfully authenticated, but GitHub does not provide shell access.表示，使用https没有使用ssh，切换到项目.git同级目录下，设置一下使用ssh就行。 1git remote set-url origin git@github.com:lut/EvolutionApp.git 2、docker 安装使用官方 docker doc 说明安装。 设置docker开机自启动1sudo systemctl enable docker docker安装mysql正常芯片1sudo docker pull mysql:8.0.28 M1芯片1sudo docker pull --platform linux/x86_64 mysql:8.0.28 查看安装的服务1sudo docker images docker 启动 mysql123456sudo docker run -p 3306:3306 --name mysql \\-v /var/mysql/log:/var/log/mysql \\-v /var/mysql/data:/var/lib/mysql \\-v /var/mysql/conf:/etc/mysql \\-e MYSQL_ROOT_PASSWORD=123456aa \\-d mysql:8 上面代码不知道为啥启动不了 1docker run -p 3306:3306 --name mysql -e MYSQL_ROOT_PASSWORD=123456aa -d mysql:8 启动mysql容器1docker start mysql 进入 Mysql 容器1docker exec -it mysql bash navicat 连接 docker mysql在腾讯云选择该服务器——&gt;管理-&gt;防火墙中需要添加 mysql 3306端口的规则，不然会被屏蔽。 安装redis123docker pull redismkdir -p /mydata/redis/conftouch /mydata/redis/conf 启动 redis 镜像 1234docker run -p 6379:6379 --name redis \\-v /mydata/redis/data:/data \\-v /mydata/redis/conf/redis.conf:/etc/redis/redis.conf \\-d redis redis-server /etc/redis/redis.conf 检查redis安装是否成功 123docker exec -it redis redis-cliset key1 111get key1 持久化redisredis重启之后会丢失内存中的数据，可以设置持久化到磁盘中。 1vim /mydata/redis/conf/redis.conf 添加以下内容。 123appendonly yesbind 0.0.0.0 -::1requirepass 123456 给redis存值，重启，检查是否还存在。开启服务端TCP的6379端口。 docker 服务器重启自动启动程序1sudo docker update mysql --restart=always","categories":[],"tags":[{"name":"杂项","slug":"杂项","permalink":"http://example.com/tags/%E6%9D%82%E9%A1%B9/"}]},{"title":"玩转Spring全家桶学习笔记","date":"2022-04-17T13:21:32.000Z","path":"2022/04/17/玩转Spring全家桶学习笔记/","text":"1、配置数据源 druid：快 HikariCP：监控、SQL防注入 1.1 druid 定制连接池操作的各中环节通过 Filter 可以实现。","categories":[{"name":"Spring","slug":"Spring","permalink":"http://example.com/categories/Spring/"}],"tags":[]},{"title":"","date":"2022-04-16T15:36:00.379Z","path":"2022/04/16/秒杀项目总结/","text":"configuration该配置文件说明如何在本地搭建起环境，包括启动 mysql、启动虚拟机、启动 redis。 一、Mysql启动 打开navicat 连接 127.0.0.1 即可。 可以使用 http://www.localhost:8080/demo/db/get 测试 二、Redis 启动redis 是使用 multipass 安装的虚拟机需要先启动虚拟机，然后在虚拟机中启动redis。 1、启动 multipass12multipass info -allmultipass shell XXX(host) 参考链接：http://www.manongjc.com/detail/21-gtzvxvzjtoaxswf.html 2、启动 redis1234cd /usr/local/redisredis-server redis.confredis-cliauth 123456 可以使用 http://www.localhost:8080/demo/redis/get 测试 三、压测1. 图形化压测2. 命令行压测首先，需要将jar包启动（参考Spring Boot打jar包）。然后，使用jmeter压测。 1jmeter.sh -n -t /Users/jq/Desktop/goods_list.jmx -l result.jtl 如果OOM，可以使用下面命令设置更大的JVM堆栈内存。 1JVM_ARGS=&quot;-Xms512m -Xmx5g&quot; jmeter.sh -n -t /Users/jq/Desktop/goods_list.jmx -l result.jtl 四、Spring Boot打war包。1. 添加依赖12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; 2. 添加12345678910111213141516171819&lt;build&gt; &lt;finalName&gt;$&#123;project.artifactId&#125;&lt;/finalName&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;failOnMissingWebXml&gt;false&lt;/failOnMissingWebXml&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.1&lt;/version&gt; &lt;configuration&gt; &lt;fork&gt;true&lt;/fork &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 3. 修改1234&lt;groupId&gt;org.imooc&lt;/groupId&gt;&lt;artifactId&gt;miaosha&lt;/artifactId&gt;&lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&lt;packaging&gt;war&lt;/packaging&gt; 同时，把packaging中的jar修改为war。 4. 修改MainApplication类123456789101112@SpringBootApplicationpublic class MainApplication extends SpringBootServletInitializer &#123; public static void main(String[] args) &#123; SpringApplication.run(MainApplication.class, args); &#125; @Override protected SpringApplicationBuilder configure(SpringApplicationBuilder builder)&#123; return builder.sources(MainApplication.class); &#125;&#125; 5. brew 安装 tomcat@9（和java8匹配) \\Brew会默认安装在/opt/homebrew/Cellar/目录下。 6. 配置tomcat快速启动12alias tomcatstart=/opt/homebrew/Cellar/tomcat@9/9.0.60/libexec/bin/startup.shalias tomcatstop=/opt/homebrew/Cellar/tomcat@9/9.0.60/libexec/bin/shutdown.sh 7. 打成 war 包1mvn clean package 在miaosha/target目录下生成miasma.war包。将miasma.war拷贝到 /opt/homebrew/Cellar/tomcat@9/9.0.60/libexec/webapps 目录下。 8. tomcatstart 启动tomcat。 \\输入http://www.localhost:8080测试tomcat是否搭建成功。输入 http://www.localhost:8080/miaosha/login/to_login， 查看登录界面，但目前不能登录，需要在/opt/homebrew/Cellar/tomcat@9/9.0.60/libexec/webapps/Root 目录下添加一些资源。 五、Spring Boot打jar包1、添加依赖12345678910111213141516&lt;build&gt; &lt;finalName&gt;$&#123;project.artifactId&#125;&lt;/finalName&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.1&lt;/version&gt; &lt;configuration&gt; &lt;fork&gt;true&lt;/fork&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 2、修改1234&lt;groupId&gt;org.imooc&lt;/groupId&gt;&lt;artifactId&gt;miaosha&lt;/artifactId&gt;&lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&lt;packaging&gt;jar&lt;/packaging&gt; 3、打成 jar 包1mvn clean package 在miaosha/target目录下生成miasma.jar包 4、运行jar，并输出到nohup文件。1nohup java -jar miaosha.jar &amp; 5、测试输入 http://www.localhost:8080/miaosha/login/to_login， 查看登录界面，并且进行压测。 输入 tail -f nohup.out 可以查看日志的末尾输出。 五、压测 redis12345678redis-benchmark -a 123456 -h 127.0.0.1 -p 6379 -c 100 -n 100000redis-benchmark -a 123456 -h 127.0.0.1 -p 6379 -q -d 100redis-benchmark -a 123456 -t set,lpush -n 100000 -q# 只测试单条命令redis-benchmark -a 123456 -n 100000 -q script load &quot;redis.call(&#x27;set&#x27;,&#x27;foo&#x27;,&#x27;bar&#x27;)&quot; 六、页面优化技术 页面缓存 + URL缓存 + 对象缓存 页面静态化（不需要重复下载页面，只需要下载动态的），前后端分离 静态资源优化 CDN优化 1、页面缓存将 goods_list 页面的信息写入 redis，设置了60s的缓存时间。可以下命令测试： 12keys GoodsKey:glget GoodsKey:gl 2、URL 缓存和页面缓存大致一样，给 goods_detail 页面添加缓存，不同于 goods_list 页面的是 goods_detail 页面需要加用户的标号：”1”（http://www.localhost:8080/goods/to_detail/1）。 3、对象缓存此处的对象指的是用户对象，通过用户id将用户的信息写入缓存。 MiaoshaUserService 类中的 updatePassword 方法，如何更新数据库密码。 4、页面静态化将数据存在浏览器中，主要技术有：AngularJS、Vue.js等此处使用简单的。 服务端不直接返回html，只返回页面上动态的数据。在前端html页面中接受这些动态的数值即可。 思考：如何验证客户端加载了浏览器的本地缓存而不是服务端的数据？\\304状态码表示服务端数据未改变，可直接使用客户端未过期的缓存。304状态码返回时不包含任何响应的主体部分。请求首部包含If-Modified-Since: Mon, 11 Apr 2022 10:07:49 GMT，服务端会和资源的最近更新时间比较，确定是不是需要返回资源。不需要则返回304状态码，具体如下： 123HTTP/1.1 304Last-Modified: Mon, 11 Apr 2022 10:07:49 GMTDate: Mon, 11 Apr 2022 10:10:19 GMT 进一步优化上面虽然没有直接下载服务端的数据，但还是请求了一次服务端。通过在静态资源中添加设置静态资源的有效时间，不访问服务器，直接使用客户端的缓存。\\ 验证查看网页请求，发现响应如下： 1234567HTTP/1.1 200Last-Modified: Mon, 11 Apr 2022 10:07:49 GMTContent-Length: 4818Accept-Ranges: bytesContent-Type: text/htmlCache-Control: max-age=3600Date: Mon, 11 Apr 2022 10:43:17 GMT Cache-Control: max-age=3600字段表示该资源可以在3600ms内复用。 问题1：库存会被减成负值原因：两个人同时减库存时，调用的sql语句如下：1@Update(&quot;update miaosha_goods set stock_count = stock_count - 1 where goods_id = #&#123;goodsId&#125;”) 当只有一个库存时会降为-1，此时可以在sql中加库存大于0的判断如下： 1@Update(&quot;update miaosha_goods set stock_count = stock_count - 1 where goods_id = #&#123;goodsId&#125; and stock_count &gt; 0”)`） 问题2：一个用户购买了两个同一个商品。原因：库存为10，同一个用户同时发出两个请求，同时进入了判断库存等方法，导致一个用户买到两个商品。解决思路：购买流程是：减库存 -&gt; 下订单，下订单的时候有个订单表，有用户id和商品id，此处在订单表中给这两个字段建立联合唯一索引。这样创建订单时，如此该用户存在一个订单，再下另一个订单时就会出现重复。注意：在创建订单的函数前加@Transactional。如果只给用户id建立唯一索引可以不？不行，允许用户秒杀其他商品。 5、静态资源优化 JS/CSS 压缩，减少流浪； 多个 JS/CSS 组合 Tengine 在nginx基础上开发的CDN:内容分发网络。 七、秒杀接口优化方案： 把秒杀商品信息加载到redis，减少mysql的访问。 内存标记，减少一次redis查商品库存的访问：使用map（goodsId -&gt; boolean）， false表示还有库存，true表示没有库存，则秒杀结束。接下来的关于goodsId的请求不在访问redis，直接返回。 通过在redis中预减库存，当库存不足，直接返回，不需要进一步查询Redis中的订单信息，以判断是否秒杀成功。减少了redis的访问。 使用rabbitmq实现异步下单，达到削峰的作用。秒杀流程： 系统初始化，把商品库存数量加载到redis。 收到请求，内存标记，减少redis访问： redis预减库存，如果库存不足，设置该goodsId的map值为true，然后直接返回。 请求入队，立即返回排队中。 请求出队，生成订单，减少库存。 客户端轮询，是否秒杀成功。 环境安装安装 RabbitMQ。 12sudo apt-get install erlangerl 以上命令能正常输出说明erlang安装成功。接下来安装、启动并验证rabbitmq是否在监听5672端口。 123sudo apt-get install rabbitmq-serversudo rabbitmq-servernetstat -nap | grep 5672 关闭rabbitmq。 1sudo rabbitmqctl stop 设置一个 rabbitmq 的用户名和密码，默认存在一个用户 guest，密码为 guest。123rabbitmqctl add_user YOUR_USERNAME YOUR_PASSWORDrabbitmqctl set_user_tags YOUR_USERNAME administratorrabbitmqctl set_permissions -p / YOUR_USERNAME &quot;.*&quot; &quot;.*&quot; &quot;.*&quot; 扩展 Nginx水平扩展。 分库分表 八、安全优化 秒杀接口地址隐藏 数学公式验证码（可以削峰） 接口限流放刷 1、秒杀接口地址隐藏思路：秒杀开始之前，先去请求接口获取秒杀地址。 接口改造，带上PathVariable参数。 添加生成地址的接口。 秒杀收到请求，先验证PathVariable 流程秒杀开始，用户点击秒杀按钮时，在后端使用uuid+DM5生成一个str，并且以用户id_商品id为键，str为值存入redis。前端通过接口请求到这个str，拼接到路径中请求后端。后端取出这个str后和自己生成的oldStr对比（redis中的str），如果一致，则进入秒杀流程。 问题：有人先请求前端的接口得到str，然后去访问秒杀接口，可行吗？？？ 2、数学公式验证码 添加生成验证码的接口。 在获取秒杀路径的时候，验证验证码。 ScriptEngine使用。 流程秒杀开始时，前端请求后端生成验证码，然后将生成的验证码信息以vc_用户id_秒杀商品id -&gt; 验证码结果的形式存储在redis中，同时将验证码发给前端。前端展示给用户，用户输入结果，点击秒杀按钮。前端发送请求给后端（同时包含秒杀地址参数），后端先从redis中取出验证码结果验证是否正确。正确则开始在redis中生成path，并进行下一步操作。 总结秒杀系统设计 负责项目的设计和开发 2022.4 - 2022.5 • 项目介绍：为了解决秒杀商品时存在高并发的问题，本项目基于SpringBoot开发秒杀系统。本人主要负责登录模块、商品列表模块、商品详情模板、订单详情模块、秒杀接口优化部分。 • 主要工作： 实现了隧道代理，支持在 TCP 或 TLS 连接上多次发起 HTTP 请求。 支持指定隧道代理，支持添加首部、日志分级、跳过证书验证、动态 Ip 等功能。 支持用户自主解密 HTTPs 报文。 具有友好的 shell UI，能为用户提供日常使用的 shell 命令。 • 项目成果：通过隧道代理的方式复用 keep 到目标站点之间的 TCP 连接。 • 个人收获：通过隧道代理的方式复用 keep 到目标站点之间的 TCP 连接。 • 相关技术：SpringBoot、MySql、Redis、RabbitMQ、Thymeleaf","categories":[],"tags":[]},{"title":"初识ThreadLocal","date":"2022-04-16T04:22:26.000Z","path":"2022/04/16/初识ThreadLocal/","text":"1、ThreadLocal 使用实例来源：廖雪峰Java教程 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.TimeUnit;public class Main &#123; public static void main(String[] args) throws Exception &#123; ExecutorService es = Executors.newFixedThreadPool(3); String[] users = new String[] &#123; &quot;Bob&quot;, &quot;Alice&quot;, &quot;Tim&quot;, &quot;Mike&quot;, &quot;Lily&quot;, &quot;Jack&quot;, &quot;Bush&quot; &#125;; for (String user : users) &#123; es.submit(new Task(user)); &#125; es.awaitTermination(3, TimeUnit.SECONDS); es.shutdown(); &#125;&#125;class UserContext implements AutoCloseable &#123; // private static final ThreadLocal&lt;String&gt; userThreadLocal = new ThreadLocal&lt;&gt;(); public UserContext(String name) &#123; userThreadLocal.set(name); System.out.printf(&quot;[%s] init user %s...\\n&quot;, Thread.currentThread().getName(), UserContext.getCurrentUser()); &#125; public static String getCurrentUser() &#123; return userThreadLocal.get(); &#125; @Override public void close() &#123; System.out.printf(&quot;[%s] cleanup for user %s...\\n&quot;, Thread.currentThread().getName(), UserContext.getCurrentUser()); userThreadLocal.remove(); &#125;&#125;class Task implements Runnable &#123; final String username; public Task(String username) &#123; this.username = username; &#125; @Override public void run() &#123; try (UserContext ctx = new UserContext(this.username)) &#123; new Task1().process(); new Task2().process(); new Task3().process(); &#125; &#125;&#125;class Task1 &#123; public void process() &#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; &#125; System.out.printf(&quot;[%s] check user %s...\\n&quot;, Thread.currentThread().getName(), UserContext.getCurrentUser()); &#125;&#125;class Task2 &#123; public void process() &#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; &#125; System.out.printf(&quot;[%s] %s registered ok.\\n&quot;, Thread.currentThread().getName(), UserContext.getCurrentUser()); &#125;&#125;class Task3 &#123; public void process() &#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException ignored) &#123; &#125; System.out.printf(&quot;[%s] work of %s has done.\\n&quot;, Thread.currentThread().getName(), UserContext.getCurrentUser()); &#125;&#125; 2、ThreadLocal 结构ThreadLocal类里边定义了一个ThreadLocalMap静态内部类，ThreadLocalMap里边又有一个static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt;{}。除此之外，ThreadLocalMap中定义了private Entry[] table。因此，ThreadLocal的结构如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class ThreadLocal&lt;T&gt; &#123; static ThreadLocalMap createInheritedMap(ThreadLocalMap parentMap) &#123; return new ThreadLocalMap(parentMap); &#125; static class ThreadLocalMap &#123; static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123; /** The value associated with this ThreadLocal. */ Object value; Entry(ThreadLocal&lt;?&gt; k, Object v) &#123; super(k); value = v; &#125; &#125; /** * The initial capacity -- MUST be a power of two. */ private static final int INITIAL_CAPACITY = 16; /** * The table, resized as necessary. * table.length MUST always be a power of two. */ private Entry[] table; /** * The number of entries in the table. */ private int size = 0; /** * The next size value at which to resize. */ private int threshold; // Default to 0 ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123; table = new Entry[INITIAL_CAPACITY]; int i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - 1); table[i] = new Entry(firstKey, firstValue); size = 1; setThreshold(INITIAL_CAPACITY); &#125; // ... &#125; // ...&#125; 内存泄露问题ThreadLocalMap中的key是一个弱引用，垃圾回收时就会被回收。如果ThreadLocalMap对应的线程依旧存活，那么value就依旧具有强引用而不会被回收，从而导致内存泄漏。解决内存泄漏的方法：直接调用remove()方法 (try{}finally{})，将value也置为 NULL。 3、结合Thread理解ThreadLoalThread类中包含一个ThreadLocal.ThreadLocalMap类型的成员变量threadLocals，因此每一个Thread都有一个ThreadLocalMap。 12345public class Thread implements Runnable &#123; /* ThreadLocal values pertaining to this thread. This map is maintained * by the ThreadLocal class. */ ThreadLocal.ThreadLocalMap threadLocals = null;&#125; ThreadLoalset或get时，会先获取当前的thread，其实操作的就是thread的threadLocals,代码如下： 1234567891011121314151617181920212223242526272829public class ThreadLocal&lt;T&gt; &#123; public T get() &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) &#123; ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) &#123; @SuppressWarnings(&quot;unchecked&quot;) T result = (T)e.value; return result; &#125; &#125; return setInitialValue(); &#125; public void set(T value) &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value); &#125; ThreadLocalMap getMap(Thread t) &#123; return t.threadLocals; &#125;&#125; 在set方法中，最终是map.set(this, value)，这儿的this是Thread的一个实例,因此map结构是 (线程 –&gt; Object)。 思考：Entry类数组的作用？参考：1、Guide ThreadLocal 关键字解析","categories":[{"name":"java","slug":"java","permalink":"http://example.com/categories/java/"}],"tags":[]},{"title":"SpringMVC自定义参数解析器","date":"2022-04-15T08:05:04.000Z","path":"2022/04/15/SpringMVC自定义参数解析器/","text":"1、实现参数解析器的接口HandlerMethodArgumentResolverHandlerMethodArgumentResolver接口包含两个方法supportsParameter和resolveArgument。 supportsParameter方法返回 boolean 值，表示是否启用该解析器，true 表示启用，false 表示不启用； resolveArgument 方法表示方法参数的解析过程，就是你把 HTTP 的请求参数转换为方法参数的过程，返回 Object 对象，即参数的转换结果。 源代码如下： 12345public interface HandlerMethodArgumentResolver &#123; boolean supportsParameter(MethodParameter var1); Object resolveArgument(MethodParameter var1, ModelAndViewContainer var2, NativeWebRequest var3, WebDataBinderFactory var4) throws Exception;&#125; 2、自定义一个参数解析器 定义一个方法注解 实现HandlerMethodArgumentResolver接口。 注册参数解析器 使用参数解析器 2.1 定义一个方法注解12345@Retention(RUNTIME)@Target(METHOD)public @interface ParamModel &#123; // 可以定义需要带的参数&#125; 2.2 实现HandlerMethodArgumentResolver接口。在HandlerMethodArgumentResolver接口中实现具体的参数解析。 1234567891011121314151617181920@Servicepublic class UserArgumentResolvers implements HandlerMethodArgumentResolver &#123; @Override public boolean supportsParameter(MethodParameter parameter) &#123; //带有注解就解析，即调用下面的 resolveArgument 方法。 return methodParameter.hasParameterAnnotation(ParamModel.class); &#125; @Override public Object resolveArgument(MethodParameter methodParameter, ModelAndViewContainer modelAndViewContainer, NativeWebRequest webRequest, WebDataBinderFactory webDataBinderFactory) throws Exception &#123; HttpServletRequest request = webRequest.getNativeRequest(HttpServletRequest.class); HttpServletResponse response = webRequest.getNativeResponse(HttpServletResponse.class); // 从request和request中解析出对应的Object。 return null; &#125; 2.3 注册参数解析器1234567891011@Configurationpublic class WebConfig extends WebMvcConfigurerAdapter &#123; @Autowired UserArgumentResolvers userArgumentResolver; @Override public void addArgumentResolvers(List&lt;HandlerMethodArgumentResolver&gt; argumentResolvers) &#123; argumentResolvers.add(userArgumentResolver); &#125;&#125; 2.4 使用参数解析器1234public void getMiaoshaPath(@ParamModel int verifyCode) &#123; // 参数解析的结果会赋值给verifyCode。 // ...&#125;","categories":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://example.com/categories/SpringMVC/"}],"tags":[{"name":"java、SpringMVC、参数解析器","slug":"java、SpringMVC、参数解析器","permalink":"http://example.com/tags/java%E3%80%81SpringMVC%E3%80%81%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%E5%99%A8/"}]},{"title":"SpringMVC实现拦截器","date":"2022-04-15T08:01:11.000Z","path":"2022/04/15/SpringMVC实现拦截器/","text":"1、功能需求在秒杀商品时，需要使用秒杀接口防刷保护程序，可以定义一个拦截器实现。具体使用如下所示： 1@AccessLimit(seconds = 1, maxCount = 100, needLogin = true) 这个拦截器需要当前用户登录，且1s内限制最大请求次数为100。 2、拦截器的主要类HandlerInterceptorAdapterHandlerInterceptorAdapter提供的方法如下： preHandle:方法执行前调用拦截器，返回true，则接续执行，否则不会执行方法。 postHandle:在方法执行后调用。 afterCompletion源代码如下：123456789public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; return true;&#125;public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123;&#125;public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;&#125; 3、实现拦截器 自定义 @AccessLimit 参数解析器。 重写HandlerInterceptorAdapter类的preHandle方法 注册拦截器 使用拦截器 3.1 自定义 @AccessLimit 注解。12345678910/** 定义一个注解*/@Retention(RUNTIME)@Target(METHOD)public @interface AccessLimit &#123; int seconds(); int maxCount(); boolean needLogin() default true;&#125; 3.2 重写preHandle方法123456789101112131415161718192021222324252627282930/** 满足拦截条件 return false;* 不满足拦截条件 return true;*/@Servicepublic class AccessInterceptor extends HandlerInterceptorAdapter &#123; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; if (handler instanceof HandlerMethod)&#123; MiaoshaUser user = getUser(request, response); // 存储user UserContext.setUser(user); // 当前线程就可以取用。 HandlerMethod hm = (HandlerMethod) handler; AccessLimit accessLimit = hm.getMethodAnnotation(AccessLimit.class); // 获取注解 if (accessLimit == null) &#123; // 如果没有限制 return true; &#125; int seconds = accessLimit.seconds(); int maxCount = accessLimit.maxCount(); boolean needLogin = accessLimit.needLogin(); // 具体的拦截逻辑 &#125; return true; &#125;&#125; 3.3 注册拦截器12345678910111213141516@Configurationpublic class WebConfig extends WebMvcConfigurerAdapter &#123; @Autowired AccessInterceptor accessInterceptor; @Override public void addArgumentResolvers(List&lt;HandlerMethodArgumentResolver&gt; argumentResolvers) &#123; argumentResolvers.add(userArgumentResolver); &#125; // 注册拦截器 @Override public void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(new); &#125;&#125; 3.4 使用拦截器1234@AccessLimit(seconds = 1, maxCount = 100, needLogin = true)public void test()&#123; // ...&#125;","categories":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://example.com/categories/SpringMVC/"}],"tags":[{"name":"java，SpringMVC，拦截器","slug":"java，SpringMVC，拦截器","permalink":"http://example.com/tags/java%EF%BC%8CSpringMVC%EF%BC%8C%E6%8B%A6%E6%88%AA%E5%99%A8/"}]},{"title":"java杂项","date":"2022-04-15T07:02:11.000Z","path":"2022/04/15/java杂项/","text":"ThreadLcoal 的用法在秒杀功能中，定义一个static的ThreadLcoal存储MiaoshaUser。当用户点击秒杀按钮时将其存储在ThreadLocal中，该线程以后使用时就可以直接get。 1private static ThreadLocal&lt;MiaoshaUser&gt; userHolder = new ThreadLocal&lt;&gt;(); 如果不这样做，需要每次从请求中解析MiaoshaUser对象,代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243@Servicepublic class UserArgumentResolvers implements HandlerMethodArgumentResolver &#123; @Autowired MiaoshaUserService userService; @Override public boolean supportsParameter(MethodParameter parameter) &#123; // 当为 MiaoshaUser 类型时就执行参数解析，即调用下面的 resolveArgument 方法。 Class&lt;?&gt; clazz = parameter.getParameterType(); return clazz == MiaoshaUser.class; &#125; @Override public Object resolveArgument(MethodParameter methodParameter, ModelAndViewContainer modelAndViewContainer, NativeWebRequest webRequest, WebDataBinderFactory webDataBinderFactory) throws Exception &#123; HttpServletRequest request = webRequest.getNativeRequest(HttpServletRequest.class); HttpServletResponse response = webRequest.getNativeResponse(HttpServletResponse.class); String paramToken = request.getParameter(MiaoshaUserService.COOKI_NAME_TOKEN); String cookieToken = getCookieValue(request, MiaoshaUserService.COOKI_NAME_TOKEN); if (StringUtils.isEmpty(cookieToken) &amp;&amp; StringUtils.isEmpty(paramToken))&#123; return null; &#125; String token = StringUtils.isEmpty(paramToken) ? cookieToken : paramToken; return userService.getByToken(response,token); &#125; private String getCookieValue(HttpServletRequest request, String cookieName) &#123; Cookie[] cookies = request.getCookies(); if (cookies == null || cookies.length &lt;= 0)&#123; return null; &#125; for (Cookie cookie : cookies) &#123; if (cookie.getName().equals(cookieName))&#123; return cookie.getValue(); &#125; &#125; return null; &#125;&#125;","categories":[{"name":"java","slug":"java","permalink":"http://example.com/categories/java/"}],"tags":[{"name":"杂项","slug":"杂项","permalink":"http://example.com/tags/%E6%9D%82%E9%A1%B9/"}]},{"title":"杂项","date":"2022-04-08T03:37:43.000Z","path":"2022/04/08/杂项/","text":"配置环境变量exportexport 表示将该路径添加到环境变量中，打开 vim .zshrc ，添加jmeter的快速启动路径 export JMETER_HOME=/usr/local/apache-jmeter-5.4.3export PATH=$JAVA_HOME/bin:$PATH:.:$JMETER_HOME/bin:$PATHexport CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JMETER_HOME/lib/ext/ApacheJMeter_core.jar:$JMETER_HOME/lib/jorphan.jar:$JMETER_HOME/lib/logkit-2.0.jar source .zshrc 使.zshrc生效。使用 export -p 可以查看当前的环境中的路径。 aliasalias 为指定路径起别名。 export PATH=/usr/local/mysql/bin:$PATH#快速启动、结束MySQL服务, 可以使用alias命令alias mysqlstart=’sudo /usr/local/mysql/support-files/mysql.server start’alias mysqlstop=’sudo /usr/local/mysql/support-files/mysql.server stop’ macOS目录的作用系统硬件相关/cores 内核转储文件存放目录。当一个进程崩溃时，如果系统允许则会产生转储文件。/dev 设备文件存放目录，如何代表硬盘的/dev/disk0。/Network 网络节点存放目录；/Volumes 文件系统挂载点存放目录。 系统配置相关/etc. 标准unix系统配置文件存放目录，如用户密码文件/etc/passwd。此目录实际为指向/private/etc的链接。 系统程序相关/Applications 应用程序目录，默认所有的GUI应用程序都安装在这里；/Library 系统的数据文件、帮助文件、文档等等；/System 只包含一个名为Library的目录，这个子目录中存放了系统的绝大部分组件，如各种framework，以及内核模块，字体文件等等。 系统命令相关/bin 传统unix命令的存放目录，如ls，rm，mv等。/sbin 传统unix管理类命令存放目录，如fdisk，ifconfig等等。 用户信息相关/Users 存放用户的个人资料和配置。每个用户有自己的单独目录。 用户经常使用/usr 第三方程序安装目录。/usr/bin, /usr/sbin, /usr/lib，其中/usr/lib目录中存放了共享库（动态链接库）。/var 存放经常变化的文件，如日志文件。此目录实际为指向/private/var的链接。 /opt/homebrew brew安装的程序一般放这儿。 /private 里面的子目录存放了/tmp, /var, /etc等链接目录的目标目录。/tmp 临时文件存放目录，其权限为所有人任意读写。此目录实际为指向/private/tmp的链接。 其他/installer.failurerequests 可能是用来记录发生crash时的日志。 linux 命令拾遗lsof（list open files）lsof 列出当前系统打开文件的工具。lsof -i :8080 可以查看当前占用8080端口的进程。 ls（list）ls默认情况下用来打印出当前目录的列表。 git流程将写了一半的项目git到空github上。 github上创建同名仓库 git clone到本地 将隐藏的.git文件复制到已经写了一半的project中 git add . git status git commit -m “提交说明” git push","categories":[],"tags":[{"name":"杂项","slug":"杂项","permalink":"http://example.com/tags/%E6%9D%82%E9%A1%B9/"}]},{"title":"hexo github配置博客","date":"2022-04-06T03:44:59.000Z","path":"2022/04/06/hexo github配置博客/","text":"1、 配置环境流程1.1 安装node.js官网下载node.jsnode -vnmp -v 1.2 创建blog目录mkdir /Users/jq/blog 1.3 安装hexonmp install hexo -g hexo-clihexo -v 1.4 VPN设置如果设置了VPN，需要设置环境变量；vim ./~zshrc 123export https_proxy=http://127.0.0.1:7890 http_proxy=http://127.0.0.1:7890 all_proxy=socks5://127.0.0.1:7890source ./~zshrc 1.5 初始化hexosudo susudo hexo init 2、写一个博客流程2.1 开始hexohexo s 2.2 创建一个新博客hexo n “XXXX” 使用vsconde等编写内容。 2.3 清理hexo clean 2.4 生成博客hexo g 2.5 浏览刚才写的博客hexo s 3、配置github3.1 在最后添加1234deploy: type: git repository: git@github.com:jiaoqiang2014/jiaoqiang2014.github.io.git branch: master 4、换主题4.1 下载主题12git clone git@github.com:litten/hexo-theme-yilia.git themes/yiliagit@github.com:yscoder/hexo-theme-indigo.git 4.2 修改_config.yml配置1theme: yilia Hexo clean Hexo g Hero s 5、代码折叠功能6、hexo引用本地图片无法显示问题使用格式为：![图片描述](md文件夹名字/example.jpg) 参考博客：1、 hexo增加分类、标签2、 hexo主题美化3 https://github.com/Neveryu/Neveryu.github.io/blob/","categories":[{"name":"hexo","slug":"hexo","permalink":"http://example.com/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://example.com/tags/hexo/"}]}]