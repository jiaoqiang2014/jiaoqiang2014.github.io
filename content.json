[{"title":"java8新特性","date":"2022-04-28T14:48:18.000Z","path":"2022/04/28/java8新特性/","text":"java8 新特性 接口的默认方法(Default Methods for Interfaces) Lambda表达式 函数式接口 Streams(流) Parallel Streams(并行流) Maps Date API(日期相关API) Annotations(注解) 链接总结的很棒java8 新特性。 接口的默认方法(Default Methods for Interfaces)12345678910111213141516171819202122232425package com.learnjava.java8;public class java8 &#123; public static void main(String[] args) &#123; Formula formula = new Formula() &#123; @Override public double calculate(double a, double b) &#123; return a + b; &#125; &#125;; System.out.println(formula.calculate(10, 12)); //使用 default 关键字向接口添加的非抽象方法可以直接调用 System.out.println(formula.mul(10, 12)); &#125;&#125;@FunctionalInterfaceinterface Formula&#123; double calculate(double a, double b); // Java 8使我们能够通过使用 default 关键字向接口添加非抽象方法实现。 此功能也称为虚拟扩展方法。 default double mul(int a, int b)&#123; return a*b; &#125;&#125; 1","categories":[],"tags":[]},{"title":"gulimall配置","date":"2022-04-20T01:44:14.000Z","path":"2022/04/20/gulimall配置/","text":"1、环境配置 项目结构搭建 配置Mysql 配置renren-fast和renren-fast-vue 高版本的springboot默认不加载bootstrap.yml文件，需要在pom里加上依赖。 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-bootstrap&lt;/artifactId&gt;&lt;/dependency&gt;","categories":[],"tags":[]},{"title":"开发环境安装杂项","date":"2022-04-18T04:12:51.000Z","path":"2022/04/18/开发环境安装杂项/","text":"1、配置git 生成ssh 配置到github 测试 生成ssh1ssh-keygen -t rsa -C &quot;jiaoqiang2014@163.com&quot; 配置到github在~/.ssh目录下生成id_rsa.pub和id_rsa公钥和私钥。打开公钥，复制到github 1cat /Users/jq/.ssh/id_rsa.pub 测试连接1sudo ssh -T git@github.com 如果显示Hi jiaoqiang2014! You&#39;ve successfully authenticated, but GitHub does not provide shell access.表示，使用https没有使用ssh，切换到项目.git同级目录下，设置一下使用ssh就行。 1git remote set-url origin git@github.com:lut/EvolutionApp.git 2、docker 安装使用官方 docker doc 说明安装。 设置docker开机自启动1sudo systemctl enable docker docker安装mysql正常芯片1sudo docker pull mysql:8.0.28 M1芯片1sudo docker pull --platform linux/x86_64 mysql:8.0.28 查看安装的服务1sudo docker images docker 启动 mysql123456sudo docker run -p 3306:3306 --name mysql \\-v /var/mysql/log:/var/log/mysql \\-v /var/mysql/data:/var/lib/mysql \\-v /var/mysql/conf:/etc/mysql \\-e MYSQL_ROOT_PASSWORD=123456aa \\-d mysql:8 上面代码不知道为啥启动不了 1docker run -p 3306:3306 --name mysql -e MYSQL_ROOT_PASSWORD=123456aa -d mysql:8 启动mysql容器1docker start mysql 进入 Mysql 容器1docker exec -it mysql bash navicat 连接 docker mysql在腾讯云选择该服务器——&gt;管理-&gt;防火墙中需要添加 mysql 3306端口的规则，不然会被屏蔽。 安装redis123docker pull redismkdir -p /mydata/redis/conftouch /mydata/redis/conf 启动 redis 镜像 1234docker run -p 6379:6379 --name redis \\-v /mydata/redis/data:/data \\-v /mydata/redis/conf/redis.conf:/etc/redis/redis.conf \\-d redis redis-server /etc/redis/redis.conf 检查redis安装是否成功 123docker exec -it redis redis-cliset key1 111get key1 持久化redisredis重启之后会丢失内存中的数据，可以设置持久化到磁盘中。 1vim /mydata/redis/conf/redis.conf 添加以下内容。 123appendonly yesbind 0.0.0.0 -::1requirepass 123456 给redis存值，重启，检查是否还存在。开启服务端TCP的6379端口。 docker 服务器重启自动启动程序1sudo docker update mysql --restart=always 3、前端项目配置杂项在项目目录下下载需要的组件。 1nmp install 报错 123npm ERR! command failednpm ERR! command sh -c node install.jsnpm ERR! Only Mac 64 bits supported. 使用下面命令可以解决。 123npm install --ignore-scriptsnpm uninstall node-saas //卸载node -saasnpm install node-sass --save-dev //重新安装node -saas 运行前端项目 1npm run dev 如果报错可以试试下面代码。 1npm cache --force clean &amp;&amp; npm install --force node-sass 4、renrenfast生成","categories":[],"tags":[{"name":"杂项","slug":"杂项","permalink":"http://example.com/tags/%E6%9D%82%E9%A1%B9/"}]},{"title":"玩转Spring全家桶学习笔记","date":"2022-04-17T13:21:32.000Z","path":"2022/04/17/玩转Spring全家桶学习笔记/","text":"第二章 JDBC必知必会1、配置单个数据源建立h2、web、lombak的springboot。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package com.example.learn;import com.example.learn.config.ProfileProperties;import com.example.learn.service.LibraryProperties;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.InitializingBean;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.CommandLineRunner;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.EnableAutoConfiguration;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration;import org.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration;import org.springframework.boot.autoconfigure.jdbc.JdbcTemplateAutoConfiguration;import org.springframework.boot.context.properties.EnableConfigurationProperties;import org.springframework.jdbc.core.JdbcTemplate;import javax.sql.DataSource;import java.sql.Connection;import java.sql.SQLException;@SpringBootApplication()public class DemoApplication implements CommandLineRunner &#123; private static final Logger log = LoggerFactory.getLogger(DemoApplication.class); @Autowired DataSource dataSource; @Autowired JdbcTemplate jdbcTemplate; public static void main(String[] args) &#123; SpringApplication.run(DemoApplication.class, args); &#125; @Override public void run(String... args) throws Exception &#123; showConnection(); showData(); &#125; private void showData() &#123; jdbcTemplate.queryForList(&quot;SELECT * FROM FOO&quot;).forEach(row -&gt; log.info(row.toString())); &#125; private void showConnection() throws SQLException &#123; log.info(dataSource.toString()); Connection conn = dataSource.getConnection(); log.info(conn.toString()); conn.close(); &#125;&#125; 在resource目录先创建schema.sql文件，写入： 1CREATE TABLE FOO (ID INT IDENTITY, BAR VARCHAR(64)); 在resource目录先创建data.sql文件，写入： 12INSERT INTO FOO (ID, BAR) VALUES(1, &#x27;aaa&#x27;)INSERT INTO FOO (ID, BAR) VALUES(2, &#x27;bbb&#x27;) 2、配置多个数据源配置文件application.properties中写入数据源的信息。 1234567foo.datasource.url=jdbc:h2:mem:foofoo.datasource.username=safoo.datasource.password=bar.datasource.url=jdbc:h2:mem:barbar.datasource.username=sabar.datasource.password= 需要指定使用什么连接池：COMMONS-DBCP、TOMCAT-JDBC、HIKARICP。 12345&lt;dependency&gt; &lt;groupId&gt;com.zaxxer&lt;/groupId&gt; &lt;artifactId&gt;HikariCP&lt;/artifactId&gt; &lt;version&gt;3.2.0&lt;/version&gt;&lt;/dependency&gt; 配置数据源 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475package multiDatasource;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.CommandLineRunner;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration;import org.springframework.boot.autoconfigure.jdbc.DataSourceProperties;import org.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration;import org.springframework.boot.autoconfigure.jdbc.JdbcTemplateAutoConfiguration;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.context.annotation.Bean;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.jdbc.datasource.DataSourceTransactionManager;import org.springframework.transaction.PlatformTransactionManager;import javax.annotation.Resource;import javax.sql.DataSource;import java.sql.Connection;import java.sql.SQLException;// 排除自动配置，进行手动配置@SpringBootApplication(exclude = &#123;DataSourceAutoConfiguration.class, DataSourceTransactionManagerAutoConfiguration.class, JdbcTemplateAutoConfiguration.class&#125;)public class MultiDataSourceApplication &#123; private static final Logger log = LoggerFactory.getLogger(MultiDataSourceApplication.class); public static void main(String[] args) &#123; SpringApplication.run(MultiDataSourceApplication.class, args); &#125; @Bean @ConfigurationProperties(&quot;foo.datasource&quot;) public DataSourceProperties fooDataSourceProperties()&#123; return new DataSourceProperties(); &#125; @Bean public DataSource fooDataSource()&#123; DataSourceProperties dataSourceProperties = fooDataSourceProperties(); log.info(&quot;foo datasource:&#123;&#125;&quot;, dataSourceProperties.getUrl()); return dataSourceProperties.initializeDataSourceBuilder().build(); &#125; @Bean @Resource public PlatformTransactionManager fooTxManager(DataSource fooDataSource)&#123; return new DataSourceTransactionManager(fooDataSource); &#125; @Bean @ConfigurationProperties(&quot;bar.datasource&quot;) public DataSourceProperties barDataSourceProperties()&#123; return new DataSourceProperties(); &#125; @Bean public DataSource barDataSource()&#123; DataSourceProperties dataSourceProperties = barDataSourceProperties(); log.info(&quot;bar datasource:&#123;&#125;&quot;, dataSourceProperties.getUrl()); return dataSourceProperties.initializeDataSourceBuilder().build(); &#125; @Bean @Resource public PlatformTransactionManager barTxManager(DataSource barDataSource)&#123; return new DataSourceTransactionManager(barDataSource); &#125;&#125; 3、数据库连接池推荐 druid：快 HikariCP：监控、SQL防注入 4、JdbcTemplate 的使用首先，添加H2数据库的依赖。 12345&lt;dependency&gt; &lt;groupId&gt;com.h2database&lt;/groupId&gt; &lt;artifactId&gt;h2&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt; 然后,创建和表对应的Entiy。 1234567@Data@Builderpublic class Foo &#123; private Long id; private String bar;&#125; 接下来，完成数据库的查询，添加等功能。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package simplejdbcdemo;import lombok.extern.slf4j.Slf4j;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.jdbc.core.RowMapper;import org.springframework.jdbc.core.simple.SimpleJdbcInsert;import org.springframework.stereotype.Repository;import javax.swing.*;import java.sql.ResultSet;import java.sql.SQLException;import java.util.Arrays;import java.util.HashMap;import java.util.List;@Slf4j@Repositorypublic class FooDao &#123; @Autowired private JdbcTemplate jdbcTemplate; @Autowired private SimpleJdbcInsert simpleJdbcInsert; public void insertData()&#123; // 方法一：使用jdbcTemplate Arrays.asList(&quot;a&quot;, &quot;b&quot;).forEach(bar -&gt; &#123; jdbcTemplate.update(&quot;insert into Foo (bar) values (?)&quot;, bar); &#125;); //方法二：使用simpleJdbcInsert HashMap&lt;String, String&gt; row = new HashMap&lt;&gt;(); row.put(&quot;bar&quot;, &quot;d&quot;); Number id = simpleJdbcInsert.executeAndReturnKey(row); log.info(&quot;ID of d: &#123;&#125;&quot;, id.longValue()); &#125; public void listData()&#123; log.info(&quot;Count: &#123;&#125;&quot;,jdbcTemplate.queryForObject(&quot;select count(*) from foo&quot;, Long.class)); List&lt;String&gt; list = jdbcTemplate.queryForList(&quot;select bar from foo&quot;, String.class); list.forEach(s -&gt; &#123;log.info(&quot;Bar: &#123;&#125;&quot;, s);&#125;); List&lt;Foo&gt; fooList = jdbcTemplate.query(&quot;select * from foo&quot;, new RowMapper&lt;Foo&gt;() &#123; @Override public Foo mapRow(ResultSet rs, int rowNum) throws SQLException &#123; return Foo.builder().id(rs.getLong(1)).bar(rs.getString(2)).build(); &#125; &#125;); fooList.forEach(f -&gt; log.info(&quot;Foo: &#123;&#125;&quot;, f)); &#125;&#125; 最后，在程序入口调用数据库操作。 1234567891011121314151617181920212223242526272829303132333435363738package simplejdbcdemo;import lombok.extern.slf4j.Slf4j;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.CommandLineRunner;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.context.annotation.Bean;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.jdbc.core.simple.SimpleJdbcInsert;@Slf4j@SpringBootApplicationpublic class SiampleJdbcDemoApplication implements CommandLineRunner &#123; public static void main(String[] args) &#123; SpringApplication.run(SiampleJdbcDemoApplication.class, args); &#125; @Autowired FooDao fooDao; @Bean @Autowired public SimpleJdbcInsert simpleJdbcInsert(JdbcTemplate jdbcTemplate) &#123; // 将 FOO 和 ID 绑定。 return new SimpleJdbcInsert(jdbcTemplate) .withTableName(&quot;FOO&quot;).usingGeneratedKeyColumns(&quot;ID&quot;); &#125; @Override public void run(String... args) throws Exception &#123; fooDao.insertData(); fooDao.listData(); &#125;&#125; 5、NamedParameterJdbcTemplate6、事务 编程式事务 声明式事务（推荐使用）编程式事务 TransactionTemplate PlatformTransactionTemplate 引入H2数据库的依赖。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package transaction;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.CommandLineRunner;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.transaction.TransactionStatus;import org.springframework.transaction.support.TransactionCallbackWithoutResult;import org.springframework.transaction.support.TransactionTemplate;import javax.sql.DataSource;import java.sql.Connection;import java.sql.SQLException;import java.util.List;@SpringBootApplication()public class TransactionDemoApplication implements CommandLineRunner &#123; private static final Logger log = LoggerFactory.getLogger(TransactionDemoApplication.class); @Autowired JdbcTemplate jdbcTemplate; @Autowired TransactionTemplate transactionTemplate; public static void main(String[] args) &#123; SpringApplication.run(TransactionDemoApplication.class, args); &#125; @Override public void run(String... args) throws Exception &#123; log.info(&quot;count before transaction: &#123;&#125;&quot;, getCount()); transactionTemplate.execute(new TransactionCallbackWithoutResult() &#123; @Override protected void doInTransactionWithoutResult(TransactionStatus status) &#123; jdbcTemplate.execute(&quot;INSERT INTO FOO (ID, BAR) VALUES (1, &#x27;AAA&#x27;)&quot;); log.info(&quot;count in transaction: &#123;&#125;&quot;, getCount()); status.setRollbackOnly(); &#125; &#125;); log.info(&quot;count after transaction: &#123;&#125;&quot;, getCount()); &#125; private long getCount()&#123;// List&lt;Integer&gt; list = jdbcTemplate.queryForList(&quot;select count(*) as cnt from FOO&quot;, Integer.class);// log.info(String.valueOf(list.get(0))); return (long)jdbcTemplate.queryForList(&quot;select count(*) as cnt from FOO&quot;).get(0).get(&quot;cnt&quot;); &#125;&#125; 声明式事务在 XML 配置文件中配置或者基于注解，实际是通过 AOP 实现（基于@Transactional 的全注解方式使用最多）。 测试声明式事务核心方法。 123456789101112131415161718192021222324252627282930313233343536package DeclarativeTransaction;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.stereotype.Component;import org.springframework.transaction.annotation.Transactional;@Componentpublic class FooServiceImpl implements FooService &#123; @Autowired JdbcTemplate jdbcTemplate; @Autowired FooService fooService; @Override @Transactional public void insertRecord() &#123; jdbcTemplate.execute(&quot;INSERT INTO FOO (BAR) VALUES (&#x27;AAA&#x27;)&quot;); &#125; @Override @Transactional(rollbackFor = RollbackException.class) public void insertThenRollback() throws RollbackException &#123; jdbcTemplate.execute(&quot;INSERT INTO FOO (BAR) VALUES (&#x27;BBB&#x27;)&quot;); throw new RollbackException(); &#125; @Override public void invokeInsertThenRollback() throws RollbackException &#123; // 思考这两个方法的不同。// insertThenRollback(); fooService.insertThenRollback(); &#125;&#125; 开始调用时需要开启事务注解。 123456789101112131415161718192021222324252627282930313233343536373839404142434445package DeclarativeTransaction;import lombok.extern.slf4j.Slf4j;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.CommandLineRunner;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.context.annotation.AdviceMode;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.transaction.annotation.EnableTransactionManagement;@SpringBootApplication@Slf4j@EnableTransactionManagement(mode = AdviceMode.PROXY) // 开启事务注解public class DeclarativeTransactionDemoApplication implements CommandLineRunner &#123; @Autowired FooService fooService; @Autowired JdbcTemplate jdbcTemplate; public static void main(String[] args) &#123; SpringApplication.run(DeclarativeTransactionDemoApplication.class, args); &#125; @Override public void run(String... args) throws Exception &#123; fooService.insertRecord(); log.info(&quot;AAA: &#123;&#125;&quot;, jdbcTemplate. queryForObject(&quot;SELECT COUNT(*) FROM FOO WHERE BAR=&#x27;AAA&#x27;&quot;, Long.class)); try &#123; fooService.insertThenRollback(); &#125; catch (RollbackException e) &#123; log.info(&quot;BBB &#123;&#125;&quot;,jdbcTemplate.queryForObject(&quot;SELECT COUNT(*) FROM FOO WHERE BAR=&#x27;BBB&#x27;&quot;, Long.class)); &#125; try &#123; fooService.invokeInsertThenRollback(); &#125; catch (RollbackException e) &#123; log.info(&quot;BBB &#123;&#125;&quot;,jdbcTemplate.queryForObject(&quot;SELECT COUNT(*) FROM FOO WHERE BAR=&#x27;BBB&#x27;&quot;, Long.class)); &#125; &#125;&#125; 定义的接口。 12345678package DeclarativeTransaction;public interface FooService &#123; public void insertRecord(); public void insertThenRollback() throws RollbackException; public void invokeInsertThenRollback() throws RollbackException;&#125; 定义的异常。 1234package DeclarativeTransaction;public class RollbackException extends Throwable &#123;&#125; 事务的传播特性TransactionDefinition.PROPAGATION_REQUIRED使用的最多的一个事务传播行为，我们平时经常使用的@Transactional注解默认使用就是这个事务传播行为。如果当前存在事务，则加入该事务，不会创建新事务；如果当前没有事务，则创建一个新的事务。 TransactionDefinition.PROPAGATION_REQUIRES_NEW始终新起一个事务，两个事务没有关联。 TransactionDefinition.PROPAGATION_NESTED 有事务：在原事务内启动一个内嵌事务。两个事务有关联，外部事务回滚，内嵌事务也会回滚。 TransactionDefinition.PROPAGATION_MANDATORY如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。（mandatory：强制性） 代码实例如下： 1234567891011121314151617181920212223242526272829303132333435363738package DeclarativeTransaction;import lombok.extern.slf4j.Slf4j;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.stereotype.Component;import org.springframework.transaction.annotation.Propagation;import org.springframework.transaction.annotation.Transactional;@Slf4j@Componentpublic class FooServiceImpl implements FooService &#123; @Autowired JdbcTemplate jdbcTemplate; @Autowired FooService fooService; @Override @Transactional(rollbackFor = RollbackException.class, propagation = Propagation.REQUIRES_NEW) public void insertThenRollback() throws RollbackException &#123; jdbcTemplate.execute(&quot;INSERT INTO FOO (BAR) VALUES (&#x27;BBB&#x27;)&quot;); // throw new RollbackException(); &#125; @Override @Transactional(rollbackFor = RollbackException.class) public void invokeInsertThenRollback() throws RollbackException &#123; jdbcTemplate.execute(&quot;INSERT INTO FOO (BAR) VALUES (&#x27;AAA&#x27;)&quot;); try &#123; fooService.insertThenRollback(); &#125;catch (RollbackException e)&#123; log.error(&quot;RollbackException&quot;, e); &#125; throw new RollbackException(); &#125;&#125; 7、慢 SQL 日志开启慢 SQL 日志，设置超过 100ms 的sql为慢sql。 12spring.datasource.druid.filter.stat.log-slow-sql=truespring.datasource.druid.filter.stat.slow-sql-millis=100 测试代码如下： 123456789@Override@Transactionalpublic void selectForUpdate()&#123; jdbcTemplate.queryForObject(&quot;select id from foo where id = 1 for update&quot;, Long.class); try&#123; Thread.sleep(200); &#125;catch (InterruptedException e)&#123; &#125;&#125; 调用代码如下： 1234567891011121314151617181920212223242526272829303132333435363738package DeclarativeTransaction;import lombok.extern.slf4j.Slf4j;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.CommandLineRunner;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.context.annotation.AdviceMode;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.transaction.annotation.EnableTransactionManagement;import javax.sql.DataSource;@SpringBootApplication@Slf4j@EnableTransactionManagement(mode = AdviceMode.PROXY) // 开启事务注解public class DeclarativeTransactionDemoApplication implements CommandLineRunner &#123; @Autowired FooService fooService; @Autowired JdbcTemplate jdbcTemplate; @Autowired DataSource dataSource; public static void main(String[] args) &#123; SpringApplication.run(DeclarativeTransactionDemoApplication.class, args); &#125; @Override public void run(String... args) throws Exception &#123; log.info(dataSource.toString()); new Thread(() -&gt; fooService.selectForUpdate()).start(); new Thread(() -&gt; fooService.selectForUpdate()).start(); &#125;&#125; 控制台输出 1c.alibaba.druid.filter.stat.StatFilter: slow sql 212 millis. select id from foo where id = 1 for update[] 第三章 O/R Mapping 实践 ORM（Object/Relational Mapping）”对象-关系映射”。简单说，ORM 就是通过实例对象的语法，完成关系型数据库的操作的技术。 推荐阅读: JPA、Hibernate、Spring Data JPA之间的关系 1、Spring Data JPAJava 持久层框架访问数据库的方式大致分为两种。一种以 SQL 核心，封装一定程度的 JDBC 操作，比如： MyBatis。另一种是以 Java 实体类为核心，将实体类的和数据库表之间建立映射关系，也就是我们说的ORM框架，如：Hibernate、Spring Data JPA（Java Persistence API Java持久层API）。 Spring Data JPA 提供的支持 @EnableJpaRepositories Repository 接口： CrudRepository&lt;T, ID&gt; PagingAndSortingRepository&lt;T, ID&gt; JpaRepository&lt;T, ID&gt; Repository 实现类： SimpleJpaRepository QueryDslJpaRepository 2、使用 Spring Data JPA 操作数据库创建实体（表）使用SpringBoot内嵌的H2数据库。创建一个咖啡表和一个咖啡订单表。咖啡表 123456789101112131415161718192021222324252627282930package com.jq.coffe.model;import lombok.*;import lombok.extern.slf4j.Slf4j;import org.hibernate.annotations.CreationTimestamp;import org.hibernate.annotations.Type;import org.hibernate.annotations.UpdateTimestamp;import org.joda.money.Money;import javax.persistence.*;import java.io.Serializable;import java.util.Date;@Data@Entity // 实体@Table(name = &quot;T_MENU&quot;)@Builder // @Builder声明表示实体可以使用Builder方式初始化@Slf4j@NoArgsConstructor@AllArgsConstructor@ToString(callSuper = true)public class Coffee extends BaseEntity implements Serializable &#123; private String name; @Column @Type(type = &quot;org.jadira.usertype.moneyandcurrency.joda.PersistentMoneyMinorAmount&quot;, parameters = &#123;@org.hibernate.annotations.Parameter(name = &quot;currencyCode&quot;, value = &quot;CNY&quot;)&#125;) private Money price;&#125; 咖啡订单表 1234567891011121314151617181920212223242526272829303132333435363738package com.jq.coffe.model;import com.jq.coffe.model.BaseEntity;import com.jq.coffe.model.Coffee;import com.jq.coffe.model.OrderState;import lombok.AllArgsConstructor;import lombok.Builder;import lombok.Data;import lombok.NoArgsConstructor;import lombok.ToString;import javax.persistence.Column;import javax.persistence.Entity;import javax.persistence.Enumerated;import javax.persistence.JoinTable;import javax.persistence.ManyToMany;import javax.persistence.OrderBy;import javax.persistence.Table;import java.io.Serializable;import java.util.List;@Entity@Table(name = &quot;T_ORDER&quot;)@Data@ToString(callSuper = true)@NoArgsConstructor@AllArgsConstructor@Builderpublic class CoffeeOrder extends BaseEntity implements Serializable &#123; private String customer; @ManyToMany @JoinTable(name = &quot;T_ORDER_COFFEE&quot;) // 创建一个 T_ORDER_COFFEE 表 @OrderBy(&quot;id&quot;) private List&lt;Coffee&gt; items; @Enumerated @Column(nullable = false) // 可以为空 private OrderState state;&#125; 父类 1234567891011121314151617181920212223242526272829package com.jq.coffe.model;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;import org.hibernate.annotations.CreationTimestamp;import org.hibernate.annotations.Type;import org.hibernate.annotations.UpdateTimestamp;import org.joda.money.Money;import javax.persistence.*;import java.io.Serializable;import java.util.Date;// 编写一个父类,将这些共同属性放到这个父类中, 并且在父类上加上@MappedSuperclass注解.注意:标注为@MappedSuperclass的类将不是一个完整的实体类，他将不会映射到数据库表，但是他的属性都将映射到其子类的数据库字段中。@MappedSuperclass @Data@NoArgsConstructor@AllArgsConstructorpublic class BaseEntity implements Serializable &#123; @Id // 表示主键 @GeneratedValue // 主键生成规则 private Long id; @Column(updatable = false) // 不可以更新 @CreationTimestamp private Date createTime; @UpdateTimestamp private Date updateTime;&#125; 实现 操作数据库的接口这些接口的命名是固定好的，只要按规定格式命名，Spring Boot JPA 就会帮我们做具体操作数据库的逻辑。 123456789package com.jq.coffe.repository;import org.springframework.data.repository.NoRepositoryBean;import org.springframework.data.repository.PagingAndSortingRepository;import java.util.List;@NoRepositoryBean // 表示不会作为一个Beanpublic interface BaseRepository&lt;T, Long&gt; extends PagingAndSortingRepository&lt;T, Long&gt; &#123; List&lt;T&gt; findTop3ByOrderByUpdateTimeDescIdAsc();&#125; 操作咖啡表的接口 12345package com.jq.coffe.repository;import com.jq.coffe.model.Coffee;public interface CoffeeRepository extends BaseRepository&lt;Coffee, Long&gt; &#123;&#125; 操作咖啡订单表的接口 123456789package com.jq.coffe.repository;import com.jq.coffe.model.CoffeeOrder;import org.springframework.data.repository.CrudRepository;import java.util.List;public interface CoffeeOrderRepository extends BaseRepository&lt;CoffeeOrder, Long&gt; &#123; List&lt;CoffeeOrder&gt; findByCustomerOrderById(String customer); List&lt;CoffeeOrder&gt; findByItems_Name(String name);&#125; 测试代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104package com.jq.coffe;import com.jq.coffe.model.Coffee;import com.jq.coffe.model.CoffeeOrder;import com.jq.coffe.model.OrderState;import com.jq.coffe.repository.CoffeeOrderRepository;import com.jq.coffe.repository.CoffeeRepository;import lombok.extern.slf4j.Slf4j;import org.joda.money.CurrencyUnit;import org.joda.money.Money;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.ApplicationArguments;import org.springframework.boot.ApplicationRunner;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.data.domain.Sort;import org.springframework.data.jpa.repository.config.EnableJpaRepositories;import org.springframework.transaction.annotation.EnableTransactionManagement;import org.springframework.transaction.annotation.Transactional;import java.util.Arrays;import java.util.Collections;import java.util.List;import java.util.stream.Collectors;@SpringBootApplication@Slf4j@EnableJpaRepositories@EnableTransactionManagementpublic class CoffeApplication implements ApplicationRunner &#123; @Autowired CoffeeRepository coffeeRepository; @Autowired CoffeeOrderRepository orderRepository; public static void main(String[] args) &#123; SpringApplication.run(CoffeApplication.class, args); &#125; @Override @Transactional public void run(ApplicationArguments args) throws Exception &#123; initOrders(); findOrders(); &#125; private void initOrders()&#123; Coffee espresso = Coffee.builder().name(&quot;espresso&quot;) .price(Money.of(CurrencyUnit.of(&quot;CNY&quot;), 20.0)) .build(); coffeeRepository.save(espresso); log.info(&quot;Coffee: &#123;&#125;&quot;, espresso); Coffee latte = Coffee.builder().name(&quot;latte&quot;) .price(Money.of(CurrencyUnit.of(&quot;CNY&quot;), 30.0)) .build(); coffeeRepository.save(latte); log.info(&quot;Coffee: &#123;&#125;&quot;, latte); CoffeeOrder order = CoffeeOrder.builder() .customer(&quot;Li Lei&quot;) .items(Collections.singletonList(espresso)) // 创建不可变List的单个元素 .state(OrderState.INIT) .build(); orderRepository.save(order); log.info(&quot;Order: &#123;&#125;&quot;, order); order = CoffeeOrder.builder() .customer(&quot;Li Lei&quot;) .items(Arrays.asList(espresso, latte)) .state(OrderState.INIT) .build(); orderRepository.save(order); log.info(&quot;Order: &#123;&#125;&quot;, order); &#125; private void findOrders() &#123; coffeeRepository .findAll(Sort.by(Sort.Direction.DESC, &quot;id&quot;)) .forEach(c -&gt; log.info(&quot;Loading &#123;&#125;&quot;, c)); List&lt;CoffeeOrder&gt; list = orderRepository.findTop3ByOrderByUpdateTimeDescIdAsc(); log.info(&quot;findTop3ByOrderByUpdateTimeDescIdAsc: &#123;&#125;&quot;, getJoinedOrderId(list)); list = orderRepository.findByCustomerOrderById(&quot;Li Lei&quot;); log.info(&quot;findByCustomerOrderById: &#123;&#125;&quot;, getJoinedOrderId(list)); // 不开启事务会因为没Session而报LazyInitializationException list.forEach(o -&gt; &#123; log.info(&quot;Order &#123;&#125;&quot;, o.getId()); o.getItems().forEach(i -&gt; log.info(&quot; Item &#123;&#125;&quot;, i)); &#125;); list = orderRepository.findByItems_Name(&quot;latte&quot;); log.info(&quot;findByItems_Name: &#123;&#125;&quot;, getJoinedOrderId(list)); &#125; private String getJoinedOrderId(List&lt;CoffeeOrder&gt; list) &#123; return list.stream().map(o -&gt; o.getId().toString()) .collect(Collectors.joining(&quot;,&quot;)); &#125;&#125; 3、MyBatis 操作数据库 代码仓库 一款持久化框架，支持定制化SQL、存储过程和高级映射。JPA中SQL是框架自动生成的，MyBatis是自己手写的。 定义Coffee，其中 Price 使用Joda-Money。 12345678910111213141516171819202122package com.example.mybatis.model;import lombok.AllArgsConstructor;import lombok.Builder;import lombok.Data;import lombok.NoArgsConstructor;import org.joda.money.Money;import java.util.Date;@Data@AllArgsConstructor@NoArgsConstructor@Builderpublic class Coffee &#123; private Long id; private String name; private Money price; private Date createTime; private Date updateTime;&#125; 创建表：新建 schema.sql 文件 12345678create table t_coffee ( id bigint not null auto_increment, name varchar(255), price bigint not null, create_time timestamp, update_time timestamp, primary key (id)); Mapper sql语句 123456789101112131415161718192021222324package com.example.mybatis.mapper;import com.example.mybatis.model.Coffee;import org.apache.ibatis.annotations.*;@Mapperpublic interface CoffeeMapper &#123; // insert into t_coffee (name, price, create_time, update_time) values (&quot;latte&quot;,30.0, &#x27;2022-05-06&#x27;, &#x27;2022-05-06&#x27;); @Insert(&quot;insert into t_coffee (name, price, create_time, update_time) values (#&#123;name&#125;, #&#123;price&#125;, #&#123;createTime&#125;, #&#123;updateTime&#125;)&quot;) @Options(useGeneratedKeys = true, keyColumn = &quot;id&quot;, keyProperty = &quot;id&quot;) // 指定在数据库中的字段名 id，实例对象中主键的属性名 id。 int save(Coffee coffee); // 返回的是变动记录的条数 // select * from t_coffee where id = #&#123;id&#125; @Select(&quot;select * from t_coffee where id = #&#123;id&#125;&quot;) @Results(&#123; @Result(id = true, column = &quot;id&quot;, property = &quot;id&quot;), @Result(column = &quot;create_time&quot;, property = &quot;createTime&quot;), // 实例对象名字为 create_time，数据库中名字为 createTime。 // map-underscore-to-camel-case = true 可以实现一样的效果 // @Result(column = &quot;update_time&quot;, property = &quot;updateTime&quot;) &#125;) // @Param(&quot;id&quot;)对应where id = #&#123;id&#125;里的#&#123;id&#125;，给个例子，万一大家以后变量名和参数名不一样，也好知道怎么写。 Coffee findById(@Param(&quot;id&quot;) Long id);&#125; 引入类型转换的配置 1234# 表示是类型转化时包的前缀mybatis.type-handlers-package=com.example.mybatis.handler# 将下划线转化为驼峰规则mybatis.configuration.map-underscore-to-camel-case=true 定义自己的handle，用于处理Money的类型转换（类中使用 Money 类型的price，数据库中使用 bigint 类型的price） 123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.example.mybatis.handler;import org.apache.ibatis.type.BaseTypeHandler;import org.apache.ibatis.type.JdbcType;import org.joda.money.CurrencyUnit;import org.joda.money.Money;import java.sql.CallableStatement;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;/** * 类中使用 Money 类型的price，数据库中使用 bigint 类型的price。 * mybatis在没有配置handler时，会根据参数或者返回结果的不同，默认为我们选择合适的TypeHandler处理。 * 当我们需要特殊的字段处理时，可以配置自己的handler。 * 首先，在配置文件中引入 配置的包。 * 然后，实现 BaseTypeHandler 接口完成自己的类。 * 在 Money 与 Long 之间转换的 TypeHandler，处理 CNY 人民币 */public class MoneyTypeHandler extends BaseTypeHandler&lt;Money&gt; &#123; @Override public void setNonNullParameter(PreparedStatement ps, int i, Money parameter, JdbcType jdbcType) throws SQLException &#123; ps.setLong(i, parameter.getAmountMinorLong()); &#125; @Override public Money getNullableResult(ResultSet rs, String columnName) throws SQLException &#123; return parseMoney(rs.getLong(columnName)); &#125; @Override public Money getNullableResult(ResultSet rs, int columnIndex) throws SQLException &#123; return parseMoney(rs.getLong(columnIndex)); &#125; @Override public Money getNullableResult(CallableStatement cs, int columnIndex) throws SQLException &#123; return parseMoney(cs.getLong(columnIndex)); &#125; private Money parseMoney(Long value) &#123; return Money.of(CurrencyUnit.of(&quot;CNY&quot;), value / 100.0); &#125;&#125; 调用代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.example.mybatis;import com.example.mybatis.mapper.CoffeeMapper;import com.example.mybatis.model.Coffee;import lombok.extern.slf4j.Slf4j;import org.apache.ibatis.annotations.Mapper;import org.joda.money.CurrencyUnit;import org.joda.money.Money;import org.mybatis.spring.annotation.MapperScan;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.ApplicationArguments;import org.springframework.boot.ApplicationRunner;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplication@Slf4j@MapperScan(&quot;com.example.mybatis.mapper&quot;) // 扫描对应包里边的mapper映射public class MybatisApplication implements ApplicationRunner &#123; @Autowired CoffeeMapper coffeeMapper; public static void main(String[] args) &#123; SpringApplication.run(MybatisApplication.class, args); &#125; @Override public void run(ApplicationArguments args) throws Exception &#123; // 将 name 的值设置为 espresso，将price的值设置为 20.0。和sql中的$&#123;name&#125;和$&#123;price&#125;对应。 // @Insert(&quot;insert into t_coffee (name, price, create_time, update_time) values (#&#123;name&#125;, #&#123;price&#125;, now(), now())&quot;) Coffee coffee = Coffee.builder().name(&quot;espresso&quot;) .price(Money.of(CurrencyUnit.of(&quot;CNY&quot;), 20.0)) .createTime(new Date()) .updateTime(new Date()) .build(); int count = coffeeMapper.save(coffee); log.info(&quot;Save &#123;&#125; Coffee: &#123;&#125;&quot;, count, coffee); coffee = Coffee.builder().name(&quot;latte&quot;) .price(Money.of(CurrencyUnit.of(&quot;CNY&quot;), 25.0)) .createTime(new Date()) .updateTime(new Date()).build(); count = coffeeMapper.save(coffee); log.info(&quot;Save &#123;&#125; Coffee: &#123;&#125;&quot;, count, coffee); coffeeMapper.findById(coffee.getId()); log.info(&quot;Find Coffee: &#123;&#125;&quot;, coffee); &#125;&#125; 4、MaBatis Generator代码仓库 5、MaBatis PageHelper代码仓库 第四章 NoSQL 实践1、docker 的一些环境安装1docker run --name mongo -p 27017:27017 -v ~/docker-data/mongo:/data/db -e MONGO_INITDB_ROOT_USERNAME=admin -e MONGO_INITDB_ROOT_PASSWORD=admin -d mongo 2、MongoDBMongoDB 是一款开源的文档型数据库。Spring 对 MongoDB 的支持： Spring Data MongoDB MongoTemplate Repository 支持 注解 @Document 和 @Entity 类似，表示类是一个文档（@Entity中是表） @Id 每个文档都会对应一个 Id ，通过@Id表明类中哪一个属性是id。加上 @Id 之后，Spring Data Mongo 会将属性的类型转化为 MongoDB 中的 object ID。 MongoTemplate save / remove Criteria / Query / Update Spring Data MongoDB 的 Repository @EnableMongoRepositories 对应接口 MongoRepository&lt;T, ID&gt; PagingAndSortingRepository&lt;T, ID&gt; CrudRepository&lt;T, ID&gt; 3、Spring 中访问 MongoDB代码仓库 3.1 安装 MongoDB使用 docker 安装。 1234567891011121314151617181920212223242526272829docker pull Mongodocker exec -it mongo bashmongo -u admin -p admin// 显示当前存在的库show dbs// 使用springbucks库，没有会默认创建一个use springbucks// 创建 createUser，用户名和密码都为springbucks。db.createUser( &#123; user: &quot;springbucks&quot;, pwd: &quot;springbucks&quot;, roles: [ &#123;role: &quot;readWrite&quot;, db: &quot;springbucks&quot;&#125; ] &#125;)show usersshow collections;db.coffee.find();// 删除 coffee 中所有名为 espresso 的 Document 。db.coffee.remove(&#123;&quot;name&quot;:&quot;espresso&quot;&#125;); 3.2 基于 MongoTemplate 的方法创建 Coffee 类1234567891011121314151617181920212223242526package com.example.mongo.model;import lombok.AllArgsConstructor;import lombok.Builder;import lombok.Data;import lombok.NoArgsConstructor;import org.joda.money.Money;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.data.annotation.Id;import org.springframework.data.mongodb.core.mapping.Document;import java.util.Date;// 表示类是一个文档@Document@Data@AllArgsConstructor@NoArgsConstructor@Builderpublic class Coffee &#123; @Id private String id; // 加上 @Id 之后，Spring Data Mongo 会将String类型转化为 MongoDB 中的 object ID。 private String name; private Money price; private Date createTime; private Date updateTime;&#125; 配置 MongoDB123# 用户名密码对应 springbucks:springbucks ，使用 springbucks 库。spring.data.mongodb.uri=mongodb://springbucks:springbucks@124.220.171.2:27017/springbucksspring.main.allow-circular-references=true 编写特殊类型 Money 的转化代码（ Mongo -&gt; Money 类型）从 Money 类型转化为 Mongo 中的 Document 是自动转化的，不需要我们自己手写。其实就是转化为 Dson 类型（和json相似）。mongo 中存储的 Coffee 对象格式如下，这是一条 Document 123456789101112131415&#123; &quot;_id&quot; : ObjectId(&quot;626b59f24eb80121ff790475&quot;),&quot;name&quot; : &quot;espresso&quot;,&quot;price&quot; : &#123; &quot;money&quot; : &#123; &quot;currency&quot; : &#123; &quot;code&quot; : &quot;CNY&quot;, &quot;numericCode&quot; : 156, &quot;decimalPlaces&quot; : 2 &#125;, &quot;amount&quot; : &quot;20.00&quot; &#125; &#125;,&quot;createTime&quot; : ISODate(&quot;2022-04-29T03:22:26.240Z&quot;),&quot;updateTime&quot; : ISODate(&quot;2022-04-29T03:22:26.240Z&quot;),&quot;_class&quot; : &quot;com.example.mongo.model.Coffee&quot; &#125; Mongo -&gt; Money 类型 123456789101112131415161718192021package com.example.mongo.converter;import org.bson.Document;import org.joda.money.CurrencyUnit;import org.joda.money.Money;import org.springframework.core.convert.converter.Converter;/** Document 转化为 Money。* */public class MoneyReadConverter implements Converter&lt;Document, Money&gt; &#123; @Override public Money convert(Document source) &#123; // Mongo 取出 Document 的数据，从中取出 money。 Document money = (Document) source.get(&quot;money&quot;); // 从 money 中解析出金额。 double amount = Double.parseDouble(money.getString(&quot;amount&quot;)); String currency = ((Document) money.get(&quot;currency&quot;)).getString(&quot;code&quot;); return Money.of(CurrencyUnit.of(currency), amount); &#125;&#125; 调用代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778package com.example.mongo;import com.example.mongo.converter.MoneyReadConverter;import com.example.mongo.model.Coffee;import com.mongodb.client.result.UpdateResult;import com.mongodb.internal.bulk.UpdateRequest;import lombok.extern.slf4j.Slf4j;import org.joda.money.CurrencyUnit;import org.joda.money.Money;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.ApplicationArguments;import org.springframework.boot.ApplicationRunner;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.context.annotation.Bean;import org.springframework.data.mongodb.ClientSessionException;import org.springframework.data.mongodb.core.MongoTemplate;import org.springframework.data.mongodb.core.convert.MongoCustomConversions;import org.springframework.data.mongodb.core.query.Criteria;import org.springframework.data.mongodb.core.query.Query;import org.springframework.data.mongodb.core.query.Update;import java.util.Arrays;import java.util.Date;import java.util.List;import static org.springframework.data.mongodb.core.query.Criteria.where;import static org.springframework.data.mongodb.core.query.Query.query;@SpringBootApplication@Slf4jpublic class MongoApplication implements ApplicationRunner &#123; @Autowired MongoTemplate mongoTemplate; public static void main(String[] args) &#123; SpringApplication.run(MongoApplication.class, args); &#125; // 查看 spring-boot-autoconfigure -&gt; data -&gt; mongo -&gt; MongoDataAutoConfiguration.class // 可以看出构造一个 MongoCustomConversions 类型的 bean ，可以替代 MongoDataAutoConfiguration 中的一部分配置。 @Bean public MongoCustomConversions mongoCustomConversions()&#123; return new MongoCustomConversions(Arrays.asList(new MoneyReadConverter())); &#125; @Override public void run(ApplicationArguments args) throws Exception &#123; //插入 Coffee espresso = Coffee.builder() .name(&quot;espresso&quot;) .price(Money.of(CurrencyUnit.of(&quot;CNY&quot;), 20.0)) .createTime(new Date()) .updateTime(new Date()).build(); Coffee saved = mongoTemplate.save(espresso); log.info(&quot;Coffee &#123;&#125;&quot;, saved); // 查询 List&lt;Coffee&gt; list = mongoTemplate.find(query(where(&quot;name&quot;).is(&quot;espresso&quot;)), Coffee.class); log.info(&quot;Find &#123;&#125; Coffee&quot;, list.size()); list.forEach(c -&gt; log.info(&quot;Coffee &#123;&#125;&quot;, c)); // 更新 Thread.sleep(1000); // 为了看更新时间 1s UpdateResult result = mongoTemplate.updateFirst(query(where(&quot;name&quot;).is(&quot;espresso&quot;)), new Update().set(&quot;price&quot;, Money.ofMajor(CurrencyUnit.of(&quot;CNY&quot;), 30)) .currentDate(&quot;updateTime&quot;), Coffee.class); log.info(&quot;Update Result: &#123;&#125;&quot;, result.getModifiedCount()); Coffee updateOne = mongoTemplate.findById(saved.getId(), Coffee.class); log.info(&quot;Update Result: &#123;&#125;&quot;, updateOne); // 删除 mongoTemplate.remove(updateOne); &#125;&#125; 3.3 基于 Spring Data MongoDB 的 Repository 的方法代码仓库在基于 MongoTemplate 的方法基础上实现 MongoRepository 接口 12345678910package com.example.mongo.repository;import com.example.mongo.model.Coffee;import org.springframework.data.mongodb.repository.MongoRepository;import java.util.List;public interface CoffeeRepository extends MongoRepository&lt;Coffee, String&gt; &#123; List&lt;Coffee&gt; findByName(String name);&#125; 添加@EnableMongoRepositories注解，修改调用代码如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677package com.example.mongo;import com.example.mongo.converter.MoneyReadConverter;import com.example.mongo.model.Coffee;import com.example.mongo.repository.CoffeeRepository;import com.mongodb.client.result.UpdateResult;import com.mongodb.internal.bulk.UpdateRequest;import lombok.extern.slf4j.Slf4j;import org.joda.money.CurrencyUnit;import org.joda.money.Money;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.ApplicationArguments;import org.springframework.boot.ApplicationRunner;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.context.annotation.Bean;import org.springframework.data.domain.Sort;import org.springframework.data.mongodb.ClientSessionException;import org.springframework.data.mongodb.core.MongoTemplate;import org.springframework.data.mongodb.core.convert.MongoCustomConversions;import org.springframework.data.mongodb.core.query.Criteria;import org.springframework.data.mongodb.core.query.Query;import org.springframework.data.mongodb.core.query.Update;import org.springframework.data.mongodb.repository.config.EnableMongoRepositories;import java.util.Arrays;import java.util.Date;import java.util.List;import static org.springframework.data.mongodb.core.query.Criteria.where;import static org.springframework.data.mongodb.core.query.Query.query;@SpringBootApplication@Slf4j@EnableMongoRepositoriespublic class MongoApplication implements ApplicationRunner &#123; @Autowired CoffeeRepository coffeeRepository; public static void main(String[] args) &#123; SpringApplication.run(MongoApplication.class, args); &#125; // 查看 spring-boot-autoconfigure -&gt; data -&gt; mongo -&gt; MongoDataAutoConfiguration.class // 可以看出构造一个 MongoCustomConversions 类型的 bean ，可以替代 MongoDataAutoConfiguration 中的一部分配置。 @Bean public MongoCustomConversions mongoCustomConversions()&#123; return new MongoCustomConversions(Arrays.asList(new MoneyReadConverter())); &#125; @Override public void run(ApplicationArguments args) throws Exception &#123; //插入 Coffee espresso = Coffee.builder() .name(&quot;espresso&quot;) .price(Money.of(CurrencyUnit.of(&quot;CNY&quot;), 20.0)) .createTime(new Date()) .updateTime(new Date()).build(); Coffee latte = Coffee.builder() .name(&quot;latte&quot;) .price(Money.of(CurrencyUnit.of(&quot;CNY&quot;), 30.0)) .createTime(new Date()) .updateTime(new Date()).build(); coffeeRepository.insert(Arrays.asList(espresso, latte)); coffeeRepository.findAll(Sort.by(&quot;name&quot;)).forEach(c -&gt; log.info(&quot;Saved Coffee &#123;&#125;&quot;, c)); Thread.sleep(1000); latte.setPrice(Money.of(CurrencyUnit.of(&quot;CNY&quot;), 35.0)); latte.setUpdateTime(new Date()); coffeeRepository.save(latte); coffeeRepository.findByName(&quot;latte&quot;).forEach(c -&gt; log.info(&quot;Coffee &#123;&#125;&quot;, c)); coffeeRepository.deleteAll(); &#125;&#125; 1","categories":[{"name":"Spring","slug":"Spring","permalink":"http://example.com/categories/Spring/"}],"tags":[]},{"title":"","date":"2022-04-16T15:36:00.379Z","path":"2022/04/16/秒杀项目总结/","text":"configuration该配置文件说明如何在本地搭建起环境，包括启动 mysql、启动虚拟机、启动 redis。 一、Mysql启动 打开navicat 连接 127.0.0.1 即可。 可以使用 http://www.localhost:8080/demo/db/get 测试 二、Redis 启动redis 是使用 multipass 安装的虚拟机需要先启动虚拟机，然后在虚拟机中启动redis。 1、启动 multipass12multipass info -allmultipass shell XXX(host) 参考链接：http://www.manongjc.com/detail/21-gtzvxvzjtoaxswf.html 2、启动 redis1234cd /usr/local/redisredis-server redis.confredis-cliauth 123456 可以使用 http://www.localhost:8080/demo/redis/get 测试 三、压测1. 图形化压测2. 命令行压测首先，需要将jar包启动（参考Spring Boot打jar包）。然后，使用jmeter压测。 1jmeter.sh -n -t /Users/jq/Desktop/goods_list.jmx -l result.jtl 如果OOM，可以使用下面命令设置更大的JVM堆栈内存。 1JVM_ARGS=&quot;-Xms512m -Xmx5g&quot; jmeter.sh -n -t /Users/jq/Desktop/goods_list.jmx -l result.jtl 四、Spring Boot打war包。1. 添加依赖12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; 2. 添加12345678910111213141516171819&lt;build&gt; &lt;finalName&gt;$&#123;project.artifactId&#125;&lt;/finalName&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;failOnMissingWebXml&gt;false&lt;/failOnMissingWebXml&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.1&lt;/version&gt; &lt;configuration&gt; &lt;fork&gt;true&lt;/fork &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 3. 修改1234&lt;groupId&gt;org.imooc&lt;/groupId&gt;&lt;artifactId&gt;miaosha&lt;/artifactId&gt;&lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&lt;packaging&gt;war&lt;/packaging&gt; 同时，把packaging中的jar修改为war。 4. 修改MainApplication类123456789101112@SpringBootApplicationpublic class MainApplication extends SpringBootServletInitializer &#123; public static void main(String[] args) &#123; SpringApplication.run(MainApplication.class, args); &#125; @Override protected SpringApplicationBuilder configure(SpringApplicationBuilder builder)&#123; return builder.sources(MainApplication.class); &#125;&#125; 5. brew 安装 tomcat@9（和java8匹配) \\Brew会默认安装在/opt/homebrew/Cellar/目录下。 6. 配置tomcat快速启动12alias tomcatstart=/opt/homebrew/Cellar/tomcat@9/9.0.60/libexec/bin/startup.shalias tomcatstop=/opt/homebrew/Cellar/tomcat@9/9.0.60/libexec/bin/shutdown.sh 7. 打成 war 包1mvn clean package 在miaosha/target目录下生成miasma.war包。将miasma.war拷贝到 /opt/homebrew/Cellar/tomcat@9/9.0.60/libexec/webapps 目录下。 8. tomcatstart 启动tomcat。 \\输入http://www.localhost:8080测试tomcat是否搭建成功。输入 http://www.localhost:8080/miaosha/login/to_login， 查看登录界面，但目前不能登录，需要在/opt/homebrew/Cellar/tomcat@9/9.0.60/libexec/webapps/Root 目录下添加一些资源。 五、Spring Boot打jar包1、添加依赖12345678910111213141516&lt;build&gt; &lt;finalName&gt;$&#123;project.artifactId&#125;&lt;/finalName&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.1&lt;/version&gt; &lt;configuration&gt; &lt;fork&gt;true&lt;/fork&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 2、修改1234&lt;groupId&gt;org.imooc&lt;/groupId&gt;&lt;artifactId&gt;miaosha&lt;/artifactId&gt;&lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&lt;packaging&gt;jar&lt;/packaging&gt; 3、打成 jar 包1mvn clean package 在miaosha/target目录下生成miasma.jar包 4、运行jar，并输出到nohup文件。1nohup java -jar miaosha.jar &amp; 5、测试输入 http://www.localhost:8080/miaosha/login/to_login， 查看登录界面，并且进行压测。 输入 tail -f nohup.out 可以查看日志的末尾输出。 五、压测 redis12345678redis-benchmark -a 123456 -h 127.0.0.1 -p 6379 -c 100 -n 100000redis-benchmark -a 123456 -h 127.0.0.1 -p 6379 -q -d 100redis-benchmark -a 123456 -t set,lpush -n 100000 -q# 只测试单条命令redis-benchmark -a 123456 -n 100000 -q script load &quot;redis.call(&#x27;set&#x27;,&#x27;foo&#x27;,&#x27;bar&#x27;)&quot; 六、页面优化技术 页面缓存 + URL缓存 + 对象缓存 页面静态化（不需要重复下载页面，只需要下载动态的），前后端分离 静态资源优化 CDN优化 1、页面缓存将 goods_list 页面的信息写入 redis，设置了60s的缓存时间。可以下命令测试： 12keys GoodsKey:glget GoodsKey:gl 2、URL 缓存和页面缓存大致一样，给 goods_detail 页面添加缓存，不同于 goods_list 页面的是 goods_detail 页面需要加用户的标号：”1”（http://www.localhost:8080/goods/to_detail/1）。 3、对象缓存此处的对象指的是用户对象，通过用户id将用户的信息写入缓存。 MiaoshaUserService 类中的 updatePassword 方法，如何更新数据库密码。 4、页面静态化将数据存在浏览器中，主要技术有：AngularJS、Vue.js等此处使用简单的。 服务端不直接返回html，只返回页面上动态的数据。在前端html页面中接受这些动态的数值即可。 思考：如何验证客户端加载了浏览器的本地缓存而不是服务端的数据？\\304状态码表示服务端数据未改变，可直接使用客户端未过期的缓存。304状态码返回时不包含任何响应的主体部分。请求首部包含If-Modified-Since: Mon, 11 Apr 2022 10:07:49 GMT，服务端会和资源的最近更新时间比较，确定是不是需要返回资源。不需要则返回304状态码，具体如下： 123HTTP/1.1 304Last-Modified: Mon, 11 Apr 2022 10:07:49 GMTDate: Mon, 11 Apr 2022 10:10:19 GMT 进一步优化上面虽然没有直接下载服务端的数据，但还是请求了一次服务端。通过在静态资源中添加设置静态资源的有效时间，不访问服务器，直接使用客户端的缓存。\\ 验证查看网页请求，发现响应如下： 1234567HTTP/1.1 200Last-Modified: Mon, 11 Apr 2022 10:07:49 GMTContent-Length: 4818Accept-Ranges: bytesContent-Type: text/htmlCache-Control: max-age=3600Date: Mon, 11 Apr 2022 10:43:17 GMT Cache-Control: max-age=3600字段表示该资源可以在3600ms内复用。 问题1：库存会被减成负值原因：两个人同时减库存时，调用的sql语句如下：1@Update(&quot;update miaosha_goods set stock_count = stock_count - 1 where goods_id = #&#123;goodsId&#125;”) 当只有一个库存时会降为-1，此时可以在sql中加库存大于0的判断如下： 1@Update(&quot;update miaosha_goods set stock_count = stock_count - 1 where goods_id = #&#123;goodsId&#125; and stock_count &gt; 0”)`） 问题2：一个用户购买了两个同一个商品。原因：库存为10，同一个用户同时发出两个请求，同时进入了判断库存等方法，导致一个用户买到两个商品。解决思路：购买流程是：减库存 -&gt; 下订单，下订单的时候有个订单表，有用户id和商品id，此处在订单表中给这两个字段建立联合唯一索引。这样创建订单时，如此该用户存在一个订单，再下另一个订单时就会出现重复。注意：在创建订单的函数前加@Transactional。如果只给用户id建立唯一索引可以不？不行，允许用户秒杀其他商品。 5、静态资源优化 JS/CSS 压缩，减少流浪； 多个 JS/CSS 组合 Tengine 在nginx基础上开发的CDN:内容分发网络。 七、秒杀接口优化方案： 把秒杀商品信息加载到redis，减少mysql的访问。 内存标记，减少一次redis查商品库存的访问：使用map（goodsId -&gt; boolean）， false表示还有库存，true表示没有库存，则秒杀结束。接下来的关于goodsId的请求不在访问redis，直接返回。 通过在redis中预减库存，当库存不足，直接返回，不需要进一步查询Redis中的订单信息，以判断是否秒杀成功。减少了redis的访问。 使用rabbitmq实现异步下单，达到削峰的作用。秒杀流程： 系统初始化，把商品库存数量加载到redis。 收到请求，内存标记，减少redis访问： redis预减库存，如果库存不足，设置该goodsId的map值为true，然后直接返回。 请求入队，立即返回排队中。 请求出队，生成订单，减少库存。 客户端轮询，是否秒杀成功。 环境安装安装 RabbitMQ。 12sudo apt-get install erlangerl 以上命令能正常输出说明erlang安装成功。接下来安装、启动并验证rabbitmq是否在监听5672端口。 123sudo apt-get install rabbitmq-serversudo rabbitmq-servernetstat -nap | grep 5672 关闭rabbitmq。 1sudo rabbitmqctl stop 设置一个 rabbitmq 的用户名和密码，默认存在一个用户 guest，密码为 guest。123rabbitmqctl add_user YOUR_USERNAME YOUR_PASSWORDrabbitmqctl set_user_tags YOUR_USERNAME administratorrabbitmqctl set_permissions -p / YOUR_USERNAME &quot;.*&quot; &quot;.*&quot; &quot;.*&quot; 扩展 Nginx水平扩展。 分库分表 八、安全优化 秒杀接口地址隐藏 数学公式验证码（可以削峰） 接口限流放刷 1、秒杀接口地址隐藏思路：秒杀开始之前，先去请求接口获取秒杀地址。 接口改造，带上PathVariable参数。 添加生成地址的接口。 秒杀收到请求，先验证PathVariable 流程秒杀开始，用户点击秒杀按钮时，在后端使用uuid+DM5生成一个str，并且以用户id_商品id为键，str为值存入redis。前端通过接口请求到这个str，拼接到路径中请求后端。后端取出这个str后和自己生成的oldStr对比（redis中的str），如果一致，则进入秒杀流程。 问题：有人先请求前端的接口得到str，然后去访问秒杀接口，可行吗？？？ 2、数学公式验证码 添加生成验证码的接口。 在获取秒杀路径的时候，验证验证码。 ScriptEngine使用。 流程秒杀开始时，前端请求后端生成验证码，然后将生成的验证码信息以vc_用户id_秒杀商品id -&gt; 验证码结果的形式存储在redis中，同时将验证码发给前端。前端展示给用户，用户输入结果，点击秒杀按钮。前端发送请求给后端（同时包含秒杀地址参数），后端先从redis中取出验证码结果验证是否正确。正确则开始在redis中生成path，并进行下一步操作。 总结秒杀系统设计 负责项目的设计和开发 2022.4 - 2022.5 • 项目介绍：为了解决秒杀商品时存在高并发的问题，本项目基于SpringBoot开发秒杀系统。本人主要负责登录模块、商品列表模块、商品详情模板、订单详情模块、秒杀接口优化部分、安全模块。 • 个人收获：对于基于SpringBoot项目的开发有了更加完整和深刻的认识。 • 相关技术：SpringBoot、MySql、mybatis、Redis、RabbitMQ、Thymeleaf、jmeter","categories":[],"tags":[]},{"title":"初识ThreadLocal","date":"2022-04-16T04:22:26.000Z","path":"2022/04/16/初识ThreadLocal/","text":"1、ThreadLocal 使用实例来源：廖雪峰Java教程 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.TimeUnit;public class Main &#123; public static void main(String[] args) throws Exception &#123; ExecutorService es = Executors.newFixedThreadPool(3); String[] users = new String[] &#123; &quot;Bob&quot;, &quot;Alice&quot;, &quot;Tim&quot;, &quot;Mike&quot;, &quot;Lily&quot;, &quot;Jack&quot;, &quot;Bush&quot; &#125;; for (String user : users) &#123; es.submit(new Task(user)); &#125; es.awaitTermination(3, TimeUnit.SECONDS); es.shutdown(); &#125;&#125;class UserContext implements AutoCloseable &#123; // private static final ThreadLocal&lt;String&gt; userThreadLocal = new ThreadLocal&lt;&gt;(); public UserContext(String name) &#123; userThreadLocal.set(name); System.out.printf(&quot;[%s] init user %s...\\n&quot;, Thread.currentThread().getName(), UserContext.getCurrentUser()); &#125; public static String getCurrentUser() &#123; return userThreadLocal.get(); &#125; @Override public void close() &#123; System.out.printf(&quot;[%s] cleanup for user %s...\\n&quot;, Thread.currentThread().getName(), UserContext.getCurrentUser()); userThreadLocal.remove(); &#125;&#125;class Task implements Runnable &#123; final String username; public Task(String username) &#123; this.username = username; &#125; @Override public void run() &#123; try (UserContext ctx = new UserContext(this.username)) &#123; new Task1().process(); new Task2().process(); new Task3().process(); &#125; &#125;&#125;class Task1 &#123; public void process() &#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; &#125; System.out.printf(&quot;[%s] check user %s...\\n&quot;, Thread.currentThread().getName(), UserContext.getCurrentUser()); &#125;&#125;class Task2 &#123; public void process() &#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; &#125; System.out.printf(&quot;[%s] %s registered ok.\\n&quot;, Thread.currentThread().getName(), UserContext.getCurrentUser()); &#125;&#125;class Task3 &#123; public void process() &#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException ignored) &#123; &#125; System.out.printf(&quot;[%s] work of %s has done.\\n&quot;, Thread.currentThread().getName(), UserContext.getCurrentUser()); &#125;&#125; 2、ThreadLocal 结构ThreadLocal类里边定义了一个ThreadLocalMap静态内部类，ThreadLocalMap里边又有一个static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt;{}。除此之外，ThreadLocalMap中定义了private Entry[] table。因此，ThreadLocal的结构如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class ThreadLocal&lt;T&gt; &#123; static ThreadLocalMap createInheritedMap(ThreadLocalMap parentMap) &#123; return new ThreadLocalMap(parentMap); &#125; static class ThreadLocalMap &#123; static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123; /** The value associated with this ThreadLocal. */ Object value; Entry(ThreadLocal&lt;?&gt; k, Object v) &#123; super(k); value = v; &#125; &#125; /** * The initial capacity -- MUST be a power of two. */ private static final int INITIAL_CAPACITY = 16; /** * The table, resized as necessary. * table.length MUST always be a power of two. */ private Entry[] table; /** * The number of entries in the table. */ private int size = 0; /** * The next size value at which to resize. */ private int threshold; // Default to 0 ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123; table = new Entry[INITIAL_CAPACITY]; int i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - 1); table[i] = new Entry(firstKey, firstValue); size = 1; setThreshold(INITIAL_CAPACITY); &#125; // ... &#125; // ...&#125; 内存泄露问题ThreadLocalMap中的key是一个弱引用，垃圾回收时就会被回收。如果ThreadLocalMap对应的线程依旧存活，那么value就依旧具有强引用而不会被回收，从而导致内存泄漏。解决内存泄漏的方法：直接调用remove()方法 (try{}finally{})，将value也置为 NULL。 3、结合Thread理解ThreadLoalThread类中包含一个ThreadLocal.ThreadLocalMap类型的成员变量threadLocals，因此每一个Thread都有一个ThreadLocalMap。 12345public class Thread implements Runnable &#123; /* ThreadLocal values pertaining to this thread. This map is maintained * by the ThreadLocal class. */ ThreadLocal.ThreadLocalMap threadLocals = null;&#125; ThreadLoalset或get时，会先获取当前的thread，其实操作的就是thread的threadLocals,代码如下： 1234567891011121314151617181920212223242526272829public class ThreadLocal&lt;T&gt; &#123; public T get() &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) &#123; ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) &#123; @SuppressWarnings(&quot;unchecked&quot;) T result = (T)e.value; return result; &#125; &#125; return setInitialValue(); &#125; public void set(T value) &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value); &#125; ThreadLocalMap getMap(Thread t) &#123; return t.threadLocals; &#125;&#125; 在set方法中，最终是map.set(this, value)，这儿的this是Thread的一个实例,因此map结构是 (线程 –&gt; Object)。 思考：Entry类数组的作用？3、ThreadLocal 使用场景 ThreadLocal 相当于是线程的本地缓存，因此对可以存储一些属于该线程的数据，防止竞争。 对于当前线程多次使用的的数据可以使用 ThreadLocal 存储，通过 get 方法就可以获得。比如，当前用户的 session 会在程序中多次使用，定义一个 ThreadLocal 存储，每次使用时 get 即可。 参考：1、Guide ThreadLocal 关键字解析","categories":[{"name":"java","slug":"java","permalink":"http://example.com/categories/java/"}],"tags":[]},{"title":"SpringMVC自定义参数解析器","date":"2022-04-15T08:05:04.000Z","path":"2022/04/15/SpringMVC自定义参数解析器/","text":"1、实现参数解析器的接口HandlerMethodArgumentResolverHandlerMethodArgumentResolver接口包含两个方法supportsParameter和resolveArgument。 supportsParameter方法返回 boolean 值，表示是否启用该解析器，true 表示启用，false 表示不启用； resolveArgument 方法表示方法参数的解析过程，就是你把 HTTP 的请求参数转换为方法参数的过程，返回 Object 对象，即参数的转换结果。 源代码如下： 12345public interface HandlerMethodArgumentResolver &#123; boolean supportsParameter(MethodParameter var1); Object resolveArgument(MethodParameter var1, ModelAndViewContainer var2, NativeWebRequest var3, WebDataBinderFactory var4) throws Exception;&#125; 2、自定义一个参数解析器 定义一个方法注解 实现HandlerMethodArgumentResolver接口。 注册参数解析器 使用参数解析器 2.1 定义一个方法注解12345@Retention(RUNTIME)@Target(METHOD)public @interface ParamModel &#123; // 可以定义需要带的参数&#125; 2.2 实现HandlerMethodArgumentResolver接口。在HandlerMethodArgumentResolver接口中实现具体的参数解析。 1234567891011121314151617181920@Servicepublic class UserArgumentResolvers implements HandlerMethodArgumentResolver &#123; @Override public boolean supportsParameter(MethodParameter parameter) &#123; //带有注解就解析，即调用下面的 resolveArgument 方法。 return methodParameter.hasParameterAnnotation(ParamModel.class); &#125; @Override public Object resolveArgument(MethodParameter methodParameter, ModelAndViewContainer modelAndViewContainer, NativeWebRequest webRequest, WebDataBinderFactory webDataBinderFactory) throws Exception &#123; HttpServletRequest request = webRequest.getNativeRequest(HttpServletRequest.class); HttpServletResponse response = webRequest.getNativeResponse(HttpServletResponse.class); // 从request和request中解析出对应的Object。 return null; &#125; 2.3 注册参数解析器1234567891011@Configurationpublic class WebConfig extends WebMvcConfigurerAdapter &#123; @Autowired UserArgumentResolvers userArgumentResolver; @Override public void addArgumentResolvers(List&lt;HandlerMethodArgumentResolver&gt; argumentResolvers) &#123; argumentResolvers.add(userArgumentResolver); &#125;&#125; 2.4 使用参数解析器1234public void getMiaoshaPath(@ParamModel int verifyCode) &#123; // 参数解析的结果会赋值给verifyCode。 // ...&#125;","categories":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://example.com/categories/SpringMVC/"}],"tags":[{"name":"java、SpringMVC、参数解析器","slug":"java、SpringMVC、参数解析器","permalink":"http://example.com/tags/java%E3%80%81SpringMVC%E3%80%81%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%E5%99%A8/"}]},{"title":"SpringMVC实现拦截器","date":"2022-04-15T08:01:11.000Z","path":"2022/04/15/SpringMVC实现拦截器/","text":"1、功能需求在秒杀商品时，需要使用秒杀接口防刷保护程序，可以定义一个拦截器实现。具体使用如下所示： 1@AccessLimit(seconds = 1, maxCount = 100, needLogin = true) 这个拦截器需要当前用户登录，且1s内限制最大请求次数为100。 2、拦截器的主要类HandlerInterceptorAdapterHandlerInterceptorAdapter提供的方法如下： preHandle:方法执行前调用拦截器，返回true，则接续执行，否则不会执行方法。 postHandle:在方法执行后调用。 afterCompletion源代码如下：123456789public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; return true;&#125;public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123;&#125;public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;&#125; 3、实现拦截器 自定义 @AccessLimit 参数解析器。 重写HandlerInterceptorAdapter类的preHandle方法 注册拦截器 使用拦截器 3.1 自定义 @AccessLimit 注解。12345678910/** 定义一个注解*/@Retention(RUNTIME)@Target(METHOD)public @interface AccessLimit &#123; int seconds(); int maxCount(); boolean needLogin() default true;&#125; 3.2 重写preHandle方法123456789101112131415161718192021222324252627282930/** 满足拦截条件 return false;* 不满足拦截条件 return true;*/@Servicepublic class AccessInterceptor extends HandlerInterceptorAdapter &#123; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; if (handler instanceof HandlerMethod)&#123; MiaoshaUser user = getUser(request, response); // 存储user UserContext.setUser(user); // 当前线程就可以取用。 HandlerMethod hm = (HandlerMethod) handler; AccessLimit accessLimit = hm.getMethodAnnotation(AccessLimit.class); // 获取注解 if (accessLimit == null) &#123; // 如果没有限制 return true; &#125; int seconds = accessLimit.seconds(); int maxCount = accessLimit.maxCount(); boolean needLogin = accessLimit.needLogin(); // 具体的拦截逻辑 &#125; return true; &#125;&#125; 3.3 注册拦截器12345678910111213141516@Configurationpublic class WebConfig extends WebMvcConfigurerAdapter &#123; @Autowired AccessInterceptor accessInterceptor; @Override public void addArgumentResolvers(List&lt;HandlerMethodArgumentResolver&gt; argumentResolvers) &#123; argumentResolvers.add(userArgumentResolver); &#125; // 注册拦截器 @Override public void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(new); &#125;&#125; 3.4 使用拦截器1234@AccessLimit(seconds = 1, maxCount = 100, needLogin = true)public void test()&#123; // ...&#125;","categories":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://example.com/categories/SpringMVC/"}],"tags":[{"name":"java，SpringMVC，拦截器","slug":"java，SpringMVC，拦截器","permalink":"http://example.com/tags/java%EF%BC%8CSpringMVC%EF%BC%8C%E6%8B%A6%E6%88%AA%E5%99%A8/"}]},{"title":"java杂项","date":"2022-04-15T07:02:11.000Z","path":"2022/04/15/java杂项/","text":"ThreadLcoal 的用法在秒杀功能中，定义一个static的ThreadLcoal存储MiaoshaUser。当用户点击秒杀按钮时将其存储在ThreadLocal中，该线程以后使用时就可以直接get。 1private static ThreadLocal&lt;MiaoshaUser&gt; userHolder = new ThreadLocal&lt;&gt;(); 如果不这样做，需要每次从请求中解析MiaoshaUser对象,代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142@Servicepublic class UserArgumentResolvers implements HandlerMethodArgumentResolver &#123; @Autowired MiaoshaUserService userService; @Override public boolean supportsParameter(MethodParameter parameter) &#123; // 当为 MiaoshaUser 类型时就执行参数解析，即调用下面的 resolveArgument 方法。 Class&lt;?&gt; clazz = parameter.getParameterType(); return clazz == MiaoshaUser.class; &#125; @Override public Object resolveArgument(MethodParameter methodParameter, ModelAndViewContainer modelAndViewContainer, NativeWebRequest webRequest, WebDataBinderFactory webDataBinderFactory) throws Exception &#123; HttpServletRequest request = webRequest.getNativeRequest(HttpServletRequest.class); HttpServletResponse response = webRequest.getNativeResponse(HttpServletResponse.class); String paramToken = request.getParameter(MiaoshaUserService.COOKI_NAME_TOKEN); String cookieToken = getCookieValue(request, MiaoshaUserService.COOKI_NAME_TOKEN); if (StringUtils.isEmpty(cookieToken) &amp;&amp; StringUtils.isEmpty(paramToken))&#123; return null; &#125; String token = StringUtils.isEmpty(paramToken) ? cookieToken : paramToken; return userService.getByToken(response,token); &#125; private String getCookieValue(HttpServletRequest request, String cookieName) &#123; Cookie[] cookies = request.getCookies(); if (cookies == null || cookies.length &lt;= 0)&#123; return null; &#125; for (Cookie cookie : cookies) &#123; if (cookie.getName().equals(cookieName))&#123; return cookie.getValue(); &#125; &#125; return null; &#125;&#125;","categories":[{"name":"java","slug":"java","permalink":"http://example.com/categories/java/"}],"tags":[{"name":"杂项","slug":"杂项","permalink":"http://example.com/tags/%E6%9D%82%E9%A1%B9/"}]},{"title":"杂项","date":"2022-04-08T03:37:43.000Z","path":"2022/04/08/杂项/","text":"配置环境变量exportexport 表示将该路径添加到环境变量中，打开 vim .zshrc ，添加jmeter的快速启动路径 export JMETER_HOME=/usr/local/apache-jmeter-5.4.3export PATH=$JAVA_HOME/bin:$PATH:.:$JMETER_HOME/bin:$PATHexport CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JMETER_HOME/lib/ext/ApacheJMeter_core.jar:$JMETER_HOME/lib/jorphan.jar:$JMETER_HOME/lib/logkit-2.0.jar source .zshrc 使.zshrc生效。使用 export -p 可以查看当前的环境中的路径。 aliasalias 为指定路径起别名。 export PATH=/usr/local/mysql/bin:$PATH#快速启动、结束MySQL服务, 可以使用alias命令alias mysqlstart=’sudo /usr/local/mysql/support-files/mysql.server start’alias mysqlstop=’sudo /usr/local/mysql/support-files/mysql.server stop’ macOS目录的作用系统硬件相关/cores 内核转储文件存放目录。当一个进程崩溃时，如果系统允许则会产生转储文件。/dev 设备文件存放目录，如何代表硬盘的/dev/disk0。/Network 网络节点存放目录；/Volumes 文件系统挂载点存放目录。 系统配置相关/etc. 标准unix系统配置文件存放目录，如用户密码文件/etc/passwd。此目录实际为指向/private/etc的链接。 系统程序相关/Applications 应用程序目录，默认所有的GUI应用程序都安装在这里；/Library 系统的数据文件、帮助文件、文档等等；/System 只包含一个名为Library的目录，这个子目录中存放了系统的绝大部分组件，如各种framework，以及内核模块，字体文件等等。 系统命令相关/bin 传统unix命令的存放目录，如ls，rm，mv等。/sbin 传统unix管理类命令存放目录，如fdisk，ifconfig等等。 用户信息相关/Users 存放用户的个人资料和配置。每个用户有自己的单独目录。 用户经常使用/usr 第三方程序安装目录。/usr/bin, /usr/sbin, /usr/lib，其中/usr/lib目录中存放了共享库（动态链接库）。/var 存放经常变化的文件，如日志文件。此目录实际为指向/private/var的链接。 /opt/homebrew brew安装的程序一般放这儿。 /private 里面的子目录存放了/tmp, /var, /etc等链接目录的目标目录。/tmp 临时文件存放目录，其权限为所有人任意读写。此目录实际为指向/private/tmp的链接。 其他/installer.failurerequests 可能是用来记录发生crash时的日志。 linux 命令拾遗lsof（list open files）lsof 列出当前系统打开文件的工具。lsof -i :8080 可以查看当前占用8080端口的进程。 ls（list）ls默认情况下用来打印出当前目录的列表。 git流程将写了一半的项目git到空github上。 github上创建同名仓库 git clone到本地 将隐藏的.git文件复制到已经写了一半的project中 git add . git status git commit -m “提交说明” git push","categories":[],"tags":[{"name":"杂项","slug":"杂项","permalink":"http://example.com/tags/%E6%9D%82%E9%A1%B9/"}]},{"title":"hexo github配置博客","date":"2022-04-06T03:44:59.000Z","path":"2022/04/06/hexo github配置博客/","text":"1、 配置环境流程1.1 安装node.js官网下载node.jsnode -vnmp -v 1.2 创建blog目录mkdir /Users/jq/blog 1.3 安装hexonmp install hexo -g hexo-clihexo -v 1.4 VPN设置如果设置了VPN，需要设置环境变量；vim ./~zshrc 123export https_proxy=http://127.0.0.1:7890 http_proxy=http://127.0.0.1:7890 all_proxy=socks5://127.0.0.1:7890source ./~zshrc 1.5 初始化hexosudo susudo hexo init 2、写一个博客流程2.1 开始hexohexo s 2.2 创建一个新博客hexo n “XXXX” 使用vsconde等编写内容。 2.3 清理hexo clean 2.4 生成博客hexo g 2.5 浏览刚才写的博客hexo s 3、配置github3.1 在最后添加1234deploy: type: git repository: git@github.com:jiaoqiang2014/jiaoqiang2014.github.io.git branch: master 4、换主题4.1 下载主题12git clone git@github.com:litten/hexo-theme-yilia.git themes/yiliagit@github.com:yscoder/hexo-theme-indigo.git 4.2 修改_config.yml配置1theme: yilia Hexo clean Hexo g Hero s 5、代码折叠功能6、hexo引用本地图片无法显示问题使用格式为：![图片描述](md文件夹名字/example.jpg) 参考博客：1、 hexo增加分类、标签2、 hexo主题美化3 https://github.com/Neveryu/Neveryu.github.io/blob/","categories":[{"name":"hexo","slug":"hexo","permalink":"http://example.com/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://example.com/tags/hexo/"}]}]