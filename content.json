[{"title":"SpringMVC自定义参数解析器","date":"2022-04-15T08:05:04.000Z","path":"2022/04/15/SpringMVC自定义参数解析器/","text":"1、实现参数解析器的接口HandlerMethodArgumentResolverHandlerMethodArgumentResolver接口包含两个方法supportsParameter和resolveArgument。 supportsParameter方法返回 boolean 值，表示是否启用该解析器，true 表示启用，false 表示不启用； resolveArgument 方法表示方法参数的解析过程，就是你把 HTTP 的请求参数转换为方法参数的过程，返回 Object 对象，即参数的转换结果。 源代码如下： 12345public interface HandlerMethodArgumentResolver &#123; boolean supportsParameter(MethodParameter var1); Object resolveArgument(MethodParameter var1, ModelAndViewContainer var2, NativeWebRequest var3, WebDataBinderFactory var4) throws Exception;&#125; 2、自定义一个参数解析器 定义一个方法注解 实现HandlerMethodArgumentResolver接口。 注册参数解析器 使用参数解析器 2.1 定义一个方法注解12345@Retention(RUNTIME)@Target(METHOD)public @interface ParamModel &#123; // 可以定义需要带的参数&#125; 2.2 实现HandlerMethodArgumentResolver接口。在HandlerMethodArgumentResolver接口中实现具体的参数解析。 1234567891011121314151617181920@Servicepublic class UserArgumentResolvers implements HandlerMethodArgumentResolver &#123; @Override public boolean supportsParameter(MethodParameter parameter) &#123; //带有注解就解析，即调用下面的 resolveArgument 方法。 return methodParameter.hasParameterAnnotation(ParamModel.class); &#125; @Override public Object resolveArgument(MethodParameter methodParameter, ModelAndViewContainer modelAndViewContainer, NativeWebRequest webRequest, WebDataBinderFactory webDataBinderFactory) throws Exception &#123; HttpServletRequest request = webRequest.getNativeRequest(HttpServletRequest.class); HttpServletResponse response = webRequest.getNativeResponse(HttpServletResponse.class); // 从request和request中解析出对应的Object。 return null; &#125; 2.3 注册参数解析器1234567891011@Configurationpublic class WebConfig extends WebMvcConfigurerAdapter &#123; @Autowired UserArgumentResolvers userArgumentResolver; @Override public void addArgumentResolvers(List&lt;HandlerMethodArgumentResolver&gt; argumentResolvers) &#123; argumentResolvers.add(userArgumentResolver); &#125;&#125; 2.4 使用参数解析器1234public void getMiaoshaPath(@ParamModel int verifyCode) &#123; // 参数解析的结果会赋值给verifyCode。 // ...&#125;","categories":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://example.com/categories/SpringMVC/"}],"tags":[{"name":"java、SpringMVC、参数解析器","slug":"java、SpringMVC、参数解析器","permalink":"http://example.com/tags/java%E3%80%81SpringMVC%E3%80%81%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%E5%99%A8/"}]},{"title":"SpringMVC实现拦截器","date":"2022-04-15T08:01:11.000Z","path":"2022/04/15/SpringMVC实现拦截器/","text":"1、功能需求在秒杀商品时，需要使用秒杀接口防刷保护程序，可以定义一个拦截器实现。具体使用如下所示： 1@AccessLimit(seconds = 1, maxCount = 100, needLogin = true) 这个拦截器需要当前用户登录，且1s内限制最大请求次数为100。 2、拦截器的主要类HandlerInterceptorAdapterHandlerInterceptorAdapter提供的方法如下： preHandle:方法执行前调用拦截器，返回true，则接续执行，否则不会执行方法。 postHandle:在方法执行后调用。 afterCompletion源代码如下：123456789public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; return true;&#125;public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123;&#125;public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;&#125; 3、实现拦截器 自定义 @AccessLimit 参数解析器。 重写HandlerInterceptorAdapter类的preHandle方法 注册拦截器 使用拦截器 3.1 自定义 @AccessLimit 注解。12345678910/** 定义一个注解*/@Retention(RUNTIME)@Target(METHOD)public @interface AccessLimit &#123; int seconds(); int maxCount(); boolean needLogin() default true;&#125; 3.2 重写preHandle方法123456789101112131415161718192021222324252627282930/** 满足拦截条件 return false;* 不满足拦截条件 return true;*/@Servicepublic class AccessInterceptor extends HandlerInterceptorAdapter &#123; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; if (handler instanceof HandlerMethod)&#123; MiaoshaUser user = getUser(request, response); // 存储user UserContext.setUser(user); // 当前线程就可以取用。 HandlerMethod hm = (HandlerMethod) handler; AccessLimit accessLimit = hm.getMethodAnnotation(AccessLimit.class); // 获取注解 if (accessLimit == null) &#123; // 如果没有限制 return true; &#125; int seconds = accessLimit.seconds(); int maxCount = accessLimit.maxCount(); boolean needLogin = accessLimit.needLogin(); // 具体的拦截逻辑 &#125; return true; &#125;&#125; 3.3 注册拦截器12345678910111213141516@Configurationpublic class WebConfig extends WebMvcConfigurerAdapter &#123; @Autowired AccessInterceptor accessInterceptor; @Override public void addArgumentResolvers(List&lt;HandlerMethodArgumentResolver&gt; argumentResolvers) &#123; argumentResolvers.add(userArgumentResolver); &#125; // 注册拦截器 @Override public void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(new); &#125;&#125; 3.4 使用拦截器1234@AccessLimit(seconds = 1, maxCount = 100, needLogin = true)public void test()&#123; // ...&#125;","categories":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://example.com/categories/SpringMVC/"}],"tags":[{"name":"java，SpringMVC，拦截器","slug":"java，SpringMVC，拦截器","permalink":"http://example.com/tags/java%EF%BC%8CSpringMVC%EF%BC%8C%E6%8B%A6%E6%88%AA%E5%99%A8/"}]},{"title":"java杂项","date":"2022-04-15T07:02:11.000Z","path":"2022/04/15/java杂项/","text":"ThreadLcoal 的用法在秒杀功能中，定义一个static的ThreadLcoal存储MiaoshaUser。当用户点击秒杀按钮时将其存储在ThreadLocal中，该线程以后使用时就可以直接get。 1private static ThreadLocal&lt;MiaoshaUser&gt; userHolder = new ThreadLocal&lt;&gt;(); 如果不这样做，需要每次从请求中解析MiaoshaUser对象,代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243@Servicepublic class UserArgumentResolvers implements HandlerMethodArgumentResolver &#123; @Autowired MiaoshaUserService userService; @Override public boolean supportsParameter(MethodParameter parameter) &#123; // 当为 MiaoshaUser 类型时就执行参数解析，即调用下面的 resolveArgument 方法。 Class&lt;?&gt; clazz = parameter.getParameterType(); return clazz == MiaoshaUser.class; &#125; @Override public Object resolveArgument(MethodParameter methodParameter, ModelAndViewContainer modelAndViewContainer, NativeWebRequest webRequest, WebDataBinderFactory webDataBinderFactory) throws Exception &#123; HttpServletRequest request = webRequest.getNativeRequest(HttpServletRequest.class); HttpServletResponse response = webRequest.getNativeResponse(HttpServletResponse.class); String paramToken = request.getParameter(MiaoshaUserService.COOKI_NAME_TOKEN); String cookieToken = getCookieValue(request, MiaoshaUserService.COOKI_NAME_TOKEN); if (StringUtils.isEmpty(cookieToken) &amp;&amp; StringUtils.isEmpty(paramToken))&#123; return null; &#125; String token = StringUtils.isEmpty(paramToken) ? cookieToken : paramToken; return userService.getByToken(response,token); &#125; private String getCookieValue(HttpServletRequest request, String cookieName) &#123; Cookie[] cookies = request.getCookies(); if (cookies == null || cookies.length &lt;= 0)&#123; return null; &#125; for (Cookie cookie : cookies) &#123; if (cookie.getName().equals(cookieName))&#123; return cookie.getValue(); &#125; &#125; return null; &#125;&#125;","categories":[{"name":"java","slug":"java","permalink":"http://example.com/categories/java/"}],"tags":[{"name":"杂项","slug":"杂项","permalink":"http://example.com/tags/%E6%9D%82%E9%A1%B9/"}]},{"title":"杂项","date":"2022-04-08T03:37:43.000Z","path":"2022/04/08/杂项/","text":"配置环境变量exportexport 表示将该路径添加到环境变量中，打开 vim .zshrc ，添加jmeter的快速启动路径 export JMETER_HOME=/usr/local/apache-jmeter-5.4.3export PATH=$JAVA_HOME/bin:$PATH:.:$JMETER_HOME/bin:$PATHexport CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JMETER_HOME/lib/ext/ApacheJMeter_core.jar:$JMETER_HOME/lib/jorphan.jar:$JMETER_HOME/lib/logkit-2.0.jar source .zshrc 使.zshrc生效。使用 export -p 可以查看当前的环境中的路径。 aliasalias 为指定路径起别名。 export PATH=/usr/local/mysql/bin:$PATH#快速启动、结束MySQL服务, 可以使用alias命令alias mysqlstart=’sudo /usr/local/mysql/support-files/mysql.server start’alias mysqlstop=’sudo /usr/local/mysql/support-files/mysql.server stop’ macOS目录的作用系统硬件相关/cores 内核转储文件存放目录。当一个进程崩溃时，如果系统允许则会产生转储文件。/dev 设备文件存放目录，如何代表硬盘的/dev/disk0。/Network 网络节点存放目录；/Volumes 文件系统挂载点存放目录。 系统配置相关/etc. 标准unix系统配置文件存放目录，如用户密码文件/etc/passwd。此目录实际为指向/private/etc的链接。 系统程序相关/Applications 应用程序目录，默认所有的GUI应用程序都安装在这里；/Library 系统的数据文件、帮助文件、文档等等；/System 只包含一个名为Library的目录，这个子目录中存放了系统的绝大部分组件，如各种framework，以及内核模块，字体文件等等。 系统命令相关/bin 传统unix命令的存放目录，如ls，rm，mv等。/sbin 传统unix管理类命令存放目录，如fdisk，ifconfig等等。 用户信息相关/Users 存放用户的个人资料和配置。每个用户有自己的单独目录。 用户经常使用/usr 第三方程序安装目录。/usr/bin, /usr/sbin, /usr/lib，其中/usr/lib目录中存放了共享库（动态链接库）。/var 存放经常变化的文件，如日志文件。此目录实际为指向/private/var的链接。 /opt/homebrew brew安装的程序一般放这儿。 /private 里面的子目录存放了/tmp, /var, /etc等链接目录的目标目录。/tmp 临时文件存放目录，其权限为所有人任意读写。此目录实际为指向/private/tmp的链接。 其他/installer.failurerequests 可能是用来记录发生crash时的日志。 linux 命令拾遗lsof（list open files）lsof 列出当前系统打开文件的工具。lsof -i :8080 可以查看当前占用8080端口的进程。 ls（list）ls默认情况下用来打印出当前目录的列表。 git流程将写了一半的项目git到空github上。 github上创建同名仓库 git clone到本地 将隐藏的.git文件复制到已经写了一半的project中 git add . git status git commit -m “提交说明” git push","categories":[],"tags":[{"name":"杂项","slug":"杂项","permalink":"http://example.com/tags/%E6%9D%82%E9%A1%B9/"}]},{"title":"hexo github配置博客","date":"2022-04-06T03:44:59.000Z","path":"2022/04/06/hexo github配置博客/","text":"配置环境流程安装node.js官网下载node.jsnode -vnmp -v 创建blog目录mkdir /Users/jq/blog 安装hexonmp install hexo -g hexo-clihexo -v VPN设置如果设置了VPN，需要设置环境变量；vim ./~zshrc export https_proxy=http://127.0.0.1:7890 http_proxy=http://127.0.0.1:7890 all_proxy=socks5://127.0.0.1:7890 source ./~zshrc 初始化hexosudo susudo hexo init 写一个博客流程开始hexohexo s 创建一个新博客hexo n “XXXX” 使用vsconde等编写内容。 清理hexo clean 生成博客hexo g 浏览刚才写的博客hexo s 配置github在最后添加1234deploy: type: git repository: git@github.com:jiaoqiang2014/jiaoqiang2014.github.io.git branch: master 换主题下载主题12git clone git@github.com:litten/hexo-theme-yilia.git themes/yiliagit@github.com:yscoder/hexo-theme-indigo.git 修改_config.yml配置1theme: yilia Hexo clean Hexo g Hero s 参考博客：1、 hexo增加分类、标签2、 hexo主题美化3 https://github.com/Neveryu/Neveryu.github.io/blob/","categories":[{"name":"hexo","slug":"hexo","permalink":"http://example.com/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://example.com/tags/hexo/"}]}]