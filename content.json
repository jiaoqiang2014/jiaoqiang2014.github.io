[{"title":"java8新特性","date":"2022-04-28T14:48:18.000Z","path":"2022/04/28/java8新特性/","text":"java8 新特性 接口的默认方法(Default Methods for Interfaces) Lambda表达式 函数式接口 内置的函数式接口(Built-in Functional Interfaces) Optional Streams(流) Parallel Streams(并行流) Date API(日期相关API) Annotations(注解) 链接总结的很棒java8 新特性。 1、接口的默认方法(Default Methods for Interfaces)12345678910111213141516171819202122232425package com.learnjava.java8;public class java8 &#123; public static void main(String[] args) &#123; Formula formula = new Formula() &#123; @Override public double calculate(double a, double b) &#123; return a + b; &#125; &#125;; System.out.println(formula.calculate(10, 12)); //使用 default 关键字向接口添加的非抽象方法可以直接调用 System.out.println(formula.mul(10, 12)); &#125;&#125;@FunctionalInterfaceinterface Formula&#123; double calculate(double a, double b); // Java 8使我们能够通过使用 default 关键字向接口添加非抽象方法实现。 此功能也称为虚拟扩展方法。 default double mul(int a, int b)&#123; return a*b; &#125;&#125; 2、Lambda 表达式一个简单的例子1234567891011121314151617181920public void lambda() &#123; List&lt;String&gt; names = Arrays.asList(&quot;peter&quot;, &quot;anna&quot;, &quot;mike&quot;, &quot;xenia&quot;); // 写法一 Collections.sort(names, new Comparator&lt;String&gt;() &#123; @Override public int compare(String o1, String o2) &#123; return o2.compareTo(o1); &#125; &#125;); names.forEach(c -&gt; log.info(c + &quot; &quot;)); // 写法二 Collections.sort(names, (a, b) -&gt; &#123; return b.compareTo(a); &#125;); // 写法三 names.sort((a, b) -&gt; b.compareTo(a)); &#125; lambda 表达式作用域可以直接在 lambda 表达式中访问 lambda 表达式外部的局部变量（注意和类变量和类属性区分），但不可以修改，其实就是会将次局部变量隐性的设置为final。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455@SpringBootApplication@Slf4jpublic class javaDemoApplication implements CommandLineRunner&#123; static int outerStaticNum; int outerNum; void testScopes() &#123; Converter&lt;Integer, String&gt; stringConverter1 = (from) -&gt; &#123; outerNum = 23; // 修改类属性(成员变量) return String.valueOf(from); &#125;; log.info(stringConverter1.Converter(1)); Converter&lt;Integer, String&gt; stringConverter2 = (from) -&gt; &#123; outerStaticNum = 72; // 修改类变量 return String.valueOf(from); &#125;; log.info(stringConverter2.Converter(2)); int num = 10; // lambda 表达式外部的局部变量 Converter&lt;Integer, String&gt; stringConverter3 = (from) -&gt; &#123;// num = 72; // 可以访问，但是修改会报错 log.info(String.valueOf(num)); return String.valueOf(from); &#125;; log.info(stringConverter3.Converter(3)); &#125; public static void main(String[] args) &#123; SpringApplication.run(javaDemoApplication.class, args); &#125; @Override public void run(String... args) throws Exception &#123; testScopes(); &#125;&#125;@FunctionalInterfaceinterface Converter&lt;F, T&gt; &#123; T Converter(F from); // 只能有一个抽象方法 /* * 可以有多个非抽象方法 * */ default int add(int a)&#123; return a + 10; &#125; default int mul(int a, int b)&#123; return a * 10; &#125;&#125; 3、函数式接口函数式接口主要用于搭配 lambda 表达式使用。“函数式接口”是指仅仅只包含一个抽象方法的接口。 像这样的接口，可以被隐式转换为lambda表达式。java.lang.Runnable 与 java.util.concurrent.Callable 是函数式接口最典型的两个例子。只要接口只包含一个抽象方法，虚拟机会自动判断该接口为函数式接口。大部分函数式接口都不用我们自己写，Java8都给我们实现好了，这些接口都在java.util.function包里。（from Guide） 函数式接口使用例子12345678910111213141516171819202122232425262728293031323334353637383940414243444546@SpringBootApplication@Slf4jpublic class javaDemoApplication implements CommandLineRunner&#123; public static void main(String[] args) &#123; SpringApplication.run(javaDemoApplication.class, args); &#125; @Override public void run(String... args) throws Exception &#123; /* * 方法一：Lambda 形式实现函数式接口 * */ // 方法一的非简化版本// Converter&lt;String, Integer&gt; converter = (from) -&gt; &#123;// return Integer.valueOf(from);// &#125;; // 方法一的简化版本 Converter&lt;String, Integer&gt; converter = (from) -&gt; Integer.valueOf(from); // 方法一使用函数式接口 Integer to = converter.Converter(&quot;12&quot;); log.info(String.valueOf(to)); /* * 方法二: 非 Lambda 形式实现函数式接口使用函数式接口 * */ Converter&lt;String, Integer&gt; converter2 = new Converter&lt;String, Integer&gt;() &#123; @Override public Integer Converter(String from) &#123; return Integer.valueOf(from); &#125; &#125;; converter2.Converter(&quot;12&quot;); log.info(String.valueOf(to)); &#125;&#125;// 定义函数式接口@FunctionalInterfaceinterface Converter&lt;F, T&gt; &#123; T Converter(F from);&#125; 内置的函数式接口(Built-in Functional Interfaces) Predicate Function Supplier Consumer Comparator Predicate1 Function1 Supplier1 Consumer1 Comparator1 4、OptionalOptional不是函数式接口，而是用于防止 NullPointerException 的漂亮工具。Optional 是一个简单的容器，在Java 8 之前一般某个函数应该返回非空对象但是有时却什么也没有返回，而在Java 8 中，你应该返回 Optional 而不是 null。（from Guide） 1234567891011121314//为非null的值创建一个OptionalOptional&lt;String&gt; optional = Optional.of(&quot;bam&quot;);//如果Optional实例有值则为其调用consumer，否则不做处理optional.ifPresent((s) -&gt; System.out.println(s.charAt(0))); // &quot;b&quot;// 如果值存在返回true，否则返回falseoptional.isPresent(); // true//如果Optional有值则将其返回，否则抛出NoSuchElementExceptionoptional.get(); // &quot;bam&quot;//如果有值则将其返回，否则返回指定的其它值optional.orElse(&quot;fallback&quot;); // &quot;bam&quot; 强烈推荐 Java8 如何正确使用 Optional 5、Streams(流)在 java.util.Stream 包中实现，可以分为中间操作和最终操作两类。 中间操作：中间操作返回Stream本身。包含的方法有：Filter、Sorted、Map 最终操作：最终操作返回一特定类型的计算结果。包含的方法有：Match、Count、Reduce Stream 的创建需要指定一个数据源，比如 java.util.Collection 的子类，List 或者 Set， Map 不支持。Map接口本身没有可用的 stream()方法，但是你可以在键，值上创建专门的流或者通过 map.keySet().stream(),map.values().stream()和map.entrySet().stream()。Stream 的操作可以串行执行或者并行执行。 实例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public void stream()&#123; List&lt;String&gt; stringList = new ArrayList&lt;&gt;(); stringList.add(&quot;ddd2&quot;); stringList.add(&quot;aaa2&quot;); stringList.add(&quot;bbb1&quot;); stringList.add(&quot;aaa1&quot;); stringList.add(&quot;bbb3&quot;); stringList.add(&quot;ccc&quot;); stringList.add(&quot;bbb2&quot;); stringList.add(&quot;ddd1&quot;); // Filter stringList.stream().filter(s -&gt; s.startsWith(&quot;a&quot;)).forEach(s -&gt; System.out.println(s)); System.out.println(); // Sorted stringList.stream().sorted().filter(s -&gt; s.startsWith(&quot;a&quot;)).forEach(s -&gt; System.out.println(s)); System.out.println(); // Map 通过map来将对象转换成其他类型 stringList.stream().map(s -&gt; s.toUpperCase()).sorted().forEach(s -&gt; System.out.println(s)); System.out.println(); // Match boolean anyStartWithA = stringList.stream().anyMatch(s -&gt; s.startsWith(&quot;a&quot;)); System.out.println(anyStartWithA); // true boolean allStartWithA = stringList.stream().allMatch(s -&gt; s.startsWith(&quot;a&quot;)); System.out.println(allStartWithA); // false // Count long startWithB = stringList.stream().filter(s -&gt; s.startsWith(&quot;b&quot;)).count(); System.out.println(startWithB); System.out.println(); // Reduce // 方法一 Optional&lt;String&gt; reduced = stringList .stream() .sorted() .reduce((s1, s2) -&gt; s1 + &quot;#&quot; + s2); reduced.ifPresent(s -&gt; System.out.println(s.toString())); // 方法二 stringList.stream().sorted().reduce(new BinaryOperator&lt;String&gt;() &#123; @Override public String apply(String s, String s2) &#123; s = s + &quot;#&quot; + s2; return s; &#125; &#125;); reduced.ifPresent(s -&gt; System.out.println(s.toString())); &#125; 6、Parallel Streams(并行流)7、Date API1 1 1 1 8、Annotations(注解)Java 8允许我们把同一个类型的注解使用多次，只需要给该注解标注一下@Repeatable即可。 多重注解实例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970@SpringBootApplication@Slf4jpublic class javaDemoApplication implements CommandLineRunner&#123; public static void main(String[] args) &#123; SpringApplication.run(javaDemoApplication.class, args); &#125; @Override public void run(String... args) throws Exception &#123; testAnnotations(); &#125; public void testAnnotations()&#123; /* * java 8 多重注解用法 * */ // 正确方法一：使用反射获取注解信息 Hint[] hints = Test.class.getAnnotationsByType(Hint.class); log.info(String.valueOf(hints.length)); // 2 // 正确方法二：使用反射获取注解信息 Hints hints1 = Test.class.getAnnotation(Hints.class); int len = hints1.value().length; log.info(String.valueOf(len)); // 2 // 错误方法二：使用反射获取注解信息 Hint hint = Test.class.getAnnotation(Hint.class); log.info(String.valueOf(hint)); // null /* * java 8 之前注解用法。 * */ Hint[] hints2 = Test2.class.getAnnotationsByType(Hint.class); log.info(String.valueOf(hints2.length)); // 2 &#125;&#125;/** 定义注解* */// RetentionPolicy.SOURCE：注解只保留在源文件，当Java文件编译成class文件的时候，注解被遗弃；// RetentionPolicy.CLASS：注解被保留到class文件，但jvm加载class文件时候被遗弃，这是默认的生命周期；// RetentionPolicy.RUNTIME：注解不仅被保存到class文件中，jvm加载class文件之后，仍然存在；@Retention(RetentionPolicy.RUNTIME)@interface Hints &#123; Hint[] value();&#125;// Java 8允许我们把同一个类型的注解使用多次，只需要给该注解标注一下@Repeatable即可。@Repeatable(Hints.class)@interface Hint&#123; String value();&#125;/* * java 8 多重注解 * */@Hint(&quot;hint1&quot;)@Hint(&quot;hint2&quot;)class Test&#123;&#125;/** java 8 之前注解* */@Hints(&#123;@Hint(&quot;hint1&quot;), @Hint(&quot;hint2&quot;)&#125;)class Test2 &#123;&#125;","categories":[{"name":"java","slug":"java","permalink":"http://example.com/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"}]},{"title":"gulimall配置","date":"2022-04-20T01:44:14.000Z","path":"2022/04/20/gulimall配置/","text":"1、环境配置 项目结构搭建 配置Mysql 配置renren-fast和renren-fast-vue 高版本的springboot默认不加载bootstrap.yml文件，需要在pom里加上依赖。 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-bootstrap&lt;/artifactId&gt;&lt;/dependency&gt;","categories":[],"tags":[]},{"title":"开发环境安装杂项","date":"2022-04-18T04:12:51.000Z","path":"2022/04/18/开发环境安装杂项/","text":"1、配置git 生成ssh 配置到github 测试 生成ssh1ssh-keygen -t rsa -C &quot;jiaoqiang2014@163.com&quot; 配置到github在~/.ssh目录下生成id_rsa.pub和id_rsa公钥和私钥。打开公钥，复制到github 1cat /Users/jq/.ssh/id_rsa.pub 测试连接1sudo ssh -T git@github.com 如果显示Hi jiaoqiang2014! You&#39;ve successfully authenticated, but GitHub does not provide shell access.表示，使用https没有使用ssh，切换到项目.git同级目录下，设置一下使用ssh就行。 1git remote set-url origin git@github.com:lut/EvolutionApp.git 2、docker 安装使用官方 docker doc 说明安装。 设置docker开机自启动1sudo systemctl enable docker docker安装mysql正常芯片1sudo docker pull mysql:8.0.28 M1芯片1sudo docker pull --platform linux/x86_64 mysql:8.0.28 查看安装的服务1sudo docker images 删除容器1docker container rm &lt;container id&gt; 删除镜像1docker image rm &lt;image id&gt; docker 启动 mysql123456sudo docker run -p 3306:3306 --name mysql \\-v /var/mysql/log:/var/log/mysql \\-v /var/mysql/data:/var/lib/mysql \\-v /var/mysql/conf:/etc/mysql \\-e MYSQL_ROOT_PASSWORD=123456aa \\-d mysql:8 上面代码不知道为啥启动不了 1docker run -p 3306:3306 --name mysql -e MYSQL_ROOT_PASSWORD=123456aa -d mysql:8 启动mysql容器1docker start mysql 进入 Mysql 容器1docker exec -it mysql bash navicat 连接 docker mysql在腾讯云选择该服务器——&gt;管理-&gt;防火墙中需要添加 mysql 3306端口的规则，不然会被屏蔽。 安装redis123docker pull redismkdir -p /mydata/redis/conftouch /mydata/redis/conf 启动 redis 镜像 1234docker run -p 6379:6379 --name redis \\-v /mydata/redis/data:/data \\-v /mydata/redis/conf/redis.conf:/etc/redis/redis.conf \\-d redis redis-server /etc/redis/redis.conf 检查redis安装是否成功 1234docker exec -it redis redis-cliauth 123456set key1 111get key1 持久化redisredis重启之后会丢失内存中的数据，可以设置持久化到磁盘中。 1vim /mydata/redis/conf/redis.conf 添加以下内容。 123appendonly yesbind 0.0.0.0 -::1requirepass 123456 给redis存值，重启，检查是否还存在。开启服务端TCP的6379端口。 docker 服务器重启自动启动程序1sudo docker update mysql --restart=always 3、前端项目配置杂项在项目目录下下载需要的组件。 1nmp install 报错 123npm ERR! command failednpm ERR! command sh -c node install.jsnpm ERR! Only Mac 64 bits supported. 使用下面命令可以解决。 123npm install --ignore-scriptsnpm uninstall node-saas //卸载node -saasnpm install node-sass --save-dev //重新安装node -saas 运行前端项目 1npm run dev 如果报错可以试试下面代码。 1npm cache --force clean &amp;&amp; npm install --force node-sass 4、renrenfast生成","categories":[],"tags":[{"name":"杂项","slug":"杂项","permalink":"http://example.com/tags/%E6%9D%82%E9%A1%B9/"}]},{"title":"玩转Spring全家桶学习笔记","date":"2022-04-17T13:21:32.000Z","path":"2022/04/17/玩转Spring全家桶学习笔记/","text":"第二章 JDBC必知必会1、配置单个数据源建立h2、web、lombak的springboot。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package com.example.learn;import com.example.learn.config.ProfileProperties;import com.example.learn.service.LibraryProperties;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.InitializingBean;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.CommandLineRunner;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.EnableAutoConfiguration;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration;import org.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration;import org.springframework.boot.autoconfigure.jdbc.JdbcTemplateAutoConfiguration;import org.springframework.boot.context.properties.EnableConfigurationProperties;import org.springframework.jdbc.core.JdbcTemplate;import javax.sql.DataSource;import java.sql.Connection;import java.sql.SQLException;@SpringBootApplication()public class DemoApplication implements CommandLineRunner &#123; private static final Logger log = LoggerFactory.getLogger(DemoApplication.class); @Autowired DataSource dataSource; @Autowired JdbcTemplate jdbcTemplate; public static void main(String[] args) &#123; SpringApplication.run(DemoApplication.class, args); &#125; @Override public void run(String... args) throws Exception &#123; showConnection(); showData(); &#125; private void showData() &#123; jdbcTemplate.queryForList(&quot;SELECT * FROM FOO&quot;).forEach(row -&gt; log.info(row.toString())); &#125; private void showConnection() throws SQLException &#123; log.info(dataSource.toString()); Connection conn = dataSource.getConnection(); log.info(conn.toString()); conn.close(); &#125;&#125; 在resource目录先创建schema.sql文件，写入： 1CREATE TABLE FOO (ID INT IDENTITY, BAR VARCHAR(64)); 在resource目录先创建data.sql文件，写入： 12INSERT INTO FOO (ID, BAR) VALUES(1, &#x27;aaa&#x27;)INSERT INTO FOO (ID, BAR) VALUES(2, &#x27;bbb&#x27;) 2、配置多个数据源配置文件application.properties中写入数据源的信息。 1234567foo.datasource.url=jdbc:h2:mem:foofoo.datasource.username=safoo.datasource.password=bar.datasource.url=jdbc:h2:mem:barbar.datasource.username=sabar.datasource.password= 需要指定使用什么连接池：COMMONS-DBCP、TOMCAT-JDBC、HIKARICP。 12345&lt;dependency&gt; &lt;groupId&gt;com.zaxxer&lt;/groupId&gt; &lt;artifactId&gt;HikariCP&lt;/artifactId&gt; &lt;version&gt;3.2.0&lt;/version&gt;&lt;/dependency&gt; 配置数据源 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475package multiDatasource;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.CommandLineRunner;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration;import org.springframework.boot.autoconfigure.jdbc.DataSourceProperties;import org.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration;import org.springframework.boot.autoconfigure.jdbc.JdbcTemplateAutoConfiguration;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.context.annotation.Bean;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.jdbc.datasource.DataSourceTransactionManager;import org.springframework.transaction.PlatformTransactionManager;import javax.annotation.Resource;import javax.sql.DataSource;import java.sql.Connection;import java.sql.SQLException;// 排除自动配置，进行手动配置@SpringBootApplication(exclude = &#123;DataSourceAutoConfiguration.class, DataSourceTransactionManagerAutoConfiguration.class, JdbcTemplateAutoConfiguration.class&#125;)public class MultiDataSourceApplication &#123; private static final Logger log = LoggerFactory.getLogger(MultiDataSourceApplication.class); public static void main(String[] args) &#123; SpringApplication.run(MultiDataSourceApplication.class, args); &#125; @Bean @ConfigurationProperties(&quot;foo.datasource&quot;) public DataSourceProperties fooDataSourceProperties()&#123; return new DataSourceProperties(); &#125; @Bean public DataSource fooDataSource()&#123; DataSourceProperties dataSourceProperties = fooDataSourceProperties(); log.info(&quot;foo datasource:&#123;&#125;&quot;, dataSourceProperties.getUrl()); return dataSourceProperties.initializeDataSourceBuilder().build(); &#125; @Bean @Resource public PlatformTransactionManager fooTxManager(DataSource fooDataSource)&#123; return new DataSourceTransactionManager(fooDataSource); &#125; @Bean @ConfigurationProperties(&quot;bar.datasource&quot;) public DataSourceProperties barDataSourceProperties()&#123; return new DataSourceProperties(); &#125; @Bean public DataSource barDataSource()&#123; DataSourceProperties dataSourceProperties = barDataSourceProperties(); log.info(&quot;bar datasource:&#123;&#125;&quot;, dataSourceProperties.getUrl()); return dataSourceProperties.initializeDataSourceBuilder().build(); &#125; @Bean @Resource public PlatformTransactionManager barTxManager(DataSource barDataSource)&#123; return new DataSourceTransactionManager(barDataSource); &#125;&#125; 3、数据库连接池推荐 druid：快 HikariCP：监控、SQL防注入 4、JdbcTemplate 的使用首先，添加H2数据库的依赖。 12345&lt;dependency&gt; &lt;groupId&gt;com.h2database&lt;/groupId&gt; &lt;artifactId&gt;h2&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt; 然后,创建和表对应的Entiy。 1234567@Data@Builderpublic class Foo &#123; private Long id; private String bar;&#125; 接下来，完成数据库的查询，添加等功能。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package simplejdbcdemo;import lombok.extern.slf4j.Slf4j;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.jdbc.core.RowMapper;import org.springframework.jdbc.core.simple.SimpleJdbcInsert;import org.springframework.stereotype.Repository;import javax.swing.*;import java.sql.ResultSet;import java.sql.SQLException;import java.util.Arrays;import java.util.HashMap;import java.util.List;@Slf4j@Repositorypublic class FooDao &#123; @Autowired private JdbcTemplate jdbcTemplate; @Autowired private SimpleJdbcInsert simpleJdbcInsert; public void insertData()&#123; // 方法一：使用jdbcTemplate Arrays.asList(&quot;a&quot;, &quot;b&quot;).forEach(bar -&gt; &#123; jdbcTemplate.update(&quot;insert into Foo (bar) values (?)&quot;, bar); &#125;); //方法二：使用simpleJdbcInsert HashMap&lt;String, String&gt; row = new HashMap&lt;&gt;(); row.put(&quot;bar&quot;, &quot;d&quot;); Number id = simpleJdbcInsert.executeAndReturnKey(row); log.info(&quot;ID of d: &#123;&#125;&quot;, id.longValue()); &#125; public void listData()&#123; log.info(&quot;Count: &#123;&#125;&quot;,jdbcTemplate.queryForObject(&quot;select count(*) from foo&quot;, Long.class)); List&lt;String&gt; list = jdbcTemplate.queryForList(&quot;select bar from foo&quot;, String.class); list.forEach(s -&gt; &#123;log.info(&quot;Bar: &#123;&#125;&quot;, s);&#125;); List&lt;Foo&gt; fooList = jdbcTemplate.query(&quot;select * from foo&quot;, new RowMapper&lt;Foo&gt;() &#123; @Override public Foo mapRow(ResultSet rs, int rowNum) throws SQLException &#123; return Foo.builder().id(rs.getLong(1)).bar(rs.getString(2)).build(); &#125; &#125;); fooList.forEach(f -&gt; log.info(&quot;Foo: &#123;&#125;&quot;, f)); &#125;&#125; 最后，在程序入口调用数据库操作。 1234567891011121314151617181920212223242526272829303132333435363738package simplejdbcdemo;import lombok.extern.slf4j.Slf4j;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.CommandLineRunner;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.context.annotation.Bean;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.jdbc.core.simple.SimpleJdbcInsert;@Slf4j@SpringBootApplicationpublic class SiampleJdbcDemoApplication implements CommandLineRunner &#123; public static void main(String[] args) &#123; SpringApplication.run(SiampleJdbcDemoApplication.class, args); &#125; @Autowired FooDao fooDao; @Bean @Autowired public SimpleJdbcInsert simpleJdbcInsert(JdbcTemplate jdbcTemplate) &#123; // 将 FOO 和 ID 绑定。 return new SimpleJdbcInsert(jdbcTemplate) .withTableName(&quot;FOO&quot;).usingGeneratedKeyColumns(&quot;ID&quot;); &#125; @Override public void run(String... args) throws Exception &#123; fooDao.insertData(); fooDao.listData(); &#125;&#125; 5、NamedParameterJdbcTemplate6、事务 编程式事务 声明式事务（推荐使用）编程式事务 TransactionTemplate PlatformTransactionTemplate 引入H2数据库的依赖。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package transaction;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.CommandLineRunner;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.transaction.TransactionStatus;import org.springframework.transaction.support.TransactionCallbackWithoutResult;import org.springframework.transaction.support.TransactionTemplate;import javax.sql.DataSource;import java.sql.Connection;import java.sql.SQLException;import java.util.List;@SpringBootApplication()public class TransactionDemoApplication implements CommandLineRunner &#123; private static final Logger log = LoggerFactory.getLogger(TransactionDemoApplication.class); @Autowired JdbcTemplate jdbcTemplate; @Autowired TransactionTemplate transactionTemplate; public static void main(String[] args) &#123; SpringApplication.run(TransactionDemoApplication.class, args); &#125; @Override public void run(String... args) throws Exception &#123; log.info(&quot;count before transaction: &#123;&#125;&quot;, getCount()); transactionTemplate.execute(new TransactionCallbackWithoutResult() &#123; @Override protected void doInTransactionWithoutResult(TransactionStatus status) &#123; jdbcTemplate.execute(&quot;INSERT INTO FOO (ID, BAR) VALUES (1, &#x27;AAA&#x27;)&quot;); log.info(&quot;count in transaction: &#123;&#125;&quot;, getCount()); status.setRollbackOnly(); &#125; &#125;); log.info(&quot;count after transaction: &#123;&#125;&quot;, getCount()); &#125; private long getCount()&#123;// List&lt;Integer&gt; list = jdbcTemplate.queryForList(&quot;select count(*) as cnt from FOO&quot;, Integer.class);// log.info(String.valueOf(list.get(0))); return (long)jdbcTemplate.queryForList(&quot;select count(*) as cnt from FOO&quot;).get(0).get(&quot;cnt&quot;); &#125;&#125; 声明式事务在 XML 配置文件中配置或者基于注解，实际是通过 AOP 实现（基于@Transactional 的全注解方式使用最多）。 测试声明式事务核心方法。 123456789101112131415161718192021222324252627282930313233343536package DeclarativeTransaction;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.stereotype.Component;import org.springframework.transaction.annotation.Transactional;@Componentpublic class FooServiceImpl implements FooService &#123; @Autowired JdbcTemplate jdbcTemplate; @Autowired FooService fooService; @Override @Transactional public void insertRecord() &#123; jdbcTemplate.execute(&quot;INSERT INTO FOO (BAR) VALUES (&#x27;AAA&#x27;)&quot;); &#125; @Override @Transactional(rollbackFor = RollbackException.class) public void insertThenRollback() throws RollbackException &#123; jdbcTemplate.execute(&quot;INSERT INTO FOO (BAR) VALUES (&#x27;BBB&#x27;)&quot;); throw new RollbackException(); &#125; @Override public void invokeInsertThenRollback() throws RollbackException &#123; // 思考这两个方法的不同。// insertThenRollback(); fooService.insertThenRollback(); &#125;&#125; 开始调用时需要开启事务注解。 123456789101112131415161718192021222324252627282930313233343536373839404142434445package DeclarativeTransaction;import lombok.extern.slf4j.Slf4j;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.CommandLineRunner;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.context.annotation.AdviceMode;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.transaction.annotation.EnableTransactionManagement;@SpringBootApplication@Slf4j@EnableTransactionManagement(mode = AdviceMode.PROXY) // 开启事务注解public class DeclarativeTransactionDemoApplication implements CommandLineRunner &#123; @Autowired FooService fooService; @Autowired JdbcTemplate jdbcTemplate; public static void main(String[] args) &#123; SpringApplication.run(DeclarativeTransactionDemoApplication.class, args); &#125; @Override public void run(String... args) throws Exception &#123; fooService.insertRecord(); log.info(&quot;AAA: &#123;&#125;&quot;, jdbcTemplate. queryForObject(&quot;SELECT COUNT(*) FROM FOO WHERE BAR=&#x27;AAA&#x27;&quot;, Long.class)); try &#123; fooService.insertThenRollback(); &#125; catch (RollbackException e) &#123; log.info(&quot;BBB &#123;&#125;&quot;,jdbcTemplate.queryForObject(&quot;SELECT COUNT(*) FROM FOO WHERE BAR=&#x27;BBB&#x27;&quot;, Long.class)); &#125; try &#123; fooService.invokeInsertThenRollback(); &#125; catch (RollbackException e) &#123; log.info(&quot;BBB &#123;&#125;&quot;,jdbcTemplate.queryForObject(&quot;SELECT COUNT(*) FROM FOO WHERE BAR=&#x27;BBB&#x27;&quot;, Long.class)); &#125; &#125;&#125; 定义的接口。 12345678package DeclarativeTransaction;public interface FooService &#123; public void insertRecord(); public void insertThenRollback() throws RollbackException; public void invokeInsertThenRollback() throws RollbackException;&#125; 定义的异常。 1234package DeclarativeTransaction;public class RollbackException extends Throwable &#123;&#125; 事务的传播特性TransactionDefinition.PROPAGATION_REQUIRED使用的最多的一个事务传播行为，我们平时经常使用的@Transactional注解默认使用就是这个事务传播行为。如果当前存在事务，则加入该事务，不会创建新事务；如果当前没有事务，则创建一个新的事务。 TransactionDefinition.PROPAGATION_REQUIRES_NEW始终新起一个事务，两个事务没有关联。 TransactionDefinition.PROPAGATION_NESTED 有事务：在原事务内启动一个内嵌事务。两个事务有关联，外部事务回滚，内嵌事务也会回滚。 TransactionDefinition.PROPAGATION_MANDATORY如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。（mandatory：强制性） 代码实例如下： 1234567891011121314151617181920212223242526272829303132333435363738package DeclarativeTransaction;import lombok.extern.slf4j.Slf4j;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.stereotype.Component;import org.springframework.transaction.annotation.Propagation;import org.springframework.transaction.annotation.Transactional;@Slf4j@Componentpublic class FooServiceImpl implements FooService &#123; @Autowired JdbcTemplate jdbcTemplate; @Autowired FooService fooService; @Override @Transactional(rollbackFor = RollbackException.class, propagation = Propagation.REQUIRES_NEW) public void insertThenRollback() throws RollbackException &#123; jdbcTemplate.execute(&quot;INSERT INTO FOO (BAR) VALUES (&#x27;BBB&#x27;)&quot;); // throw new RollbackException(); &#125; @Override @Transactional(rollbackFor = RollbackException.class) public void invokeInsertThenRollback() throws RollbackException &#123; jdbcTemplate.execute(&quot;INSERT INTO FOO (BAR) VALUES (&#x27;AAA&#x27;)&quot;); try &#123; fooService.insertThenRollback(); &#125;catch (RollbackException e)&#123; log.error(&quot;RollbackException&quot;, e); &#125; throw new RollbackException(); &#125;&#125; 7、慢 SQL 日志开启慢 SQL 日志，设置超过 100ms 的sql为慢sql。 12spring.datasource.druid.filter.stat.log-slow-sql=truespring.datasource.druid.filter.stat.slow-sql-millis=100 测试代码如下： 123456789@Override@Transactionalpublic void selectForUpdate()&#123; jdbcTemplate.queryForObject(&quot;select id from foo where id = 1 for update&quot;, Long.class); try&#123; Thread.sleep(200); &#125;catch (InterruptedException e)&#123; &#125;&#125; 调用代码如下： 1234567891011121314151617181920212223242526272829303132333435363738package DeclarativeTransaction;import lombok.extern.slf4j.Slf4j;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.CommandLineRunner;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.context.annotation.AdviceMode;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.transaction.annotation.EnableTransactionManagement;import javax.sql.DataSource;@SpringBootApplication@Slf4j@EnableTransactionManagement(mode = AdviceMode.PROXY) // 开启事务注解public class DeclarativeTransactionDemoApplication implements CommandLineRunner &#123; @Autowired FooService fooService; @Autowired JdbcTemplate jdbcTemplate; @Autowired DataSource dataSource; public static void main(String[] args) &#123; SpringApplication.run(DeclarativeTransactionDemoApplication.class, args); &#125; @Override public void run(String... args) throws Exception &#123; log.info(dataSource.toString()); new Thread(() -&gt; fooService.selectForUpdate()).start(); new Thread(() -&gt; fooService.selectForUpdate()).start(); &#125;&#125; 控制台输出 1c.alibaba.druid.filter.stat.StatFilter: slow sql 212 millis. select id from foo where id = 1 for update[] 第三章 O/R Mapping 实践 ORM（Object/Relational Mapping）”对象-关系映射”。简单说，ORM 就是通过实例对象的语法，完成关系型数据库的操作的技术。 推荐阅读: JPA、Hibernate、Spring Data JPA之间的关系 1、Spring Data JPAJava 持久层框架访问数据库的方式大致分为两种。一种以 SQL 核心，封装一定程度的 JDBC 操作，比如： MyBatis。另一种是以 Java 实体类为核心，将实体类的和数据库表之间建立映射关系，也就是我们说的ORM框架，如：Hibernate、Spring Data JPA（Java Persistence API Java持久层API）。 Spring Data JPA 提供的支持 @EnableJpaRepositories Repository 接口： CrudRepository&lt;T, ID&gt; PagingAndSortingRepository&lt;T, ID&gt; JpaRepository&lt;T, ID&gt; Repository 实现类： SimpleJpaRepository QueryDslJpaRepository 2、使用 Spring Data JPA 操作数据库创建实体（表）使用SpringBoot内嵌的H2数据库。创建一个咖啡表和一个咖啡订单表。咖啡表 123456789101112131415161718192021222324252627282930package com.jq.coffe.model;import lombok.*;import lombok.extern.slf4j.Slf4j;import org.hibernate.annotations.CreationTimestamp;import org.hibernate.annotations.Type;import org.hibernate.annotations.UpdateTimestamp;import org.joda.money.Money;import javax.persistence.*;import java.io.Serializable;import java.util.Date;@Data@Entity // 实体@Table(name = &quot;T_MENU&quot;)@Builder // @Builder声明表示实体可以使用Builder方式初始化@Slf4j@NoArgsConstructor@AllArgsConstructor@ToString(callSuper = true)public class Coffee extends BaseEntity implements Serializable &#123; private String name; @Column @Type(type = &quot;org.jadira.usertype.moneyandcurrency.joda.PersistentMoneyMinorAmount&quot;, parameters = &#123;@org.hibernate.annotations.Parameter(name = &quot;currencyCode&quot;, value = &quot;CNY&quot;)&#125;) private Money price;&#125; 咖啡订单表 1234567891011121314151617181920212223242526272829303132333435363738package com.jq.coffe.model;import com.jq.coffe.model.BaseEntity;import com.jq.coffe.model.Coffee;import com.jq.coffe.model.OrderState;import lombok.AllArgsConstructor;import lombok.Builder;import lombok.Data;import lombok.NoArgsConstructor;import lombok.ToString;import javax.persistence.Column;import javax.persistence.Entity;import javax.persistence.Enumerated;import javax.persistence.JoinTable;import javax.persistence.ManyToMany;import javax.persistence.OrderBy;import javax.persistence.Table;import java.io.Serializable;import java.util.List;@Entity@Table(name = &quot;T_ORDER&quot;)@Data@ToString(callSuper = true)@NoArgsConstructor@AllArgsConstructor@Builderpublic class CoffeeOrder extends BaseEntity implements Serializable &#123; private String customer; @ManyToMany @JoinTable(name = &quot;T_ORDER_COFFEE&quot;) // 创建一个 T_ORDER_COFFEE 表 @OrderBy(&quot;id&quot;) private List&lt;Coffee&gt; items; @Enumerated @Column(nullable = false) // 可以为空 private OrderState state;&#125; 父类 1234567891011121314151617181920212223242526272829package com.jq.coffe.model;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;import org.hibernate.annotations.CreationTimestamp;import org.hibernate.annotations.Type;import org.hibernate.annotations.UpdateTimestamp;import org.joda.money.Money;import javax.persistence.*;import java.io.Serializable;import java.util.Date;// 编写一个父类,将这些共同属性放到这个父类中, 并且在父类上加上@MappedSuperclass注解.注意:标注为@MappedSuperclass的类将不是一个完整的实体类，他将不会映射到数据库表，但是他的属性都将映射到其子类的数据库字段中。@MappedSuperclass @Data@NoArgsConstructor@AllArgsConstructorpublic class BaseEntity implements Serializable &#123; @Id // 表示主键 @GeneratedValue // 主键生成规则 private Long id; @Column(updatable = false) // 不可以更新 @CreationTimestamp private Date createTime; @UpdateTimestamp private Date updateTime;&#125; 实现 操作数据库的接口这些接口的命名是固定好的，只要按规定格式命名，Spring Boot JPA 就会帮我们做具体操作数据库的逻辑。 123456789package com.jq.coffe.repository;import org.springframework.data.repository.NoRepositoryBean;import org.springframework.data.repository.PagingAndSortingRepository;import java.util.List;@NoRepositoryBean // 表示不会作为一个Beanpublic interface BaseRepository&lt;T, Long&gt; extends PagingAndSortingRepository&lt;T, Long&gt; &#123; List&lt;T&gt; findTop3ByOrderByUpdateTimeDescIdAsc();&#125; 操作咖啡表的接口 12345package com.jq.coffe.repository;import com.jq.coffe.model.Coffee;public interface CoffeeRepository extends BaseRepository&lt;Coffee, Long&gt; &#123;&#125; 操作咖啡订单表的接口 123456789package com.jq.coffe.repository;import com.jq.coffe.model.CoffeeOrder;import org.springframework.data.repository.CrudRepository;import java.util.List;public interface CoffeeOrderRepository extends BaseRepository&lt;CoffeeOrder, Long&gt; &#123; List&lt;CoffeeOrder&gt; findByCustomerOrderById(String customer); List&lt;CoffeeOrder&gt; findByItems_Name(String name);&#125; 测试代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104package com.jq.coffe;import com.jq.coffe.model.Coffee;import com.jq.coffe.model.CoffeeOrder;import com.jq.coffe.model.OrderState;import com.jq.coffe.repository.CoffeeOrderRepository;import com.jq.coffe.repository.CoffeeRepository;import lombok.extern.slf4j.Slf4j;import org.joda.money.CurrencyUnit;import org.joda.money.Money;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.ApplicationArguments;import org.springframework.boot.ApplicationRunner;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.data.domain.Sort;import org.springframework.data.jpa.repository.config.EnableJpaRepositories;import org.springframework.transaction.annotation.EnableTransactionManagement;import org.springframework.transaction.annotation.Transactional;import java.util.Arrays;import java.util.Collections;import java.util.List;import java.util.stream.Collectors;@SpringBootApplication@Slf4j@EnableJpaRepositories@EnableTransactionManagementpublic class CoffeApplication implements ApplicationRunner &#123; @Autowired CoffeeRepository coffeeRepository; @Autowired CoffeeOrderRepository orderRepository; public static void main(String[] args) &#123; SpringApplication.run(CoffeApplication.class, args); &#125; @Override @Transactional public void run(ApplicationArguments args) throws Exception &#123; initOrders(); findOrders(); &#125; private void initOrders()&#123; Coffee espresso = Coffee.builder().name(&quot;espresso&quot;) .price(Money.of(CurrencyUnit.of(&quot;CNY&quot;), 20.0)) .build(); coffeeRepository.save(espresso); log.info(&quot;Coffee: &#123;&#125;&quot;, espresso); Coffee latte = Coffee.builder().name(&quot;latte&quot;) .price(Money.of(CurrencyUnit.of(&quot;CNY&quot;), 30.0)) .build(); coffeeRepository.save(latte); log.info(&quot;Coffee: &#123;&#125;&quot;, latte); CoffeeOrder order = CoffeeOrder.builder() .customer(&quot;Li Lei&quot;) .items(Collections.singletonList(espresso)) // 创建不可变List的单个元素 .state(OrderState.INIT) .build(); orderRepository.save(order); log.info(&quot;Order: &#123;&#125;&quot;, order); order = CoffeeOrder.builder() .customer(&quot;Li Lei&quot;) .items(Arrays.asList(espresso, latte)) .state(OrderState.INIT) .build(); orderRepository.save(order); log.info(&quot;Order: &#123;&#125;&quot;, order); &#125; private void findOrders() &#123; coffeeRepository .findAll(Sort.by(Sort.Direction.DESC, &quot;id&quot;)) .forEach(c -&gt; log.info(&quot;Loading &#123;&#125;&quot;, c)); List&lt;CoffeeOrder&gt; list = orderRepository.findTop3ByOrderByUpdateTimeDescIdAsc(); log.info(&quot;findTop3ByOrderByUpdateTimeDescIdAsc: &#123;&#125;&quot;, getJoinedOrderId(list)); list = orderRepository.findByCustomerOrderById(&quot;Li Lei&quot;); log.info(&quot;findByCustomerOrderById: &#123;&#125;&quot;, getJoinedOrderId(list)); // 不开启事务会因为没Session而报LazyInitializationException list.forEach(o -&gt; &#123; log.info(&quot;Order &#123;&#125;&quot;, o.getId()); o.getItems().forEach(i -&gt; log.info(&quot; Item &#123;&#125;&quot;, i)); &#125;); list = orderRepository.findByItems_Name(&quot;latte&quot;); log.info(&quot;findByItems_Name: &#123;&#125;&quot;, getJoinedOrderId(list)); &#125; private String getJoinedOrderId(List&lt;CoffeeOrder&gt; list) &#123; return list.stream().map(o -&gt; o.getId().toString()) .collect(Collectors.joining(&quot;,&quot;)); &#125;&#125; 3、MyBatis 操作数据库 代码仓库 一款持久化框架，支持定制化SQL、存储过程和高级映射。JPA中SQL是框架自动生成的，MyBatis是自己手写的。 定义Coffee，其中 Price 使用Joda-Money。 12345678910111213141516171819202122package com.example.mybatis.model;import lombok.AllArgsConstructor;import lombok.Builder;import lombok.Data;import lombok.NoArgsConstructor;import org.joda.money.Money;import java.util.Date;@Data@AllArgsConstructor@NoArgsConstructor@Builderpublic class Coffee &#123; private Long id; private String name; private Money price; private Date createTime; private Date updateTime;&#125; 创建表：新建 schema.sql 文件 12345678create table t_coffee ( id bigint not null auto_increment, name varchar(255), price bigint not null, create_time timestamp, update_time timestamp, primary key (id)); Mapper sql语句 123456789101112131415161718192021222324package com.example.mybatis.mapper;import com.example.mybatis.model.Coffee;import org.apache.ibatis.annotations.*;@Mapperpublic interface CoffeeMapper &#123; // insert into t_coffee (name, price, create_time, update_time) values (&quot;latte&quot;,30.0, &#x27;2022-05-06&#x27;, &#x27;2022-05-06&#x27;); @Insert(&quot;insert into t_coffee (name, price, create_time, update_time) values (#&#123;name&#125;, #&#123;price&#125;, #&#123;createTime&#125;, #&#123;updateTime&#125;)&quot;) @Options(useGeneratedKeys = true, keyColumn = &quot;id&quot;, keyProperty = &quot;id&quot;) // 指定在数据库中的字段名 id，实例对象中主键的属性名 id。 int save(Coffee coffee); // 返回的是变动记录的条数 // select * from t_coffee where id = #&#123;id&#125; @Select(&quot;select * from t_coffee where id = #&#123;id&#125;&quot;) @Results(&#123; @Result(id = true, column = &quot;id&quot;, property = &quot;id&quot;), @Result(column = &quot;create_time&quot;, property = &quot;createTime&quot;), // 实例对象名字为 create_time，数据库中名字为 createTime。 // map-underscore-to-camel-case = true 可以实现一样的效果 // @Result(column = &quot;update_time&quot;, property = &quot;updateTime&quot;) &#125;) // @Param(&quot;id&quot;)对应where id = #&#123;id&#125;里的#&#123;id&#125;，给个例子，万一大家以后变量名和参数名不一样，也好知道怎么写。 Coffee findById(@Param(&quot;id&quot;) Long id);&#125; 引入类型转换的配置 1234# 表示是类型转化时包的前缀mybatis.type-handlers-package=com.example.mybatis.handler# 将下划线转化为驼峰规则mybatis.configuration.map-underscore-to-camel-case=true 定义自己的handle，用于处理Money的类型转换（类中使用 Money 类型的price，数据库中使用 bigint 类型的price） 123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.example.mybatis.handler;import org.apache.ibatis.type.BaseTypeHandler;import org.apache.ibatis.type.JdbcType;import org.joda.money.CurrencyUnit;import org.joda.money.Money;import java.sql.CallableStatement;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;/** * 类中使用 Money 类型的price，数据库中使用 bigint 类型的price。 * mybatis在没有配置handler时，会根据参数或者返回结果的不同，默认为我们选择合适的TypeHandler处理。 * 当我们需要特殊的字段处理时，可以配置自己的handler。 * 首先，在配置文件中引入 配置的包。 * 然后，实现 BaseTypeHandler 接口完成自己的类。 * 在 Money 与 Long 之间转换的 TypeHandler，处理 CNY 人民币 */public class MoneyTypeHandler extends BaseTypeHandler&lt;Money&gt; &#123; @Override public void setNonNullParameter(PreparedStatement ps, int i, Money parameter, JdbcType jdbcType) throws SQLException &#123; ps.setLong(i, parameter.getAmountMinorLong()); &#125; @Override public Money getNullableResult(ResultSet rs, String columnName) throws SQLException &#123; return parseMoney(rs.getLong(columnName)); &#125; @Override public Money getNullableResult(ResultSet rs, int columnIndex) throws SQLException &#123; return parseMoney(rs.getLong(columnIndex)); &#125; @Override public Money getNullableResult(CallableStatement cs, int columnIndex) throws SQLException &#123; return parseMoney(cs.getLong(columnIndex)); &#125; private Money parseMoney(Long value) &#123; return Money.of(CurrencyUnit.of(&quot;CNY&quot;), value / 100.0); &#125;&#125; 调用代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.example.mybatis;import com.example.mybatis.mapper.CoffeeMapper;import com.example.mybatis.model.Coffee;import lombok.extern.slf4j.Slf4j;import org.apache.ibatis.annotations.Mapper;import org.joda.money.CurrencyUnit;import org.joda.money.Money;import org.mybatis.spring.annotation.MapperScan;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.ApplicationArguments;import org.springframework.boot.ApplicationRunner;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplication@Slf4j@MapperScan(&quot;com.example.mybatis.mapper&quot;) // 扫描对应包里边的mapper映射public class MybatisApplication implements ApplicationRunner &#123; @Autowired CoffeeMapper coffeeMapper; public static void main(String[] args) &#123; SpringApplication.run(MybatisApplication.class, args); &#125; @Override public void run(ApplicationArguments args) throws Exception &#123; // 将 name 的值设置为 espresso，将price的值设置为 20.0。和sql中的$&#123;name&#125;和$&#123;price&#125;对应。 // @Insert(&quot;insert into t_coffee (name, price, create_time, update_time) values (#&#123;name&#125;, #&#123;price&#125;, now(), now())&quot;) Coffee coffee = Coffee.builder().name(&quot;espresso&quot;) .price(Money.of(CurrencyUnit.of(&quot;CNY&quot;), 20.0)) .createTime(new Date()) .updateTime(new Date()) .build(); int count = coffeeMapper.save(coffee); log.info(&quot;Save &#123;&#125; Coffee: &#123;&#125;&quot;, count, coffee); coffee = Coffee.builder().name(&quot;latte&quot;) .price(Money.of(CurrencyUnit.of(&quot;CNY&quot;), 25.0)) .createTime(new Date()) .updateTime(new Date()).build(); count = coffeeMapper.save(coffee); log.info(&quot;Save &#123;&#125; Coffee: &#123;&#125;&quot;, count, coffee); coffeeMapper.findById(coffee.getId()); log.info(&quot;Find Coffee: &#123;&#125;&quot;, coffee); &#125;&#125; 4、MaBatis Generator代码仓库 5、MaBatis PageHelper代码仓库 第四章 NoSQL 实践1、docker 的一些环境安装1docker run --name mongo -p 27017:27017 -v ~/docker-data/mongo:/data/db -e MONGO_INITDB_ROOT_USERNAME=admin -e MONGO_INITDB_ROOT_PASSWORD=admin -d mongo 2、MongoDBMongoDB 是一款开源的文档型数据库。Spring 对 MongoDB 的支持： Spring Data MongoDB MongoTemplate Repository 支持 注解 @Document 和 @Entity 类似，表示类是一个文档（@Entity中是表） @Id 每个文档都会对应一个 Id ，通过@Id表明类中哪一个属性是id。加上 @Id 之后，Spring Data Mongo 会将属性的类型转化为 MongoDB 中的 object ID。 MongoTemplate save / remove Criteria / Query / Update Spring Data MongoDB 的 Repository @EnableMongoRepositories 对应接口 MongoRepository&lt;T, ID&gt; PagingAndSortingRepository&lt;T, ID&gt; CrudRepository&lt;T, ID&gt; 3、Spring 中访问 MongoDB代码仓库 3.1 安装 MongoDB使用 docker 安装。 1234567891011121314151617181920212223242526272829docker pull Mongodocker exec -it mongo bashmongo -u admin -p admin// 显示当前存在的库show dbs// 使用springbucks库，没有会默认创建一个use springbucks// 创建 createUser，用户名和密码都为springbucks。db.createUser( &#123; user: &quot;springbucks&quot;, pwd: &quot;springbucks&quot;, roles: [ &#123;role: &quot;readWrite&quot;, db: &quot;springbucks&quot;&#125; ] &#125;)show usersshow collections;db.coffee.find();// 删除 coffee 中所有名为 espresso 的 Document 。db.coffee.remove(&#123;&quot;name&quot;:&quot;espresso&quot;&#125;); 3.2 基于 MongoTemplate 的方法创建 Coffee 类1234567891011121314151617181920212223242526package com.example.mongo.model;import lombok.AllArgsConstructor;import lombok.Builder;import lombok.Data;import lombok.NoArgsConstructor;import org.joda.money.Money;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.data.annotation.Id;import org.springframework.data.mongodb.core.mapping.Document;import java.util.Date;// 表示类是一个文档@Document@Data@AllArgsConstructor@NoArgsConstructor@Builderpublic class Coffee &#123; @Id private String id; // 加上 @Id 之后，Spring Data Mongo 会将String类型转化为 MongoDB 中的 object ID。 private String name; private Money price; private Date createTime; private Date updateTime;&#125; 配置 MongoDB123# 用户名密码对应 springbucks:springbucks ，使用 springbucks 库。spring.data.mongodb.uri=mongodb://springbucks:springbucks@124.220.171.2:27017/springbucksspring.main.allow-circular-references=true 编写特殊类型 Money 的转化代码（ Mongo -&gt; Money 类型）从 Money 类型转化为 Mongo 中的 Document 是自动转化的，不需要我们自己手写。其实就是转化为 Dson 类型（和json相似）。mongo 中存储的 Coffee 对象格式如下，这是一条 Document 123456789101112131415&#123; &quot;_id&quot; : ObjectId(&quot;626b59f24eb80121ff790475&quot;),&quot;name&quot; : &quot;espresso&quot;,&quot;price&quot; : &#123; &quot;money&quot; : &#123; &quot;currency&quot; : &#123; &quot;code&quot; : &quot;CNY&quot;, &quot;numericCode&quot; : 156, &quot;decimalPlaces&quot; : 2 &#125;, &quot;amount&quot; : &quot;20.00&quot; &#125; &#125;,&quot;createTime&quot; : ISODate(&quot;2022-04-29T03:22:26.240Z&quot;),&quot;updateTime&quot; : ISODate(&quot;2022-04-29T03:22:26.240Z&quot;),&quot;_class&quot; : &quot;com.example.mongo.model.Coffee&quot; &#125; Mongo -&gt; Money 类型 123456789101112131415161718192021package com.example.mongo.converter;import org.bson.Document;import org.joda.money.CurrencyUnit;import org.joda.money.Money;import org.springframework.core.convert.converter.Converter;/** Document 转化为 Money。* */public class MoneyReadConverter implements Converter&lt;Document, Money&gt; &#123; @Override public Money convert(Document source) &#123; // Mongo 取出 Document 的数据，从中取出 money。 Document money = (Document) source.get(&quot;money&quot;); // 从 money 中解析出金额。 double amount = Double.parseDouble(money.getString(&quot;amount&quot;)); String currency = ((Document) money.get(&quot;currency&quot;)).getString(&quot;code&quot;); return Money.of(CurrencyUnit.of(currency), amount); &#125;&#125; 调用代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778package com.example.mongo;import com.example.mongo.converter.MoneyReadConverter;import com.example.mongo.model.Coffee;import com.mongodb.client.result.UpdateResult;import com.mongodb.internal.bulk.UpdateRequest;import lombok.extern.slf4j.Slf4j;import org.joda.money.CurrencyUnit;import org.joda.money.Money;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.ApplicationArguments;import org.springframework.boot.ApplicationRunner;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.context.annotation.Bean;import org.springframework.data.mongodb.ClientSessionException;import org.springframework.data.mongodb.core.MongoTemplate;import org.springframework.data.mongodb.core.convert.MongoCustomConversions;import org.springframework.data.mongodb.core.query.Criteria;import org.springframework.data.mongodb.core.query.Query;import org.springframework.data.mongodb.core.query.Update;import java.util.Arrays;import java.util.Date;import java.util.List;import static org.springframework.data.mongodb.core.query.Criteria.where;import static org.springframework.data.mongodb.core.query.Query.query;@SpringBootApplication@Slf4jpublic class MongoApplication implements ApplicationRunner &#123; @Autowired MongoTemplate mongoTemplate; public static void main(String[] args) &#123; SpringApplication.run(MongoApplication.class, args); &#125; // 查看 spring-boot-autoconfigure -&gt; data -&gt; mongo -&gt; MongoDataAutoConfiguration.class // 可以看出构造一个 MongoCustomConversions 类型的 bean ，可以替代 MongoDataAutoConfiguration 中的一部分配置。 @Bean public MongoCustomConversions mongoCustomConversions()&#123; return new MongoCustomConversions(Arrays.asList(new MoneyReadConverter())); &#125; @Override public void run(ApplicationArguments args) throws Exception &#123; //插入 Coffee espresso = Coffee.builder() .name(&quot;espresso&quot;) .price(Money.of(CurrencyUnit.of(&quot;CNY&quot;), 20.0)) .createTime(new Date()) .updateTime(new Date()).build(); Coffee saved = mongoTemplate.save(espresso); log.info(&quot;Coffee &#123;&#125;&quot;, saved); // 查询 List&lt;Coffee&gt; list = mongoTemplate.find(query(where(&quot;name&quot;).is(&quot;espresso&quot;)), Coffee.class); log.info(&quot;Find &#123;&#125; Coffee&quot;, list.size()); list.forEach(c -&gt; log.info(&quot;Coffee &#123;&#125;&quot;, c)); // 更新 Thread.sleep(1000); // 为了看更新时间 1s UpdateResult result = mongoTemplate.updateFirst(query(where(&quot;name&quot;).is(&quot;espresso&quot;)), new Update().set(&quot;price&quot;, Money.ofMajor(CurrencyUnit.of(&quot;CNY&quot;), 30)) .currentDate(&quot;updateTime&quot;), Coffee.class); log.info(&quot;Update Result: &#123;&#125;&quot;, result.getModifiedCount()); Coffee updateOne = mongoTemplate.findById(saved.getId(), Coffee.class); log.info(&quot;Update Result: &#123;&#125;&quot;, updateOne); // 删除 mongoTemplate.remove(updateOne); &#125;&#125; 3.3 基于 Spring Data MongoDB 的 Repository 的方法代码仓库在基于 MongoTemplate 的方法基础上实现 MongoRepository 接口 12345678910package com.example.mongo.repository;import com.example.mongo.model.Coffee;import org.springframework.data.mongodb.repository.MongoRepository;import java.util.List;public interface CoffeeRepository extends MongoRepository&lt;Coffee, String&gt; &#123; List&lt;Coffee&gt; findByName(String name);&#125; 添加@EnableMongoRepositories注解，修改调用代码如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677package com.example.mongo;import com.example.mongo.converter.MoneyReadConverter;import com.example.mongo.model.Coffee;import com.example.mongo.repository.CoffeeRepository;import com.mongodb.client.result.UpdateResult;import com.mongodb.internal.bulk.UpdateRequest;import lombok.extern.slf4j.Slf4j;import org.joda.money.CurrencyUnit;import org.joda.money.Money;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.ApplicationArguments;import org.springframework.boot.ApplicationRunner;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.context.annotation.Bean;import org.springframework.data.domain.Sort;import org.springframework.data.mongodb.ClientSessionException;import org.springframework.data.mongodb.core.MongoTemplate;import org.springframework.data.mongodb.core.convert.MongoCustomConversions;import org.springframework.data.mongodb.core.query.Criteria;import org.springframework.data.mongodb.core.query.Query;import org.springframework.data.mongodb.core.query.Update;import org.springframework.data.mongodb.repository.config.EnableMongoRepositories;import java.util.Arrays;import java.util.Date;import java.util.List;import static org.springframework.data.mongodb.core.query.Criteria.where;import static org.springframework.data.mongodb.core.query.Query.query;@SpringBootApplication@Slf4j@EnableMongoRepositoriespublic class MongoApplication implements ApplicationRunner &#123; @Autowired CoffeeRepository coffeeRepository; public static void main(String[] args) &#123; SpringApplication.run(MongoApplication.class, args); &#125; // 查看 spring-boot-autoconfigure -&gt; data -&gt; mongo -&gt; MongoDataAutoConfiguration.class // 可以看出构造一个 MongoCustomConversions 类型的 bean ，可以替代 MongoDataAutoConfiguration 中的一部分配置。 @Bean public MongoCustomConversions mongoCustomConversions()&#123; return new MongoCustomConversions(Arrays.asList(new MoneyReadConverter())); &#125; @Override public void run(ApplicationArguments args) throws Exception &#123; //插入 Coffee espresso = Coffee.builder() .name(&quot;espresso&quot;) .price(Money.of(CurrencyUnit.of(&quot;CNY&quot;), 20.0)) .createTime(new Date()) .updateTime(new Date()).build(); Coffee latte = Coffee.builder() .name(&quot;latte&quot;) .price(Money.of(CurrencyUnit.of(&quot;CNY&quot;), 30.0)) .createTime(new Date()) .updateTime(new Date()).build(); coffeeRepository.insert(Arrays.asList(espresso, latte)); coffeeRepository.findAll(Sort.by(&quot;name&quot;)).forEach(c -&gt; log.info(&quot;Saved Coffee &#123;&#125;&quot;, c)); Thread.sleep(1000); latte.setPrice(Money.of(CurrencyUnit.of(&quot;CNY&quot;), 35.0)); latte.setUpdateTime(new Date()); coffeeRepository.save(latte); coffeeRepository.findByName(&quot;latte&quot;).forEach(c -&gt; log.info(&quot;Coffee &#123;&#125;&quot;, c)); coffeeRepository.deleteAll(); &#125;&#125; 4、RedisSpring 对 Redis 的支持 – Spring Data Redis 支持客户端Jedis / Lettuce RedisTemplate Repository 支持 Jedis 客户端的简单使用-代码仓库 Jedis 不是线程安全的 通过 JedisPool 获得 Jedis 实例。原因： Jedis 不安全，不能在多个线程中中使用同一个 jeid ，因此使用 JedisPool 管理 jedis，没次使用时从 JedisPool 中取。 直接使用 Jedis 中的方法 实现功能在前面 MongDB 的基础上，使用 Jedis 连接 Redis ，并且测试基本的增删改查。 新建 scheme.sql 文件。 1234567891011121314151617181920212223242526drop table t_coffee if exists;drop table t_order if exists;drop table t_order_coffee if exists;create table t_coffee ( id bigint auto_increment, create_time timestamp, update_time timestamp, name varchar(255), price bigint, primary key (id));create table t_order ( id bigint auto_increment, create_time timestamp, update_time timestamp, customer varchar(255), state integer not null, primary key (id));create table t_order_coffee ( coffee_order_id bigint not null, items_id bigint not null); 新建 data.sql 文件。 12345insert into t_coffee (name, price, create_time, update_time) values (&#x27;espresso&#x27;, 2000, now(), now());insert into t_coffee (name, price, create_time, update_time) values (&#x27;latte&#x27;, 2500, now(), now());insert into t_coffee (name, price, create_time, update_time) values (&#x27;capuccino&#x27;, 2500, now(), now());insert into t_coffee (name, price, create_time, update_time) values (&#x27;mocha&#x27;, 3000, now(), now());insert into t_coffee (name, price, create_time, update_time) values (&#x27;macchiato&#x27;, 3000, now(), now()); 配置 Jedis 1234567891011121314spring.jpa.hibernate.ddl-auto=nonespring.jpa.properties.hibernate.show_sql=truespring.jpa.properties.hibernate.form_sql=true# redisredis.host=124.220.171.2redis.password=123456redis.port=6379redis.maxTotal=5redis.maxIdle=5# 向资源池借用连接时是否做连接有效性检测（ping）。检测到的无效连接将会被移除。redis.testOnBorrow=falsespring.main.allow-circular-references=true 测试 Jedis 代码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110package com.jq.coffe;import com.jq.coffe.model.Coffee;import com.jq.coffe.model.CoffeeOrder;import com.jq.coffe.model.OrderState;import com.jq.coffe.repository.CoffeeOrderRepository;import com.jq.coffe.repository.CoffeeRepository;import com.jq.coffe.service.CoffeeOrderService;import com.jq.coffe.service.CoffeeService;import lombok.extern.slf4j.Slf4j;import org.joda.money.CurrencyUnit;import org.joda.money.Money;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Value;import org.springframework.boot.ApplicationArguments;import org.springframework.boot.ApplicationRunner;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.context.annotation.Bean;import org.springframework.data.domain.Sort;import org.springframework.data.jpa.repository.config.EnableJpaRepositories;import org.springframework.transaction.annotation.EnableTransactionManagement;import org.springframework.transaction.annotation.Transactional;import redis.clients.jedis.Jedis;import redis.clients.jedis.JedisCluster;import redis.clients.jedis.JedisPool;import redis.clients.jedis.JedisPoolConfig;import javax.swing.text.html.Option;import java.util.*;import java.util.stream.Collectors;@SpringBootApplication@Slf4j@EnableJpaRepositories@EnableTransactionManagementpublic class CoffeApplication implements ApplicationRunner &#123; @Autowired CoffeeRepository coffeeRepository; @Autowired CoffeeService coffeeService; @Autowired CoffeeOrderService coffeeOrderService; @Autowired JedisPool jedisPool; @Autowired JedisPoolConfig jedisPoolConfig; public static void main(String[] args) &#123; SpringApplication.run(CoffeApplication.class, args); &#125; @Override @Transactional public void run(ApplicationArguments args) throws Exception &#123; log.info(&quot;All Coffee: &#123;&#125;&quot;, coffeeRepository.findAll()); Optional&lt;Coffee&gt; mocha = coffeeService.findOneCoffee(&quot;mocha&quot;); Optional&lt;Coffee&gt; latte = coffeeService.findOneCoffee(&quot;latte&quot;); CoffeeOrder order = coffeeOrderService.createOrder(&quot;Li Lei&quot;, mocha.get(), latte.get()); log.info(&quot;Update INIT to PAID: &#123;&#125;&quot;, coffeeOrderService.updateState(order, OrderState.PAID)); log.info(&quot;Update PAID to INIT: &#123;&#125;&quot;, coffeeOrderService.updateState(order, OrderState.INIT));// testRedis(); testJedis(); &#125; @Bean @ConfigurationProperties(&quot;redis&quot;) // 解析配置文件中 redis 开头的选项。 public JedisPoolConfig jedisPoolConfig()&#123; return new JedisPoolConfig(); &#125; @Bean(destroyMethod = &quot;close&quot;) // Bean 关闭时调用他的close方法。 public JedisPool jedisPool(@Value(&quot;$&#123;redis.host&#125;&quot;) String host)&#123; return new JedisPool(jedisPoolConfig(), host); &#125; public void testRedis()&#123; try (Jedis jedis = jedisPool.getResource()) &#123; jedis.set(&quot;key1&quot;, &quot;1233&quot;); String value = jedis.get(&quot;key1&quot;); log.info(&quot;Menu: &#123;&#125;&quot;, value); &#125; &#125; public void testJedis()&#123; log.info(jedisPoolConfig.toString()); try (Jedis jedis = jedisPool.getResource()) &#123; coffeeService.findAllCoffee().forEach(c -&gt; &#123; jedis.hset(&quot;springbucks-menu&quot;, c.getName(), Long.toString(c.getPrice().getAmountMinorLong())); &#125;); Map&lt;String, String&gt; menu = jedis.hgetAll(&quot;springbucks-menu&quot;); log.info(&quot;Menu: &#123;&#125;&quot;, menu); &#125; &#125;&#125; Redis 的两种部署方式 哨兵模式 集群模式 哨兵模式Redis Sentinel 是 Redis 的一种高可用方案。 监控、通知、自动故障转移、服务发现 哨兵JedisSentinePool 集群Redis Cluster 数据自动分片（分成16384个Hash Slot） 在部分节点失效时有一定的可用性 JedisCluster Jedis 只从 Master 读数据，如果想要自动读写分离，可以定制 5、Spring Boot 缓存抽象Spring boot 为不同的缓存提供一层抽象 为java方法增加缓存，缓存执行结果 支持 Redis、ConcurrentMap、EhCache、Caffeine、JCache（JSR-107）等缓存抽象 接口 org.springframework.cache.Cache org.springframework.cache.CacheManager Spring boot 默认缓存（本地缓存） - 代码仓库Spring boot 自带的默认缓存，也可以集成 Redis、EhCache等其他缓存。 EnableCaching 开启缓存支持 @Cacheable Spring会在其被调用后将其返回值缓存起来，以保证下次利用同样的参数来执行该方法时可以直接从缓存中获取结果，而不需要再次执行该方法。Spring在缓存方法的返回值时是以键值对进行缓存的，值就是方法的返回结果。 @CacheEvict @CachEvict主要针对方法配置，能够根据一定的条件对特定的缓存进行清空。该注解有两个特别的属性： allEntries 是否清空所有缓存内容，缺省为 false，如果指定为 true，则方法调用后将立即清空所有缓存。注意不能跟key参数同时使用。 beforeInvocation 是否在方法执行前就清空，缺省为 false，如果指定为 true，则在方法还没有执行的时候就清空缓存，缺省情况下，如果方法执行抛出异常，则不会清空缓存。 @CachePut @CachePut每次都将执行方法并将返回值K-V放入缓存，如果该K存在则进行更新。 @Caching 该注解是个组合注解。有时候我们需要在一个方法上同时使用多个相同注解但是java是不支持一个注解在同一个方法上多次使用。这时就可以使用该注解进行组合。 @CacheConfig 作用于缓存接口上，来对该接口下的一些重复配置（缓存名称、key生成器、缓存管理器、缓存处理器）进行归纳处理。其他属性可参考Cacheable。 流程 开启缓存支持（@EnableCaching(proxyTargetClass = true) // 开启缓存支持） 配置缓存（@CacheConfig(cacheNames = “coffee”) // 该缓存的名字为coffee） 指定缓存的具体方法 配置缓存和为方法添加缓存注解 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package com.jq.coffe.service;import com.jq.coffe.model.Coffee;import com.jq.coffe.repository.CoffeeRepository;import lombok.extern.slf4j.Slf4j;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.cache.annotation.CacheConfig;import org.springframework.cache.annotation.CacheEvict;import org.springframework.cache.annotation.Cacheable;import org.springframework.data.domain.Example;import org.springframework.data.domain.ExampleMatcher;import org.springframework.stereotype.Service;import java.util.List;import java.util.Optional;import static org.springframework.data.domain.ExampleMatcher.GenericPropertyMatchers.exact;@Service@Slf4j@CacheConfig(cacheNames = &quot;coffee&quot;) // 该缓存的名字为coffee。（类级别共享的缓存配置）public class CoffeeService &#123; @Autowired CoffeeRepository coffeeRepository; public Optional&lt;Coffee&gt; findOneCoffee(String name)&#123; Example&lt;Coffee&gt; example = new Example&lt;Coffee&gt;() &#123; @Override public Coffee getProbe() &#123; return Coffee.builder().name(name).build(); &#125; @Override public ExampleMatcher getMatcher() &#123; ExampleMatcher exampleMatcher = ExampleMatcher.matching().withMatcher(&quot;name&quot;, exact().ignoreCase()); return exampleMatcher; &#125; &#125;; Optional&lt;Coffee&gt; coffee = coffeeRepository.findOne(example); log.info(&quot;Coffee Found: &#123;&#125;&quot;, coffee); return coffee; &#125; @Cacheable // 为该方法添加缓存 public List&lt;Coffee&gt; findAllCoffee() &#123; return coffeeRepository.findAll(); &#125; @CacheEvict // 清除缓存 public void reloadCoffee()&#123; &#125;&#125; 开启缓存支持 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687package com.jq.coffe;import com.jq.coffe.model.Coffee;import com.jq.coffe.model.CoffeeOrder;import com.jq.coffe.model.OrderState;import com.jq.coffe.repository.CoffeeOrderRepository;import com.jq.coffe.repository.CoffeeRepository;import com.jq.coffe.service.CoffeeOrderService;import com.jq.coffe.service.CoffeeService;import lombok.extern.slf4j.Slf4j;import org.joda.money.CurrencyUnit;import org.joda.money.Money;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Value;import org.springframework.boot.ApplicationArguments;import org.springframework.boot.ApplicationRunner;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.cache.annotation.EnableCaching;import org.springframework.context.annotation.Bean;import org.springframework.data.domain.Sort;import org.springframework.data.jpa.repository.config.EnableJpaRepositories;import org.springframework.transaction.annotation.EnableTransactionManagement;import org.springframework.transaction.annotation.Transactional;import redis.clients.jedis.Jedis;import redis.clients.jedis.JedisCluster;import redis.clients.jedis.JedisPool;import redis.clients.jedis.JedisPoolConfig;import javax.swing.text.html.Option;import java.util.*;import java.util.stream.Collectors;@SpringBootApplication@Slf4j@EnableJpaRepositories@EnableTransactionManagement@EnableCaching(proxyTargetClass = true) // 开启缓存支持public class CoffeApplication implements ApplicationRunner &#123; @Autowired CoffeeRepository coffeeRepository; @Autowired CoffeeOrderRepository orderRepository; @Autowired CoffeeService coffeeService; @Autowired CoffeeOrderService coffeeOrderService; public static void main(String[] args) &#123; SpringApplication.run(CoffeApplication.class, args); &#125; @Override @Transactional public void run(ApplicationArguments args) throws Exception &#123; log.info(&quot;All Coffee: &#123;&#125;&quot;, coffeeRepository.findAll()); Optional&lt;Coffee&gt; mocha = coffeeService.findOneCoffee(&quot;mocha&quot;); Optional&lt;Coffee&gt; latte = coffeeService.findOneCoffee(&quot;latte&quot;); CoffeeOrder order = coffeeOrderService.createOrder(&quot;Li Lei&quot;, mocha.get(), latte.get()); log.info(&quot;Update INIT to PAID: &#123;&#125;&quot;, coffeeOrderService.updateState(order, OrderState.PAID)); log.info(&quot;Update PAID to INIT: &#123;&#125;&quot;, coffeeOrderService.updateState(order, OrderState.INIT)); testSpringCache(); &#125; public void testSpringCache()&#123; log.info(&quot;Count: &#123;&#125;&quot;, coffeeService.findAllCoffee().size()); for (int i = 0; i &lt; 10; i++) &#123; log.info(&quot;Reading from cache.&quot;); coffeeService.findAllCoffee(); &#125; coffeeService.reloadCoffee(); log.info(&quot;Reading after refresh.&quot;); coffeeService.findAllCoffee().forEach(c -&gt; log.info(&quot;Coffee &#123;&#125;&quot;, c.getName())); &#125;&#125; 集成 redis 缓存依赖 12345678&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-cache&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt; 配置缓存 123456789101112131415spring.jpa.hibernate.ddl-auto=nonespring.jpa.properties.hibernate.show_sql=truespring.jpa.properties.hibernate.format_sql=truemanagement.endpoints.web.exposure.include=*#使用redis缓存spring.cache.type=redis#配置默认缓存的，启动时会把其中指定的缓存创建出来，运行时的缓存不能超出我这指定的范围（有同学反馈这个与底层的缓存实现有关，因此补充一下，比如Simple的不能超过，但Redis的可以），不配的话就看代码里用到哪些动态创建。@CacheConfig用来配置类级别共享的缓存配置，配置不在@CacheConfig里，就需要加在@Cacheable里。spring.cache.cache-names=coffee#在缓存中的存活时间spring.cache.redis.time-to-live=5000spring.cache.redis.cache-null-values=falsespring.redis.host=localhost 配置缓存和为方法添加缓存注解 1234567891011121314151617181920212223242526@Slf4j@Service@CacheConfig(cacheNames = &quot;coffee&quot;)public class CoffeeService &#123; @Autowired private CoffeeRepository coffeeRepository; @Cacheable public List&lt;Coffee&gt; findAllCoffee() &#123; return coffeeRepository.findAll(); &#125; @CacheEvict public void reloadCoffee() &#123; &#125; public Optional&lt;Coffee&gt; findOneCoffee(String name) &#123; ExampleMatcher matcher = ExampleMatcher.matching() .withMatcher(&quot;name&quot;, exact().ignoreCase()); Optional&lt;Coffee&gt; coffee = coffeeRepository.findOne( Example.of(Coffee.builder().name(name).build(), matcher)); log.info(&quot;Coffee Found: &#123;&#125;&quot;, coffee); return coffee; &#125;&#125; 调用代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106package com.jq.coffe;import com.jq.coffe.model.Coffee;import com.jq.coffe.model.CoffeeOrder;import com.jq.coffe.model.OrderState;import com.jq.coffe.repository.CoffeeOrderRepository;import com.jq.coffe.repository.CoffeeRepository;import com.jq.coffe.service.CoffeeOrderService;import com.jq.coffe.service.CoffeeService;import lombok.extern.slf4j.Slf4j;import org.joda.money.CurrencyUnit;import org.joda.money.Money;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Value;import org.springframework.boot.ApplicationArguments;import org.springframework.boot.ApplicationRunner;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.cache.annotation.EnableCaching;import org.springframework.context.annotation.Bean;import org.springframework.data.domain.Sort;import org.springframework.data.jpa.repository.config.EnableJpaRepositories;import org.springframework.transaction.annotation.EnableTransactionManagement;import org.springframework.transaction.annotation.Transactional;import redis.clients.jedis.Jedis;import redis.clients.jedis.JedisCluster;import redis.clients.jedis.JedisPool;import redis.clients.jedis.JedisPoolConfig;import javax.swing.text.html.Option;import java.util.*;import java.util.stream.Collectors;@SpringBootApplication@Slf4j@EnableJpaRepositories@EnableTransactionManagement@EnableCaching(proxyTargetClass = true) // 开启缓存支持public class CoffeApplication implements ApplicationRunner &#123; @Autowired CoffeeRepository coffeeRepository; @Autowired CoffeeService coffeeService; @Autowired CoffeeOrderService coffeeOrderService; @Autowired JedisPool jedisPool; @Autowired JedisPoolConfig jedisPoolConfig; public static void main(String[] args) &#123; SpringApplication.run(CoffeApplication.class, args); &#125; @Override @Transactional public void run(ApplicationArguments args) throws Exception &#123; log.info(&quot;All Coffee: &#123;&#125;&quot;, coffeeRepository.findAll()); Optional&lt;Coffee&gt; mocha = coffeeService.findOneCoffee(&quot;mocha&quot;); Optional&lt;Coffee&gt; latte = coffeeService.findOneCoffee(&quot;latte&quot;); CoffeeOrder order = coffeeOrderService.createOrder(&quot;Li Lei&quot;, mocha.get(), latte.get()); log.info(&quot;Update INIT to PAID: &#123;&#125;&quot;, coffeeOrderService.updateState(order, OrderState.PAID)); log.info(&quot;Update PAID to INIT: &#123;&#125;&quot;, coffeeOrderService.updateState(order, OrderState.INIT)); testRedisCache(); &#125; public void testRedisCache() throws InterruptedException &#123; log.info(&quot;Count: &#123;&#125;&quot;, coffeeService.findAllCoffee().size()); for (int i = 0; i &lt; 5; i++) &#123; log.info(&quot;Reading from cache.&quot;); coffeeService.findAllCoffee(); &#125; Thread.sleep(5000); log.info(&quot;Reading after refresh.&quot;); coffeeService.findAllCoffee().forEach(c -&gt; log.info(&quot;Coffee &#123;&#125;&quot;, c.getName())); &#125; public void testSpringCache()&#123; log.info(&quot;Count: &#123;&#125;&quot;, coffeeService.findAllCoffee().size()); for (int i = 0; i &lt; 10; i++) &#123; log.info(&quot;Reading from cache.&quot;); coffeeService.findAllCoffee(); &#125; coffeeService.reloadCoffee(); log.info(&quot;Reading after refresh.&quot;); coffeeService.findAllCoffee().forEach(c -&gt; log.info(&quot;Coffee &#123;&#125;&quot;, c.getName())); &#125; @Bean @ConfigurationProperties(&quot;redis&quot;) // 解析配置文件中 redis 开头的选项。 public JedisPoolConfig jedisPoolConfig()&#123; return new JedisPoolConfig(); &#125; @Bean(destroyMethod = &quot;close&quot;) // Bean 关闭时调用他的close方法。 public JedisPool jedisPool(@Value(&quot;$&#123;spring.redis.host&#125;&quot;) String host)&#123; return new JedisPool(jedisPoolConfig(), host); &#125; 6、Redis 在 Spring 中的其他用法与 Redis 建立连接配置连接工厂 LettuceConnecetionFactory 与 JedisConnectionFactory RedsiStandaloneConfiguration RedsiaSentinelConfiguration RedsiClusterConfiguraion 读写分离Lettuce 内置支持读写分离 只读主、只读从 优先读主、优先读从 LettuceClientConfiguration LettucePollingClientConfiguration LettuceClientConfigurationBuildercustonizer RedisTemplate对Redis 的操作一定设置过期时间！！！对Redis 的操作一定设置过期时间！！！对Redis 的操作一定设置过期时间！！！ RedisTemplate&lt;K, V&gt; opsForXxx() StringRedisTemplate 配置 RedisTemplate 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990package com.jq.coffe;import com.jq.coffe.model.Coffee;import com.jq.coffe.model.CoffeeOrder;import com.jq.coffe.model.OrderState;import com.jq.coffe.repository.CoffeeOrderRepository;import com.jq.coffe.repository.CoffeeRepository;import com.jq.coffe.service.CoffeeOrderService;import com.jq.coffe.service.CoffeeService;import lombok.extern.slf4j.Slf4j;import org.joda.money.CurrencyUnit;import org.joda.money.Money;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Value;import org.springframework.boot.ApplicationArguments;import org.springframework.boot.ApplicationRunner;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.cache.annotation.EnableCaching;import org.springframework.context.annotation.Bean;import org.springframework.data.domain.Sort;import org.springframework.data.jpa.repository.config.EnableJpaRepositories;import org.springframework.data.redis.connection.RedisConnectionFactory;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.transaction.annotation.EnableTransactionManagement;import org.springframework.transaction.annotation.Transactional;import redis.clients.jedis.Jedis;import redis.clients.jedis.JedisCluster;import redis.clients.jedis.JedisPool;import redis.clients.jedis.JedisPoolConfig;import javax.swing.text.html.Option;import java.util.*;import java.util.stream.Collectors;@SpringBootApplication@Slf4j@EnableJpaRepositories@EnableTransactionManagementpublic class CoffeApplication implements ApplicationRunner &#123; @Autowired CoffeeRepository coffeeRepository; @Autowired CoffeeService coffeeService; @Autowired CoffeeOrderService coffeeOrderService; public static void main(String[] args) &#123; SpringApplication.run(CoffeApplication.class, args); &#125; @Override @Transactional public void run(ApplicationArguments args) throws Exception &#123; log.info(&quot;All Coffee: &#123;&#125;&quot;, coffeeRepository.findAll()); Optional&lt;Coffee&gt; mocha = coffeeService.findOneCoffee(&quot;mocha&quot;); Optional&lt;Coffee&gt; latte = coffeeService.findOneCoffee(&quot;latte&quot;); CoffeeOrder order = coffeeOrderService.createOrder(&quot;Li Lei&quot;, mocha.get(), latte.get()); log.info(&quot;Update INIT to PAID: &#123;&#125;&quot;, coffeeOrderService.updateState(order, OrderState.PAID)); log.info(&quot;Update PAID to INIT: &#123;&#125;&quot;, coffeeOrderService.updateState(order, OrderState.INIT)); testRedisTemplate(); &#125; /* * 配置 RedisTemplate * */ @Bean public RedisTemplate&lt;String, Coffee&gt; redisTemplate(RedisConnectionFactory redisConnectionFactory)&#123; RedisTemplate&lt;String, Coffee&gt; template = new RedisTemplate&lt;&gt;(); template.setConnectionFactory(redisConnectionFactory); return template; &#125; public void testRedisTemplate()&#123; Optional&lt;Coffee&gt; c = coffeeService.findOneCoffee(&quot;mocha&quot;); log.info(&quot;Coffee &#123;&#125;&quot;, c); for (int i = 0; i &lt; 5; i++) &#123; coffeeService.findOneCoffee(&quot;mocha&quot;); &#125; log.info(&quot;Value from Redis: &#123;&#125;&quot;, c); &#125;&#125; 具体的操作 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package com.jq.coffe.service;import com.jq.coffe.model.Coffee;import com.jq.coffe.repository.CoffeeRepository;import lombok.extern.slf4j.Slf4j;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.cache.annotation.CacheConfig;import org.springframework.cache.annotation.CacheEvict;import org.springframework.cache.annotation.Cacheable;import org.springframework.data.domain.Example;import org.springframework.data.domain.ExampleMatcher;import org.springframework.data.redis.core.HashOperations;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.stereotype.Service;import java.util.List;import java.util.Optional;import java.util.concurrent.TimeUnit;import static org.springframework.data.domain.ExampleMatcher.GenericPropertyMatchers.exact;@Service@Slf4jpublic class CoffeeService &#123; private static final String CACHE = &quot;springbucks-coffee&quot;; @Autowired CoffeeRepository coffeeRepository; @Autowired RedisTemplate&lt;String, Coffee&gt; redisTemplate; public Optional&lt;Coffee&gt; findOneCoffee(String name) &#123; // 查询缓存 // HashOperations&lt;String, String, Coffee&gt; 用于存储 Map 类型，第一个 String 是Reids中key的一部分； // 第二个String是map中的key，Coffee是map的value；一个map是redis中的value HashOperations&lt;String, String, Coffee&gt; hashOperations = redisTemplate.opsForHash(); if (redisTemplate.hasKey(CACHE) &amp;&amp; hashOperations.hasKey(CACHE, name))&#123; log.info(&quot;Get coffee &#123;&#125; from Redsi.&quot;, name); return Optional.of(hashOperations.get(CACHE, name)); &#125; hashOperations.get(CACHE, name); // 写入数据库 Example&lt;Coffee&gt; example = new Example&lt;Coffee&gt;() &#123; @Override public Coffee getProbe() &#123; return Coffee.builder().name(name).build(); &#125; @Override public ExampleMatcher getMatcher() &#123; ExampleMatcher exampleMatcher = ExampleMatcher.matching().withMatcher(&quot;name&quot;, exact().ignoreCase()); return exampleMatcher; &#125; &#125;; Optional&lt;Coffee&gt; coffee = coffeeRepository.findOne(example); log.info(&quot;Coffee Found: &#123;&#125;&quot;, coffee); // 写入缓存 if (coffee.isPresent())&#123; log.info(&quot;Put coffee &#123;&#125; to Redis.&quot;, name); hashOperations.put(CACHE, name, coffee.get()); redisTemplate.expire(CACHE, 1, TimeUnit.MINUTES); &#125; return coffee; &#125;&#125; Redis Repository实体注解 @RedisHash （类似Entity） @Id @Indexed （二级索引） 出了不同类型（JPA、Mongn、Redis）数据源的 Repository如何区分这些 Repsitory 根据实体的注解 根据继承的接口类型 扫描不同的包 Redis Repository 的简单实例 配置 redis 开启 Redis Repositories 的支持 类中的特殊类型自定义 RedisCustomConversions 实现具体操作 配置 Redis 123456# redisspring.redis.host=124.220.171.2spring.redis.password=123456spring.redis.port=6379spring.redis.maxTotal=5spring.redis.maxIdle=5 ReisHash 12345678910111213141516171819202122232425package com.jq.coffe.model;import lombok.AllArgsConstructor;import lombok.Builder;import lombok.Data;import lombok.NoArgsConstructor;import org.joda.money.Money;import org.springframework.data.redis.core.RedisHash;import org.springframework.data.redis.core.index.Indexed;import javax.persistence.Id;@RedisHash(value = &quot;springbucks-coffee&quot;, timeToLive = 60)@Data@AllArgsConstructor@NoArgsConstructor@Builderpublic class CoffeeCache &#123; @Id private Long id; @Indexed private String name; private Money price;&#125; 实现 CrudRepository 接口 12345678910package com.jq.coffe.repository;import com.jq.coffe.model.CoffeeCache;import org.springframework.data.repository.CrudRepository;import java.util.Optional;public interface CoffeeCacheRepository extends CrudRepository&lt;CoffeeCache, Long&gt; &#123; Optional&lt;CoffeeCache&gt; findOneByName(String name);&#125; 实现特殊类型（Money）写入到 Reids 的转化 1234567891011121314151617package com.jq.coffe.converter;import org.joda.money.Money;import org.springframework.core.convert.converter.Converter;import org.springframework.data.convert.WritingConverter;import java.nio.charset.StandardCharsets;// 写入到 Redis 中@WritingConverterpublic class MoneyToBytesConverter implements Converter&lt;Money, byte[]&gt; &#123; @Override public byte[] convert(Money source) &#123; String value = Long.toString(source.getAmountMinorLong()); return value.getBytes(StandardCharsets.UTF_8); &#125;&#125; 实现特殊类型（Money）从 Reids 中读出转化为 Money 123456789101112131415161718package com.jq.coffe.converter;import org.joda.money.CurrencyUnit;import org.joda.money.Money;import org.springframework.core.convert.converter.Converter;import org.springframework.data.convert.ReadingConverter;import java.nio.charset.StandardCharsets;@ReadingConverterpublic class BytesToMoneyConverter implements Converter&lt;byte[], Money&gt; &#123; @Override public Money convert(byte[] source) &#123; String value = new String(source, StandardCharsets.UTF_8); return Money.ofMinor(CurrencyUnit.of(&quot;CNY&quot;), Long.parseLong(value)); &#125;&#125; 将自定义的 Converter 注入到容器中 1234@Beanpublic RedisCustomConversions redisCustomConversions()&#123; return new RedisCustomConversions(Arrays.asList(new MoneyToBytesConverter(), new BytesToMoneyConverter()));&#125; 实现 Service 层具体的操作 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596package com.jq.coffe.service;import com.jq.coffe.model.Coffee;import com.jq.coffe.model.CoffeeCache;import com.jq.coffe.repository.CoffeeCacheRepository;import com.jq.coffe.repository.CoffeeRepository;import lombok.extern.slf4j.Slf4j;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.cache.annotation.CacheConfig;import org.springframework.cache.annotation.CacheEvict;import org.springframework.cache.annotation.Cacheable;import org.springframework.data.domain.Example;import org.springframework.data.domain.ExampleMatcher;import org.springframework.data.redis.core.HashOperations;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.stereotype.Service;import java.util.List;import java.util.Optional;import java.util.concurrent.TimeUnit;import static org.springframework.data.domain.ExampleMatcher.GenericPropertyMatchers.exact;@Service@Slf4jpublic class CoffeeService &#123; private static final String CACHE = &quot;springbucks-coffee&quot;; @Autowired CoffeeRepository coffeeRepository; @Autowired RedisTemplate&lt;String, Coffee&gt; redisTemplate; @Autowired CoffeeCacheRepository coffeeCacheRepository; public Optional&lt;Coffee&gt; findOneCoffee(String name) &#123; // 查询缓存 // HashOperations&lt;String, String, Coffee&gt; 用于存储 Map 类型，第一个 String 是Reids中key的一部分； // 第二个String是map中的key，Coffee是map的value；一个map是redis中的value HashOperations&lt;String, String, Coffee&gt; hashOperations = redisTemplate.opsForHash(); if (redisTemplate.hasKey(CACHE) &amp;&amp; hashOperations.hasKey(CACHE, name))&#123; log.info(&quot;Get coffee &#123;&#125; from Redsi.&quot;, name); return Optional.of(hashOperations.get(CACHE, name)); &#125; hashOperations.get(CACHE, name); // 写入数据库 Example&lt;Coffee&gt; example = new Example&lt;Coffee&gt;() &#123; @Override public Coffee getProbe() &#123; return Coffee.builder().name(name).build(); &#125; @Override public ExampleMatcher getMatcher() &#123; ExampleMatcher exampleMatcher = ExampleMatcher.matching().withMatcher(&quot;name&quot;, exact().ignoreCase()); return exampleMatcher; &#125; &#125;; Optional&lt;Coffee&gt; coffee = coffeeRepository.findOne(example); log.info(&quot;Coffee Found: &#123;&#125;&quot;, coffee); // 写入缓存 if (coffee.isPresent())&#123; log.info(&quot;Put coffee &#123;&#125; to Redis.&quot;, name); hashOperations.put(CACHE, name, coffee.get()); redisTemplate.expire(CACHE, 1, TimeUnit.MINUTES); &#125; return coffee; &#125; public Optional&lt;Coffee&gt; findSimpleCoffeeFromCache(String name)&#123; Optional&lt;CoffeeCache&gt; cached = coffeeCacheRepository.findOneByName(name); if (cached.isPresent())&#123; CoffeeCache coffeeCache = cached.get(); Coffee coffee = Coffee.builder() .name(coffeeCache.getName()) .price(coffeeCache.getPrice()).build(); log.info(&quot;Coffee &#123;&#125; found in cache.&quot;, coffeeCache); return Optional.of(coffee); &#125;else &#123; Optional&lt;Coffee&gt; raw = findOneCoffee(name); raw.ifPresent(c -&gt; &#123; CoffeeCache coffeeCache = CoffeeCache.builder() .id(c.getId()) .name(c.getName()) .price(c.getPrice()).build(); log.info(&quot;Save Coffee &#123;&#125; to cache.&quot;, coffeeCache); coffeeCacheRepository.save(coffeeCache); &#125;); return raw; &#125; &#125;&#125; 测试代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788package com.jq.coffe;import com.jq.coffe.converter.BytesToMoneyConverter;import com.jq.coffe.converter.MoneyToBytesConverter;import com.jq.coffe.model.Coffee;import com.jq.coffe.model.CoffeeOrder;import com.jq.coffe.model.OrderState;import com.jq.coffe.repository.CoffeeOrderRepository;import com.jq.coffe.repository.CoffeeRepository;import com.jq.coffe.service.CoffeeOrderService;import com.jq.coffe.service.CoffeeService;import lombok.extern.slf4j.Slf4j;import org.joda.money.CurrencyUnit;import org.joda.money.Money;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Value;import org.springframework.boot.ApplicationArguments;import org.springframework.boot.ApplicationRunner;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.cache.annotation.EnableCaching;import org.springframework.context.annotation.Bean;import org.springframework.data.domain.Sort;import org.springframework.data.jpa.repository.config.EnableJpaRepositories;import org.springframework.data.redis.connection.RedisConnectionFactory;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.data.redis.core.convert.RedisCustomConversions;import org.springframework.data.redis.repository.configuration.EnableRedisRepositories;import org.springframework.transaction.annotation.EnableTransactionManagement;import org.springframework.transaction.annotation.Transactional;import redis.clients.jedis.Jedis;import redis.clients.jedis.JedisCluster;import redis.clients.jedis.JedisPool;import redis.clients.jedis.JedisPoolConfig;import javax.swing.text.html.Option;import java.util.*;import java.util.stream.Collectors;@SpringBootApplication@Slf4j@EnableTransactionManagement@EnableRedisRepositories // 开启Redis Repositories 的支持public class CoffeApplication implements ApplicationRunner &#123; @Autowired CoffeeRepository coffeeRepository; @Autowired CoffeeService coffeeService; @Autowired CoffeeOrderService coffeeOrderService; public static void main(String[] args) &#123; SpringApplication.run(CoffeApplication.class, args); &#125; @Override @Transactional public void run(ApplicationArguments args) throws Exception &#123; log.info(&quot;All Coffee: &#123;&#125;&quot;, coffeeRepository.findAll()); Optional&lt;Coffee&gt; mocha = coffeeService.findOneCoffee(&quot;mocha&quot;); Optional&lt;Coffee&gt; latte = coffeeService.findOneCoffee(&quot;latte&quot;); CoffeeOrder order = coffeeOrderService.createOrder(&quot;Li Lei&quot;, mocha.get(), latte.get()); log.info(&quot;Update INIT to PAID: &#123;&#125;&quot;, coffeeOrderService.updateState(order, OrderState.PAID)); log.info(&quot;Update PAID to INIT: &#123;&#125;&quot;, coffeeOrderService.updateState(order, OrderState.INIT)); testRedisRepository(); &#125; // 将自定义的 Converter 注入到容器中 @Bean public RedisCustomConversions redisCustomConversions()&#123; return new RedisCustomConversions(Arrays.asList(new MoneyToBytesConverter(), new BytesToMoneyConverter())); &#125; public void testRedisRepository()&#123; Optional&lt;Coffee&gt; c = coffeeService.findSimpleCoffeeFromCache(&quot;mocha&quot;); log.info(&quot;Coffee &#123;&#125;&quot;, c); for (int i = 0; i &lt; 5; i++) &#123; c = coffeeService.findSimpleCoffeeFromCache(&quot;mocha&quot;); &#125; log.info(&quot;Value from Redis: &#123;&#125;&quot;, c); &#125;&#125; 第五章 数据访问进阶1、Project Reactor 介绍Reactor Programming（响应式编程）: c = a + b; 当结果计算出来之后，a和b变化，c不在受影响，Reactor 编程可以将变化传给c。Reactor Programming（响应式编程） 是一种基于数据流（data stream）和变化传递（propagation of change）的声明式（declarative）的编程范式。具体理解强烈推荐 - 什么是响应式编程。 必读 - Reactor 3 快速上手,该专栏其他文章也建议阅读。 一些核心概念Publisher / Subscriber Nothing Happens Until You subscribe() Flux [ 0..N ] - onNext()、onComplete()、onError() Mono [ 0..1 ] - onNext()、onComplete()、onError() Backpressure （“回压”机制） Subscription onRequest(n) 指定每次订阅n个序列 onCancel() 取消订阅的过程 onDispose() 终止订阅的过程 线程调度 Schedulers immediate() 当前在哪个线程上 single() 独占一个线程 newSingle() elastic() elastic 的一个线程池，里面线程空闲60s就会被回收 parallel() 与CPU核数相对应的线程池，线程不会被回收 newParallel() 错误处理 onError 类似 try catch onErrorReturn 出现异常返回特定值 onErrorResume 出现异常使用特定的Lambda的处理异常 doOnError doFinally 正常执行完还是遇到异常，都会执行 doFinally 中的方法。 依赖 1234&lt;dependency&gt; &lt;groupId&gt;io.projectreactor&lt;/groupId&gt; &lt;artifactId&gt;reactor-core&lt;/artifactId&gt; &lt;/dependency&gt; Demo 1234567891011121314151617181920212223242526272829/** 在调用 subscribe 方法之前不会有任何实际的动作* */ @Override public void run(ApplicationArguments args) throws Exception &#123; // 创建包含从 0 起始的 6 个数量的 Integer 对象的序列（数据流），其实就是将其打包起来，或者理解成声明，在 执行 subscribe 方法前什么都不会发生。 Flux.range(0, 6) .publishOn(Schedulers.elastic()) // 发布到 Schedulers.elastic() 上 .doOnRequest(n -&gt; log.info(&quot;Request &#123;&#125; number&quot;, n)) .doOnComplete(() -&gt; log.info(&quot;Publisher Complete&quot;)) // 当整个序列完成时执行 .map(i -&gt; &#123; log.info(&quot;Publish &#123;&#125;, &#123;&#125;&quot;, Thread.currentThread(), i); return 10 / (i - 3);// return i; &#125;)// .onErrorReturn(-1) // 异常，发布-1，并返回 .onErrorResume(e -&gt; &#123; // 异常处理逻辑 log.error(&quot;Exception &#123;&#125;&quot;, e.toString()); return Mono.just(-1); &#125;) .doOnComplete(() -&gt; log.info(&quot;Publish Complete 2&quot;)) .subscribeOn(Schedulers.single()) // 指定从 Schedulers.single() 订阅 .subscribe(i -&gt; log.info(&quot;Subscribe &#123;&#125;: &#123;&#125;&quot;, Thread.currentThread(), i), // 订阅 e -&gt; log.error(&quot;error &#123;&#125;&quot;, e.toString()), () -&gt; log.info(&quot;Subscribe Complete&quot;), s -&gt; s.request(4) // 取出 4 个，“回压”机制 ); Thread.sleep(2000); &#125; 2、Reactor 方式访问 RedisSpring Data Redis 中的客户端 Lettuce 支持 Reactive 方式，Jedis不支持。 Spring Data Redis 中对 Reactive 的支持 ReactiveRedisConnection ReactiveRedisConnectionFactory ReactiveRedistemplate opsForXxx() 使用 ReactiveRedisConnection 建立连接，这个连接是通过 ReactiveRedisConnectionFactory 构造的，与 Redistemplate 类似提供了 ReactiveRedistemplate。 一个简单的通过 Reactor 能力访问 Redis 的例子创建表 12345678910drop table t_coffee if exists;create table t_coffee ( id bigint auto_increment, create_time timestamp, update_time timestamp, name varchar(255), price bigint, primary key (id)); 插入数据 12345insert into t_coffee (name, price, create_time, update_time) values (&#x27;espresso&#x27;, 2000, now(), now());insert into t_coffee (name, price, create_time, update_time) values (&#x27;latte&#x27;, 2500, now(), now());insert into t_coffee (name, price, create_time, update_time) values (&#x27;capuccino&#x27;, 2500, now(), now());insert into t_coffee (name, price, create_time, update_time) values (&#x27;mocha&#x27;, 3000, now(), now());insert into t_coffee (name, price, create_time, update_time) values (&#x27;macchiato&#x27;, 3000, now(), now()); 构造对应的类 1234567891011121314151617package com.example.reactor_redis;import lombok.AllArgsConstructor;import lombok.Builder;import lombok.Data;import lombok.NoArgsConstructor;@Data@AllArgsConstructor@NoArgsConstructor@Builderpublic class Coffee &#123; private Long id; private String name; private Long price;&#125; 主要代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879package com.example.reactor_redis;import lombok.extern.slf4j.Slf4j;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.ApplicationArguments;import org.springframework.boot.ApplicationRunner;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.context.annotation.Bean;import org.springframework.data.redis.connection.ReactiveListCommands;import org.springframework.data.redis.connection.ReactiveRedisConnectionFactory;import org.springframework.data.redis.core.ReactiveHashOperations;import org.springframework.data.redis.core.ReactiveStringRedisTemplate;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.transaction.annotation.EnableTransactionManagement;import org.springframework.transaction.annotation.Transactional;import reactor.core.publisher.Flux;import reactor.core.publisher.Mono;import reactor.core.scheduler.Schedulers;import java.time.Duration;import java.util.List;import java.util.concurrent.CountDownLatch;@SpringBootApplication@Slf4jpublic class DemoApplication implements ApplicationRunner &#123; private static final String KEY = &quot;COFFEE_MENU&quot;; public static void main(String[] args) &#123; SpringApplication.run(DemoApplication.class, args); &#125; @Autowired JdbcTemplate jdbcTemplate; @Autowired ReactiveStringRedisTemplate redisTemplate; /* * 使用 ReactiveRedisConnectionFactory 配置连接 * */ @Bean ReactiveStringRedisTemplate reactiveStringRedisTemplate (ReactiveRedisConnectionFactory factory)&#123; return new ReactiveStringRedisTemplate(factory); &#125; @Override public void run(ApplicationArguments args) throws Exception &#123; ReactiveHashOperations&lt;String, String, String&gt; hasOps = redisTemplate.opsForHash(); CountDownLatch cdl = new CountDownLatch(1); List&lt;Coffee&gt; list = jdbcTemplate.query(&quot;select * from t_coffee&quot;, (rs, i) -&gt; Coffee.builder() .id(rs.getLong(&quot;id&quot;)) .name(rs.getString(&quot;name&quot;)) .price(rs.getLong(&quot;price&quot;)) .build()); Flux.fromIterable(list) .publishOn(Schedulers.single()) // 调用一个单线程 .doOnComplete(() -&gt; log.info(&quot;list ok&quot;)) .flatMap(c -&gt; &#123; // flatMap将元素映射为流。map操作可以将数据元素进行转换/映射，得到一个新元素。 log.info(&quot;try to put &#123;&#125;, &#123;&#125;&quot;, c.getName(), c.getPrice()); return hasOps.put(KEY, c.getName(), c.getPrice().toString()); &#125;) .doOnComplete(() -&gt; log.info(&quot;set to redis ok&quot;)) .concatWith(redisTemplate.expire(KEY, Duration.ofMinutes(1))) // 设置有效期 .doOnComplete(() -&gt; log.info(&quot;set expire ok&quot;)) .onErrorResume(e -&gt; &#123; log.error(&quot;exception &#123;&#125;&quot;, e.getMessage()); return Mono.just(false); // just就是一种比较直接的声明数据流的方式，其参数就是数据元素。 &#125;) .subscribe(b -&gt; log.info(b.toString()), e -&gt; log.error(&quot;Exception &#123;&#125;&quot;, e.getMessage()), () -&gt; cdl.countDown()); // 等待前面的执行完 log.info(&quot;Waiting&quot;); cdl.await(); &#125;&#125; 在Redis中查看 12keys *hgetall COFFEE_MENU 3、Reactive 方式访问 MongoDBMongoDB 官方提供了支持 Reactive 的驱动 mongodb-driver-reactivestreams Spring Data MongoDB 中对 Reactive 的支持 ReactiveMongoClientFactoryBean ReactiveMongoDatabaseFactory ReactiveMongoTemplate 4、Reactive 方式访问 RDBMSSpring Data R2DBCR2DBC （https://spring.io/projects/spring-data-r2dbc） Reactive Relational Database Connectivity 支持的数据库 Postgres（io.r2dbc:r2dbc-postgresql） H2（io.r2dbc:r2dbc-h2） Microsoft SQL Server（io.r2dbc:r2dbc-mssql） Spring Data R2DBC 提供的主要的类 ConnectionFactory DatabaseClient execute().sql(SQL) inTransaction(db -&gt; {}) R2dbcExceptionTranslator SqlErrorCodeR2dbcExceptionTranslator R2DBC Repository ⽀支持一些主要的类 @EnableR2dbcRepositories ReactiveCrudRepository&lt;T, ID&gt; @Table / @Id 其中的⽅法返回都是 Mono 或者 Flux 自定义查询需要⾃自⼰己写 @Query 5、通过 AOP 打印数据访问层摘要AOP (面向切面编程)AOP (Aspect OrientedProgramming): 利用AOP可以对边缘业务进行隔离，降低无关业务逻辑耦合性。提高程序的可重用性，同时提高了开发的效率。使用场景： 一般用于日志记录，性能统计，安全控制，权限管理，事务处理，异常处理，资源池管理。 Spring AOP 的⼀些核心概念 Aspect： 切⾯ Join Point： 连接点，Spring AOP里总是代表一次⽅法执行 Advice： 通知，在连接点执行的动作 Pointcut： 切入点，说明如何匹配连接点 Introduction： 引入，为现有类型声明额外的⽅法和属性 Target object： 目标对象 AOP proxy： AOP 代理对象，可以是 JDK 动态代理，也可以是 CGLIB 代理 Weaving： 织⼊，连接切⾯与⽬标对象或类型创建代理的过程 常用注解 @EnableAspectAutoProxy 开启 Aspect 的支持，对于添加该注解的相关类去做一个 Proxy。 @Aspect 声明类是一个切面，另外需要添加一个可以成为Bean的注解。 通知注解 @Pointcut @Before @After 运行结束去 Advice @AfterReturning 返回之后 Advice @AfterThrowing 抛出异常才去做 Advice @Around 在被通知的方法调用之前和调用之后执行自定义的方法 Order 指定切面的执行顺序 AOP 流程 声明切面（@Aspect） 定义切点（@Pointcut） 定义通知（@Before / @After / @AfterReturning / @AfterThrowing / @Around） 性能拦截器的简单例子代码仓库 PS：如何打印SQL HikariCP: 本身不支持SQL输出，可以依赖 P6Spy 的库实现。 Alibaba Druid 具有内置的 SQL 输出。 https://github.com/alibaba/druid/wiki/Druid 中使⽤ log4j2 进行⽇志输出 实例中使用 HikariCP 所以使用 P6Spy 导入依赖12345&lt;dependency&gt; &lt;groupId&gt;p6spy&lt;/groupId&gt; &lt;artifactId&gt;p6spy&lt;/artifactId&gt; &lt;version&gt;3.9.1&lt;/version&gt;&lt;/dependency&gt; 配置 p6spy1234spring.datasource.driver-class-name=com.p6spy.engine.spy.P6SpyDriverspring.datasource.url=jdbc:p6spy:h2:mem:testdbspring.datasource.username=saspring.datasource.password= 新建 psy.properties 添加 p6spy 配置1234567891011# 单行日志logMessageFormat=com.p6spy.engine.spy.appender.SingleLineFormat# 使用Slf4J记录sqlappender=com.p6spy.engine.spy.appender.Slf4JLogger# 是否开启慢SQL记录outagedetection=true# 慢SQL记录标准，单位秒outagedetectioninterval=2 声明切面、定义切点和通知12345678910111213141516171819202122232425262728293031323334353637383940414243package aspect;import lombok.extern.slf4j.Slf4j;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.Around;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Pointcut;import org.springframework.stereotype.Component;// 1、声明切面@Aspect@Component@Slf4jpublic class PerformanceAspect &#123; // 3、定义通知 @Around(&quot;repositoryOps()&quot;) public Object logPerformance(ProceedingJoinPoint pjp) throws Throwable &#123; long startTime = System.currentTimeMillis(); String name = &quot;_&quot;; String result = &quot;Y&quot;; try&#123; // 获取方法的名字 name = pjp.getSignature().toShortString(); return pjp.proceed(); &#125;catch (Throwable t)&#123; result = &quot;N&quot;; throw t; &#125;finally &#123; long endTime = System.currentTimeMillis(); log.info(&quot;&#123;&#125;; &#123;&#125;; &#123;&#125;ms&quot;, name, result, endTime - startTime); &#125; &#125; // 2、定义切点 // 增强 com.jq.coffe.repository 包下面的所有方法 // execution 表示当&quot;()&quot;中指定的方法执行时被触发；第一个 &quot;*&quot; 表示返回任意类型；&quot;com.jq.coffe.repository&quot; 表示包名； // 第一个 &quot;..&quot; 表示 repository 包及其子包；第二个 &quot;*&quot; 表示任意类；&quot;(..)&quot; 表示方法的任意参数个数 @Pointcut(&quot;execution(* com.jq.coffe.repository..*(..))&quot;) private void repositoryOps()&#123; &#125;&#125; 第六章 Spring MVCSpring MVC 基本概念DispatcherServlet Controller xxxResolver ViewResolver HandleExceptionResolver MultipartResolver HandlerMapping Spring MVC常用注解 @Controller RestController (= @Controller + @ResponseBody) RequetMapping @GetMapping / @PostMapping @PutMapping / @DeleteMapping @RequestBody / @ResponseBody / @ResponseBody 1 1","categories":[{"name":"Spring","slug":"Spring","permalink":"http://example.com/categories/Spring/"}],"tags":[]},{"title":"初识ThreadLocal","date":"2022-04-16T04:22:26.000Z","path":"2022/04/16/初识ThreadLocal/","text":"1、ThreadLocal 使用实例来源：廖雪峰Java教程 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.TimeUnit;public class Main &#123; public static void main(String[] args) throws Exception &#123; ExecutorService es = Executors.newFixedThreadPool(3); String[] users = new String[] &#123; &quot;Bob&quot;, &quot;Alice&quot;, &quot;Tim&quot;, &quot;Mike&quot;, &quot;Lily&quot;, &quot;Jack&quot;, &quot;Bush&quot; &#125;; for (String user : users) &#123; es.submit(new Task(user)); &#125; es.awaitTermination(3, TimeUnit.SECONDS); es.shutdown(); &#125;&#125;class UserContext implements AutoCloseable &#123; // private static final ThreadLocal&lt;String&gt; userThreadLocal = new ThreadLocal&lt;&gt;(); public UserContext(String name) &#123; userThreadLocal.set(name); System.out.printf(&quot;[%s] init user %s...\\n&quot;, Thread.currentThread().getName(), UserContext.getCurrentUser()); &#125; public static String getCurrentUser() &#123; return userThreadLocal.get(); &#125; @Override public void close() &#123; System.out.printf(&quot;[%s] cleanup for user %s...\\n&quot;, Thread.currentThread().getName(), UserContext.getCurrentUser()); userThreadLocal.remove(); &#125;&#125;class Task implements Runnable &#123; final String username; public Task(String username) &#123; this.username = username; &#125; @Override public void run() &#123; try (UserContext ctx = new UserContext(this.username)) &#123; new Task1().process(); new Task2().process(); new Task3().process(); &#125; &#125;&#125;class Task1 &#123; public void process() &#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; &#125; System.out.printf(&quot;[%s] check user %s...\\n&quot;, Thread.currentThread().getName(), UserContext.getCurrentUser()); &#125;&#125;class Task2 &#123; public void process() &#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; &#125; System.out.printf(&quot;[%s] %s registered ok.\\n&quot;, Thread.currentThread().getName(), UserContext.getCurrentUser()); &#125;&#125;class Task3 &#123; public void process() &#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException ignored) &#123; &#125; System.out.printf(&quot;[%s] work of %s has done.\\n&quot;, Thread.currentThread().getName(), UserContext.getCurrentUser()); &#125;&#125; 2、ThreadLocal 结构ThreadLocal类里边定义了一个ThreadLocalMap静态内部类，ThreadLocalMap里边又有一个static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt;{}。除此之外，ThreadLocalMap中定义了private Entry[] table。因此，ThreadLocal的结构如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class ThreadLocal&lt;T&gt; &#123; static ThreadLocalMap createInheritedMap(ThreadLocalMap parentMap) &#123; return new ThreadLocalMap(parentMap); &#125; static class ThreadLocalMap &#123; static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123; /** The value associated with this ThreadLocal. */ Object value; Entry(ThreadLocal&lt;?&gt; k, Object v) &#123; super(k); value = v; &#125; &#125; /** * The initial capacity -- MUST be a power of two. */ private static final int INITIAL_CAPACITY = 16; /** * The table, resized as necessary. * table.length MUST always be a power of two. */ private Entry[] table; /** * The number of entries in the table. */ private int size = 0; /** * The next size value at which to resize. */ private int threshold; // Default to 0 ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123; table = new Entry[INITIAL_CAPACITY]; int i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - 1); table[i] = new Entry(firstKey, firstValue); size = 1; setThreshold(INITIAL_CAPACITY); &#125; // ... &#125; // ...&#125; 内存泄露问题ThreadLocalMap中的key是一个弱引用，垃圾回收时就会被回收。如果ThreadLocalMap对应的线程依旧存活，那么value就依旧具有强引用而不会被回收，从而导致内存泄漏。解决内存泄漏的方法：直接调用remove()方法 (try{}finally{})，将value也置为 NULL。 3、结合Thread理解ThreadLoalThread类中包含一个ThreadLocal.ThreadLocalMap类型的成员变量threadLocals，因此每一个Thread都有一个ThreadLocalMap。 12345public class Thread implements Runnable &#123; /* ThreadLocal values pertaining to this thread. This map is maintained * by the ThreadLocal class. */ ThreadLocal.ThreadLocalMap threadLocals = null;&#125; ThreadLoalset或get时，会先获取当前的thread，其实操作的就是thread的threadLocals,代码如下： 1234567891011121314151617181920212223242526272829public class ThreadLocal&lt;T&gt; &#123; public T get() &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) &#123; ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) &#123; @SuppressWarnings(&quot;unchecked&quot;) T result = (T)e.value; return result; &#125; &#125; return setInitialValue(); &#125; public void set(T value) &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value); &#125; ThreadLocalMap getMap(Thread t) &#123; return t.threadLocals; &#125;&#125; 在set方法中，最终是map.set(this, value)，这儿的this是Thread的一个实例,因此map结构是 (线程 –&gt; Object)。 思考：Entry类数组的作用？3、ThreadLocal 使用场景 ThreadLocal 相当于是线程的本地缓存，因此对可以存储一些属于该线程的数据，防止竞争。 对于当前线程多次使用的的数据可以使用 ThreadLocal 存储，通过 get 方法就可以获得。比如，当前用户的 session 会在程序中多次使用，定义一个 ThreadLocal 存储，每次使用时 get 即可。 参考：1、Guide ThreadLocal 关键字解析","categories":[{"name":"java","slug":"java","permalink":"http://example.com/categories/java/"}],"tags":[]},{"title":"秒杀项目总结","date":"2022-04-16T04:22:26.000Z","path":"2022/04/16/秒杀项目总结/","text":"configuration该配置文件说明如何在本地搭建起环境，包括启动 mysql、启动虚拟机、启动 redis。 一、Mysql启动 打开navicat 连接 127.0.0.1 即可。 可以使用 http://www.localhost:8080/demo/db/get 测试 二、Redis 启动redis 是使用 multipass 安装的虚拟机需要先启动虚拟机，然后在虚拟机中启动redis。 1、启动 multipass12multipass info -allmultipass shell XXX(host) 参考链接：http://www.manongjc.com/detail/21-gtzvxvzjtoaxswf.html 2、启动 redis1234cd /usr/local/redisredis-server redis.confredis-cliauth 123456 可以使用 http://www.localhost:8080/demo/redis/get 测试 三、压测1. 图形化压测2. 命令行压测首先，需要将jar包启动（参考Spring Boot打jar包）。然后，使用jmeter压测。 1jmeter.sh -n -t /Users/jq/Desktop/goods_list.jmx -l result.jtl 如果OOM，可以使用下面命令设置更大的JVM堆栈内存。 1JVM_ARGS=&quot;-Xms512m -Xmx5g&quot; jmeter.sh -n -t /Users/jq/Desktop/goods_list.jmx -l result.jtl 四、Spring Boot打war包。1. 添加依赖12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; 2. 添加12345678910111213141516171819&lt;build&gt; &lt;finalName&gt;$&#123;project.artifactId&#125;&lt;/finalName&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;failOnMissingWebXml&gt;false&lt;/failOnMissingWebXml&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.1&lt;/version&gt; &lt;configuration&gt; &lt;fork&gt;true&lt;/fork &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 3. 修改1234&lt;groupId&gt;org.imooc&lt;/groupId&gt;&lt;artifactId&gt;miaosha&lt;/artifactId&gt;&lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&lt;packaging&gt;war&lt;/packaging&gt; 同时，把packaging中的jar修改为war。 4. 修改MainApplication类123456789101112@SpringBootApplicationpublic class MainApplication extends SpringBootServletInitializer &#123; public static void main(String[] args) &#123; SpringApplication.run(MainApplication.class, args); &#125; @Override protected SpringApplicationBuilder configure(SpringApplicationBuilder builder)&#123; return builder.sources(MainApplication.class); &#125;&#125; 5. brew 安装 tomcat@9（和java8匹配) \\Brew会默认安装在/opt/homebrew/Cellar/目录下。 6. 配置tomcat快速启动12alias tomcatstart=/opt/homebrew/Cellar/tomcat@9/9.0.60/libexec/bin/startup.shalias tomcatstop=/opt/homebrew/Cellar/tomcat@9/9.0.60/libexec/bin/shutdown.sh 7. 打成 war 包1mvn clean package 在miaosha/target目录下生成miasma.war包。将miasma.war拷贝到 /opt/homebrew/Cellar/tomcat@9/9.0.60/libexec/webapps 目录下。 8. tomcatstart 启动tomcat。 \\输入http://www.localhost:8080测试tomcat是否搭建成功。输入 http://www.localhost:8080/miaosha/login/to_login， 查看登录界面，但目前不能登录，需要在/opt/homebrew/Cellar/tomcat@9/9.0.60/libexec/webapps/Root 目录下添加一些资源。 五、Spring Boot打jar包1、添加依赖12345678910111213141516&lt;build&gt; &lt;finalName&gt;$&#123;project.artifactId&#125;&lt;/finalName&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.1&lt;/version&gt; &lt;configuration&gt; &lt;fork&gt;true&lt;/fork&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 2、修改1234&lt;groupId&gt;org.imooc&lt;/groupId&gt;&lt;artifactId&gt;miaosha&lt;/artifactId&gt;&lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&lt;packaging&gt;jar&lt;/packaging&gt; 3、打成 jar 包1mvn clean package 在miaosha/target目录下生成miasma.jar包 4、运行jar，并输出到nohup文件。1nohup java -jar miaosha.jar &amp; 5、测试输入 http://www.localhost:8080/miaosha/login/to_login， 查看登录界面，并且进行压测。 输入 tail -f nohup.out 可以查看日志的末尾输出。 五、压测 redis12345678redis-benchmark -a 123456 -h 127.0.0.1 -p 6379 -c 100 -n 100000redis-benchmark -a 123456 -h 127.0.0.1 -p 6379 -q -d 100redis-benchmark -a 123456 -t set,lpush -n 100000 -q# 只测试单条命令redis-benchmark -a 123456 -n 100000 -q script load &quot;redis.call(&#x27;set&#x27;,&#x27;foo&#x27;,&#x27;bar&#x27;)&quot; 六、页面优化技术 页面缓存 + URL缓存 + 对象缓存 页面静态化（不需要重复下载页面，只需要下载动态的），前后端分离 静态资源优化 CDN优化 1、页面缓存将 goods_list 页面的信息写入 redis，设置了60s的缓存时间。可以下命令测试： 12keys GoodsKey:glget GoodsKey:gl 2、URL 缓存和页面缓存大致一样，给 goods_detail 页面添加缓存，不同于 goods_list 页面的是 goods_detail 页面需要加用户的标号：”1”（http://www.localhost:8080/goods/to_detail/1）。 3、对象缓存此处的对象指的是用户对象，通过用户id将用户的信息写入缓存。 MiaoshaUserService 类中的 updatePassword 方法，如何更新数据库密码。 4、页面静态化将数据存在浏览器中，主要技术有：AngularJS、Vue.js等此处使用简单的。 服务端不直接返回html，只返回页面上动态的数据。在前端html页面中接受这些动态的数值即可。 思考：如何验证客户端加载了浏览器的本地缓存而不是服务端的数据？\\304状态码表示服务端数据未改变，可直接使用客户端未过期的缓存。304状态码返回时不包含任何响应的主体部分。请求首部包含If-Modified-Since: Mon, 11 Apr 2022 10:07:49 GMT，服务端会和资源的最近更新时间比较，确定是不是需要返回资源。不需要则返回304状态码，具体如下： 123HTTP/1.1 304Last-Modified: Mon, 11 Apr 2022 10:07:49 GMTDate: Mon, 11 Apr 2022 10:10:19 GMT 进一步优化上面虽然没有直接下载服务端的数据，但还是请求了一次服务端。通过在静态资源中添加设置静态资源的有效时间，不访问服务器，直接使用客户端的缓存。\\ 验证查看网页请求，发现响应如下： 1234567HTTP/1.1 200Last-Modified: Mon, 11 Apr 2022 10:07:49 GMTContent-Length: 4818Accept-Ranges: bytesContent-Type: text/htmlCache-Control: max-age=3600Date: Mon, 11 Apr 2022 10:43:17 GMT Cache-Control: max-age=3600字段表示该资源可以在3600ms内复用。 问题1：库存会被减成负值原因：两个人同时减库存时，调用的sql语句如下：1@Update(&quot;update miaosha_goods set stock_count = stock_count - 1 where goods_id = #&#123;goodsId&#125;”) 当只有一个库存时会降为-1，此时可以在sql中加库存大于0的判断如下： 1@Update(&quot;update miaosha_goods set stock_count = stock_count - 1 where goods_id = #&#123;goodsId&#125; and stock_count &gt; 0”)`） 问题2：一个用户购买了两个同一个商品。原因：库存为10，同一个用户同时发出两个请求，同时进入了判断库存等方法，导致一个用户买到两个商品。解决思路：购买流程是：减库存 -&gt; 下订单，下订单的时候有个订单表，有用户id和商品id，此处在订单表中给这两个字段建立联合唯一索引。这样创建订单时，如此该用户存在一个订单，再下另一个订单时就会出现重复。注意：在创建订单的函数前加@Transactional。如果只给用户id建立唯一索引可以不？不行，允许用户秒杀其他商品。 5、静态资源优化 JS/CSS 压缩，减少流浪； 多个 JS/CSS 组合 Tengine 在nginx基础上开发的CDN:内容分发网络。 七、秒杀接口优化方案： 把秒杀商品信息加载到redis，减少mysql的访问。 内存标记，减少一次redis查商品库存的访问：使用map（goodsId -&gt; boolean）， false表示还有库存，true表示没有库存，则秒杀结束。接下来的关于goodsId的请求不在访问redis，直接返回。 通过在redis中预减库存，当库存不足，直接返回，不需要进一步查询Redis中的订单信息，以判断是否秒杀成功。减少了redis的访问。 使用rabbitmq实现异步下单，达到削峰的作用。秒杀流程： 系统初始化，把商品库存数量加载到redis。 收到请求，内存标记，减少redis访问： redis预减库存，如果库存不足，设置该goodsId的map值为true，然后直接返回。 请求入队，立即返回排队中。 请求出队，生成订单，减少库存。 客户端轮询，是否秒杀成功。 环境安装安装 RabbitMQ。 12sudo apt-get install erlangerl 以上命令能正常输出说明erlang安装成功。接下来安装、启动并验证rabbitmq是否在监听5672端口。 123sudo apt-get install rabbitmq-serversudo rabbitmq-servernetstat -nap | grep 5672 关闭rabbitmq。 1sudo rabbitmqctl stop 设置一个 rabbitmq 的用户名和密码，默认存在一个用户 guest，密码为 guest。123rabbitmqctl add_user YOUR_USERNAME YOUR_PASSWORDrabbitmqctl set_user_tags YOUR_USERNAME administratorrabbitmqctl set_permissions -p / YOUR_USERNAME &quot;.*&quot; &quot;.*&quot; &quot;.*&quot; 扩展 Nginx水平扩展。 分库分表 八、安全优化 秒杀接口地址隐藏 数学公式验证码（可以削峰） 接口限流放刷 1、秒杀接口地址隐藏思路：秒杀开始之前，先去请求接口获取秒杀地址。 接口改造，带上PathVariable参数。 添加生成地址的接口。 秒杀收到请求，先验证PathVariable 流程秒杀开始，用户点击秒杀按钮时，在后端使用uuid+DM5生成一个str，并且以用户id_商品id为键，str为值存入redis。前端通过接口请求到这个str，拼接到路径中请求后端。后端取出这个str后和自己生成的oldStr对比（redis中的str），如果一致，则进入秒杀流程。 问题：有人先请求前端的接口得到str，然后去访问秒杀接口，可行吗？？？ 2、数学公式验证码 添加生成验证码的接口。 在获取秒杀路径的时候，验证验证码。 ScriptEngine使用。 流程秒杀开始时，前端请求后端生成验证码，然后将生成的验证码信息以vc_用户id_秒杀商品id -&gt; 验证码结果的形式存储在redis中，同时将验证码发给前端。前端展示给用户，用户输入结果，点击秒杀按钮。前端发送请求给后端（同时包含秒杀地址参数），后端先从redis中取出验证码结果验证是否正确。正确则开始在redis中生成path，并进行下一步操作。 总结秒杀系统设计 负责项目的设计和开发 2022.4 - 2022.5 • 项目介绍：为了解决秒杀商品时存在高并发的问题，本项目基于SpringBoot开发秒杀系统。本人主要负责登录模块、商品列表模块、商品详情模板、订单详情模块、秒杀接口优化部分、安全模块。 • 个人收获：对于基于SpringBoot项目的开发有了更加完整和深刻的认识。 • 相关技术：SpringBoot、MySql、mybatis、Redis、RabbitMQ、Thymeleaf、jmeter","categories":[{"name":"java","slug":"java","permalink":"http://example.com/categories/java/"}],"tags":[]},{"title":"SpringMVC自定义参数解析器","date":"2022-04-15T08:05:04.000Z","path":"2022/04/15/SpringMVC自定义参数解析器/","text":"1、实现参数解析器的接口HandlerMethodArgumentResolverHandlerMethodArgumentResolver接口包含两个方法supportsParameter和resolveArgument。 supportsParameter方法返回 boolean 值，表示是否启用该解析器，true 表示启用，false 表示不启用； resolveArgument 方法表示方法参数的解析过程，就是你把 HTTP 的请求参数转换为方法参数的过程，返回 Object 对象，即参数的转换结果。 源代码如下： 12345public interface HandlerMethodArgumentResolver &#123; boolean supportsParameter(MethodParameter var1); Object resolveArgument(MethodParameter var1, ModelAndViewContainer var2, NativeWebRequest var3, WebDataBinderFactory var4) throws Exception;&#125; 2、自定义一个参数解析器 定义一个方法注解 实现HandlerMethodArgumentResolver接口。 注册参数解析器 使用参数解析器 2.1 定义一个方法注解12345@Retention(RUNTIME)@Target(METHOD)public @interface ParamModel &#123; // 可以定义需要带的参数&#125; 2.2 实现HandlerMethodArgumentResolver接口。在HandlerMethodArgumentResolver接口中实现具体的参数解析。 1234567891011121314151617181920@Servicepublic class UserArgumentResolvers implements HandlerMethodArgumentResolver &#123; @Override public boolean supportsParameter(MethodParameter parameter) &#123; //带有注解就解析，即调用下面的 resolveArgument 方法。 return methodParameter.hasParameterAnnotation(ParamModel.class); &#125; @Override public Object resolveArgument(MethodParameter methodParameter, ModelAndViewContainer modelAndViewContainer, NativeWebRequest webRequest, WebDataBinderFactory webDataBinderFactory) throws Exception &#123; HttpServletRequest request = webRequest.getNativeRequest(HttpServletRequest.class); HttpServletResponse response = webRequest.getNativeResponse(HttpServletResponse.class); // 从request和request中解析出对应的Object。 return null; &#125; 2.3 注册参数解析器1234567891011@Configurationpublic class WebConfig extends WebMvcConfigurerAdapter &#123; @Autowired UserArgumentResolvers userArgumentResolver; @Override public void addArgumentResolvers(List&lt;HandlerMethodArgumentResolver&gt; argumentResolvers) &#123; argumentResolvers.add(userArgumentResolver); &#125;&#125; 2.4 使用参数解析器1234public void getMiaoshaPath(@ParamModel int verifyCode) &#123; // 参数解析的结果会赋值给verifyCode。 // ...&#125;","categories":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://example.com/categories/SpringMVC/"}],"tags":[{"name":"java、SpringMVC、参数解析器","slug":"java、SpringMVC、参数解析器","permalink":"http://example.com/tags/java%E3%80%81SpringMVC%E3%80%81%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%E5%99%A8/"}]},{"title":"SpringMVC实现拦截器","date":"2022-04-15T08:01:11.000Z","path":"2022/04/15/SpringMVC实现拦截器/","text":"1、功能需求在秒杀商品时，需要使用秒杀接口防刷保护程序，可以定义一个拦截器实现。具体使用如下所示： 1@AccessLimit(seconds = 1, maxCount = 100, needLogin = true) 这个拦截器需要当前用户登录，且1s内限制最大请求次数为100。 2、拦截器的主要类HandlerInterceptorAdapterHandlerInterceptorAdapter提供的方法如下： preHandle:方法执行前调用拦截器，返回true，则接续执行，否则不会执行方法。 postHandle:在方法执行后调用。 afterCompletion源代码如下：123456789public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; return true;&#125;public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123;&#125;public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;&#125; 3、实现拦截器 自定义 @AccessLimit 参数解析器。 重写HandlerInterceptorAdapter类的preHandle方法 注册拦截器 使用拦截器 3.1 自定义 @AccessLimit 注解。12345678910/** 定义一个注解*/@Retention(RUNTIME)@Target(METHOD)public @interface AccessLimit &#123; int seconds(); int maxCount(); boolean needLogin() default true;&#125; 3.2 重写preHandle方法123456789101112131415161718192021222324252627282930/** 满足拦截条件 return false;* 不满足拦截条件 return true;*/@Servicepublic class AccessInterceptor extends HandlerInterceptorAdapter &#123; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; if (handler instanceof HandlerMethod)&#123; MiaoshaUser user = getUser(request, response); // 存储user UserContext.setUser(user); // 当前线程就可以取用。 HandlerMethod hm = (HandlerMethod) handler; AccessLimit accessLimit = hm.getMethodAnnotation(AccessLimit.class); // 获取注解 if (accessLimit == null) &#123; // 如果没有限制 return true; &#125; int seconds = accessLimit.seconds(); int maxCount = accessLimit.maxCount(); boolean needLogin = accessLimit.needLogin(); // 具体的拦截逻辑 &#125; return true; &#125;&#125; 3.3 注册拦截器12345678910111213141516@Configurationpublic class WebConfig extends WebMvcConfigurerAdapter &#123; @Autowired AccessInterceptor accessInterceptor; @Override public void addArgumentResolvers(List&lt;HandlerMethodArgumentResolver&gt; argumentResolvers) &#123; argumentResolvers.add(userArgumentResolver); &#125; // 注册拦截器 @Override public void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(new); &#125;&#125; 3.4 使用拦截器1234@AccessLimit(seconds = 1, maxCount = 100, needLogin = true)public void test()&#123; // ...&#125;","categories":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://example.com/categories/SpringMVC/"}],"tags":[{"name":"java，SpringMVC，拦截器","slug":"java，SpringMVC，拦截器","permalink":"http://example.com/tags/java%EF%BC%8CSpringMVC%EF%BC%8C%E6%8B%A6%E6%88%AA%E5%99%A8/"}]},{"title":"java杂项","date":"2022-04-15T07:02:11.000Z","path":"2022/04/15/java杂项/","text":"ThreadLcoal 的用法在秒杀功能中，定义一个static的ThreadLcoal存储MiaoshaUser。当用户点击秒杀按钮时将其存储在ThreadLocal中，该线程以后使用时就可以直接get。 1private static ThreadLocal&lt;MiaoshaUser&gt; userHolder = new ThreadLocal&lt;&gt;(); 如果不这样做，需要每次从请求中解析MiaoshaUser对象,代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142@Servicepublic class UserArgumentResolvers implements HandlerMethodArgumentResolver &#123; @Autowired MiaoshaUserService userService; @Override public boolean supportsParameter(MethodParameter parameter) &#123; // 当为 MiaoshaUser 类型时就执行参数解析，即调用下面的 resolveArgument 方法。 Class&lt;?&gt; clazz = parameter.getParameterType(); return clazz == MiaoshaUser.class; &#125; @Override public Object resolveArgument(MethodParameter methodParameter, ModelAndViewContainer modelAndViewContainer, NativeWebRequest webRequest, WebDataBinderFactory webDataBinderFactory) throws Exception &#123; HttpServletRequest request = webRequest.getNativeRequest(HttpServletRequest.class); HttpServletResponse response = webRequest.getNativeResponse(HttpServletResponse.class); String paramToken = request.getParameter(MiaoshaUserService.COOKI_NAME_TOKEN); String cookieToken = getCookieValue(request, MiaoshaUserService.COOKI_NAME_TOKEN); if (StringUtils.isEmpty(cookieToken) &amp;&amp; StringUtils.isEmpty(paramToken))&#123; return null; &#125; String token = StringUtils.isEmpty(paramToken) ? cookieToken : paramToken; return userService.getByToken(response,token); &#125; private String getCookieValue(HttpServletRequest request, String cookieName) &#123; Cookie[] cookies = request.getCookies(); if (cookies == null || cookies.length &lt;= 0)&#123; return null; &#125; for (Cookie cookie : cookies) &#123; if (cookie.getName().equals(cookieName))&#123; return cookie.getValue(); &#125; &#125; return null; &#125;&#125;","categories":[{"name":"java","slug":"java","permalink":"http://example.com/categories/java/"}],"tags":[{"name":"杂项","slug":"杂项","permalink":"http://example.com/tags/%E6%9D%82%E9%A1%B9/"}]},{"title":"杂项","date":"2022-04-08T03:37:43.000Z","path":"2022/04/08/杂项/","text":"配置环境变量exportexport 表示将该路径添加到环境变量中，打开 vim .zshrc ，添加jmeter的快速启动路径 export JMETER_HOME=/usr/local/apache-jmeter-5.4.3export PATH=$JAVA_HOME/bin:$PATH:.:$JMETER_HOME/bin:$PATHexport CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JMETER_HOME/lib/ext/ApacheJMeter_core.jar:$JMETER_HOME/lib/jorphan.jar:$JMETER_HOME/lib/logkit-2.0.jar source .zshrc 使.zshrc生效。使用 export -p 可以查看当前的环境中的路径。 aliasalias 为指定路径起别名。 export PATH=/usr/local/mysql/bin:$PATH#快速启动、结束MySQL服务, 可以使用alias命令alias mysqlstart=’sudo /usr/local/mysql/support-files/mysql.server start’alias mysqlstop=’sudo /usr/local/mysql/support-files/mysql.server stop’ macOS目录的作用系统硬件相关/cores 内核转储文件存放目录。当一个进程崩溃时，如果系统允许则会产生转储文件。/dev 设备文件存放目录，如何代表硬盘的/dev/disk0。/Network 网络节点存放目录；/Volumes 文件系统挂载点存放目录。 系统配置相关/etc. 标准unix系统配置文件存放目录，如用户密码文件/etc/passwd。此目录实际为指向/private/etc的链接。 系统程序相关/Applications 应用程序目录，默认所有的GUI应用程序都安装在这里；/Library 系统的数据文件、帮助文件、文档等等；/System 只包含一个名为Library的目录，这个子目录中存放了系统的绝大部分组件，如各种framework，以及内核模块，字体文件等等。 系统命令相关/bin 传统unix命令的存放目录，如ls，rm，mv等。/sbin 传统unix管理类命令存放目录，如fdisk，ifconfig等等。 用户信息相关/Users 存放用户的个人资料和配置。每个用户有自己的单独目录。 用户经常使用/usr 第三方程序安装目录。/usr/bin, /usr/sbin, /usr/lib，其中/usr/lib目录中存放了共享库（动态链接库）。/var 存放经常变化的文件，如日志文件。此目录实际为指向/private/var的链接。 /opt/homebrew brew安装的程序一般放这儿。 /private 里面的子目录存放了/tmp, /var, /etc等链接目录的目标目录。/tmp 临时文件存放目录，其权限为所有人任意读写。此目录实际为指向/private/tmp的链接。 其他/installer.failurerequests 可能是用来记录发生crash时的日志。 linux 命令拾遗lsof（list open files）lsof 列出当前系统打开文件的工具。lsof -i :8080 可以查看当前占用8080端口的进程。 ls（list）ls默认情况下用来打印出当前目录的列表。 git流程将写了一半的项目git到空github上。 github上创建同名仓库 git clone到本地 将隐藏的.git文件复制到已经写了一半的project中 git add . git status git commit -m “提交说明” git push","categories":[],"tags":[{"name":"杂项","slug":"杂项","permalink":"http://example.com/tags/%E6%9D%82%E9%A1%B9/"}]},{"title":"hexo github配置博客","date":"2022-04-06T03:44:59.000Z","path":"2022/04/06/hexo github配置博客/","text":"1、 配置环境流程1.1 安装node.js官网下载node.jsnode -vnmp -v 1.2 创建blog目录mkdir /Users/jq/blog 1.3 安装hexonmp install hexo -g hexo-clihexo -v 1.4 VPN设置如果设置了VPN，需要设置环境变量；vim ./~zshrc 123export https_proxy=http://127.0.0.1:7890 http_proxy=http://127.0.0.1:7890 all_proxy=socks5://127.0.0.1:7890source ./~zshrc 1.5 初始化hexosudo susudo hexo init 2、写一个博客流程2.1 开始hexohexo s 2.2 创建一个新博客hexo n “XXXX” 使用vsconde等编写内容。 2.3 清理hexo clean 2.4 生成博客hexo g 2.5 浏览刚才写的博客hexo s 3、配置github3.1 在最后添加1234deploy: type: git repository: git@github.com:jiaoqiang2014/jiaoqiang2014.github.io.git branch: master 4、换主题4.1 下载主题12git clone git@github.com:litten/hexo-theme-yilia.git themes/yiliagit@github.com:yscoder/hexo-theme-indigo.git 4.2 修改_config.yml配置1theme: yilia Hexo clean Hexo g Hero s 5、代码折叠功能6、hexo引用本地图片无法显示问题使用格式为：![图片描述](md文件夹名字/example.jpg) 参考博客：1、 hexo增加分类、标签2、 hexo主题美化3 https://github.com/Neveryu/Neveryu.github.io/blob/","categories":[{"name":"hexo","slug":"hexo","permalink":"http://example.com/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://example.com/tags/hexo/"}]}]