[{"title":"html入门","url":"/2022/08/07/html入门/","content":"\n## HTML 简介\n[HTML 推荐阅读](https://developer.mozilla.org/zh-CN/docs/Learn/Getting_started_with_the_web/HTML_basics) -- 本文也是总结该网址的内容。\n\nHTML 是一种超文本标记语言，标记的是元素（elements），而元素包含了（tags (en-US)）与内容（content），我们用标签来控制内容的样貌，例如字体大小、斜体粗体、在或图片超设置链接等。\n\n## HTML 的组成\n\n![HTML 的组成](https://developer.mozilla.org/en-US/docs/Learn/Getting_started_with_the_web/HTML_basics/grumpy-cat-small.png)\n\n元素还可以有 属性（Attribute),可以利用设置这个元素的色彩、收藏方式、图形的格线等，形式如下：\n![元素的属性](https://developer.mozilla.org/en-US/docs/Learn/Getting_started_with_the_web/HTML_basics/grumpy-cat-attribute-small.png)\n\n","tags":["html"],"categories":["html"]},{"title":"java Html 解析工具 Jsoup","url":"/2022/08/06/java Html解析工具Jsoup/","content":"友情提示：阅读前可以先了解 HTML 的结构 -- [html入门](https://jiaoqiang2014.github.io/2022/08/07/html%E5%85%A5%E9%97%A8/)\n## Jsoup 简介\njsoup是一个用于处理 HTML 的 Java 库。它提供 HTML5 DOM 方法和 CSS 选择器，用于捕获 URLs 并且提取和操作数据。\n\njsoup 实现了WHATWG HTML规范，并将 HTML 解析为与现代浏览器相同的 DOM。\n1. 从 URL、文件或字符串解析 HTML\n2. 使用 DOM 遍历或 CSS 选择器查找和提取数据\n3. 操作 HTML 元素、属性和文本\n4. 根据安全列表清理用户提交的内容，以防止 XSS\n5. 输出整洁的 HTML\njsoup 旨在处理各种常见的 HTML；jsoup 将创建一个合理的解析树。\n\n## 实例\n\n参考链接: [Java爬虫利器HTML解析工具-Jsoup](https://www.cnblogs.com/youyoui/p/11065923.html)\n\n添加 maven 依赖\n```xml\n<dependency>\n    <groupId>org.jsoup</groupId>\n    <artifactId>jsoup</artifactId>\n    <version>1.14.1</version>\n</dependency>\n```\n\n代码\n\n```java\n/*\n    * 获取网页中的所有链接\n    * */\n@Test\npublic void testJsoupGetLinks() throws IOException {\n    Document document = Jsoup.connect(\"https://www.yiibai.com/jsoup/jsoup-quick-start.html\").get();\n    // <li><a href=\"https://www.yiibai.com/html/java/\">Java技术</a></li>\n    // <li> ... </li> 表示 Element，li 是一个 Tag， <a> ... </a> 是嵌套元素, a 是一个 Tag。\n    // <a> 标签定义超链接，用于从一个页面链接到另一个页面。 <a> 元素最重要的属性是 href 属性，它指定链接的目标。\n    Elements links = document.select(\"a[href]\");    // \"a[href]\" 相当于一个正则表达式\n    for (Element link : links) {\n        System.out.println(link.attr(\"href\"));\n        System.out.println(link.text());\n    }\n}\n\n/*\n* 获取HTML页面中的所有图像\n* */\n@Test\npublic void testJsoupGetImgs() throws IOException {\n    Document document = Jsoup.connect(\"https://www.yiibai.com/jsoup/jsoup-quick-start.html\").get();\n    // <img width=\"150\" height=\"150\" src=\"https://www.yiibai.com/static/img/qrcode.jpg\">\n    // (?i) 是正则表达式的模式修饰符，(?i)即匹配时不区分大小写。\n    Elements images = document.select(\"img[src~=(?i)\\\\.(png|jpe?g|gif)]\");    // ～表示后面正式开始正则表达式。\n    // 是否使用下面的更合理\n    // Elements images = document.select(\"img[src]\");\n    for (Element image : images) {\n        System.out.println(\"src : \" + image.attr(\"src\"));\n        System.out.println(\"height : \" + image.attr(\"height\"));\n        System.out.println(\"width : \" + image.attr(\"width\"));\n        System.out.println(\"alt : \" + image.attr(\"alt\"));\n    }\n}\n\n/*\n    * 统计 HTML 中的字数\n    * */\n@Test\npublic void testJsoupCountWords() throws IOException {\n    Document document = Jsoup.connect(\"https://www.yiibai.com/jsoup/jsoup-quick-start.html\").get();\n    String html = \"<p><strong>    使  用场景</p><p><strong>使  用场景      </p>\";\n    document = Jsoup.parse(html);\n    // 获取此元素及其所有子元素的规范化组合文本(开头末尾的空格回车等被删除)。\n    String allText = document.text();\n    // text 未被规范化\n    String allWholeText = document.wholeText();\n    // 只获取当前节点的内容，不获取字节点内容\n    String ownText = document.ownText();\n}\n\n```\n\n\n\n\n\n","tags":["java","Jsoup","html 解析"],"categories":["Jsoup"]},{"title":"Kafka核心技术与实战","url":"/2022/06/21/Kafka核心技术与实战/","content":"\n## 第一章 消息引擎系统ABC\n\nApache Kafka 是一款开源的消息引擎系统，也是分布式流处理平台。消息引擎系统是一组规范，利用这组规范在不同系统之间传递语义准确的消息，实现松耦合的异步式数据传递。\n\n### 如何设计消息编码格式\n使用已有的一些成熟解决方案，比如使用 CSV、XML 亦或是 JSON；又或者国外大厂开源的一些序列化框架，比如 Google 的 Protocol Buffer 或 Facebook 的 Thrift。 Kafka 的选择：它使用的是纯二进制的字节序列。当然消息还是结构化的，只是在使用之前都要将其转换成二进制的字节序列。\n\n### 消息引擎系统的消息传输方式\n\n- 点对点模型：也叫消息队列模型。系统 A 发送的消息只能被系统 B 接收，其他任何系统都不能读取 A 发送的消息。\n- 发布 / 订阅模型：与上面不同的是，它有一个主题（Topic）的概念，你可以理解成逻辑语义相近的消息容器。该模型也有发送方和接收方，只不过提法不同。发送方也称为发布者（Publisher），接收方称为订阅者（Subscriber）。和点对点模型不同的是，这个模型可能存在多个发布者向相同的主题发送消息，而订阅者也可能存在多个，它们都能接收到相同主题的消息。\n\nKafka 同时支持这两种消息引擎模型。\n\n为什么系统 A 不能直接发送消息给系统 B，中间还要隔一个消息引擎呢？ -- 答案就是“削峰填谷”\n\n### Kafka 术语\n\nKafka 的三层消息架构：\n- 第一层是主题层，每个主题可以配置 M 个分区，而每个分区又可以配置 N 个副本。\n- 第二层是分区层，每个分区的 N 个副本中只能有一个充当领导者角色，对外提供服务；其他 N-1 个副本是追随者副本，只是提供数据冗余之用。\n- 第三层是消息层，分区中包含若干条消息，每条消息的位移从 0 开始，依次递增。\n- 最后，客户端程序只能与分区的领导者副本进行交互。\n\n## 第二章 生产者消息分区\n\n### 分区的作用\n\n- 提高负载均衡的能力。不同的分区能够被放置到不同节点的机器上，而数据的读写操作也都是针对分区这个粒度而进行的，这样每个节点的机器都能独立地执行各自分区的读写请求处理。并且，我们还可以通过添加新的节点机器来增加整体系统的吞吐量。\n\n- 利用分区也可以实现其他一些业务级别的需求，比如实现业务级别的消息顺序的问题，这一点我今天也会分享一个具体的案例来说明。\n\n### 分区策略\n- 轮询策略\n- 随机策略\n- 按消息键保序策略\n- 其他分区策略\n\n#### 自定义分区策略\n如果要自定义分区策略，需要显式地配置生产者端的参数partitioner.class。这个参数该怎么设定呢？方法很简单，在编写生产者程序时，可以编写一个具体的类实现org.apache.kafka.clients.producer.Partitioner接口。这个接口也很简单，只定义了两个方法：partition()和close()，通常你只需要实现最重要的 partition 方法。\n\n#### 轮询策略\n轮询策略是 Kafka Java 生产者 API 默认提供的分区策略。如果你未指定partitioner.class参数，那么你的生产者程序会按照轮询的方式在主题的所有分区间均匀地“码放”消息。\n\n#### 随机策略\n如果要实现随机策略版的 partition 方法，很简单，只需要两行代码即可：\n```java\nList<PartitionInfo> partitions = cluster.partitionsForTopic(topic);\nreturn ThreadLocalRandom.current().nextInt(partitions.size());\n```\n\n#### 按消息键保序策略\n实现这个策略的 partition 的方法只需要下面两行代码即可：\n```java\nList<PartitionInfo> partitions = cluster.partitionsForTopic(topic);\nreturn Math.abs(key.hashCode()) % partitions.size();\n```\n\n#### 其他分区策略\n基于地理位置的分区策略等。\n\n## 第三章 生产者压缩算法\n\n目前 Kafka 共有两大类消息格式，社区分别称之为 V1 版本和 V2 版本。V2 版本是 Kafka 0.11.0.0 中正式引入的。\n\n不论是哪个版本，Kafka 的消息层次都分为两层：消息集合（message set）以及消息（message）。一个消息集合中包含若干条日志项（record item），而日志项才是真正封装消息的地方。\n\n### 压缩消息的位置\n生产者会生产大量的数据，因此需要压缩消息。一般情况下都在 **Producer 端压缩、Broker 端保持、Consumer 端解压缩**。\n\n一个配置压缩的例子：\n```java\n Properties props = new Properties();\n props.put(\"bootstrap.servers\", \"localhost:9092\");\n props.put(\"acks\", \"all\");\n props.put(\"key.serializer\", \"org.apache.kafka.common.serialization.StringSerializer\");\n props.put(\"value.serializer\", \"org.apache.kafka.common.serialization.StringSerializer\");\n // 开启GZIP压缩\n props.put(\"compression.type\", \"gzip\");\n \n Producer<String, String> producer = new KafkaProducer<>(props);\n```\n\n通过`compression.type`即可配置压缩算法。\n\n### 两种 Broker 端需要压缩算法的例子\n- Broker 端指定了和 Producer 端不同的压缩算法。\n\n先看一个例子。想象这样一个对话。\n\nProducer 说：“我要使用 GZIP 进行压缩。”\n\nBroker 说：“不好意思，我这边接收的消息必须使用 Snappy 算法进行压缩。”\n\n这种情况下 Broker 接收到 GZIP 压缩消息后，只能解压缩然后使用 Snappy 重新压缩一遍。如果你翻开 Kafka 官网，你会发现 Broker 端也有一个参数叫 compression.type，和上面那个例子中的同名。但是这个参数的默认值是 producer，这表示 Broker 端会“尊重”Producer 端使用的压缩算法。可一旦你在 Broker 端设置了不同的 compression.type 值，就一定要小心了，因为可能会发生预料之外的压缩 / 解压缩操作，通常表现为 Broker 端 CPU 使用率飙升。（原因是解压缩和压缩需要消耗CPU）\n\n- Broker 端发生了消息格式转换。\n\n消息格式转换主要是为了兼容老版本的消费者程序。这个过程中会涉及消息的解压缩和重新压缩。一般情况下这种消息格式转换对性能是有很大影响的，除了这里的压缩之外，还让 Kafka 丧失了引以为豪的 Zero Copy 特性。\n\n### 解压缩\n\n解压缩一般发生在 Consumer 端。Broker 端也会发生解压缩，主要是对消息执行各种验证，但会对 Broker 端性能有一定影响，特别是对 CPU 的使用率而言。\n\n目前流行的压缩算法有GZIP、Snappy、LZ4 和 zstd。 zstd 具有最高的压缩比，LZ4 具有最高的压缩/解压缩吞吐量。\n\n## 第四章 Kafka 丢失消息解决策略\n\nKafka 只对“已提交”的消息（committed message）做有限度的持久化保证。\n\n什么是已提交的消息？\n\n当 Kafka 的若干个 Broker 成功地接收到一条消息并写入到日志文件后。\n\n### 丢失消息的场景\n- Producer 程序丢失消息\n\n网络抖动，导致消息就没有发送到 Broker 端；或者消息本身不合格导致 Broker 拒绝接收（比如消息太大了，超过了 Broker 的承受能力）等都会导致消息丢失。\n\n**解决方法** \\\nProducer 永远要使用带有回调通知的发送 API，也就是说不要使用 producer.send(msg)，而要使用 producer.send(msg, callback)。\n\n- Consumer 端丢失数据\n\nConsumer 端丢失数据主要体现在 Consumer 端要消费的消息不见了。Consumer 程序有个“位移”的概念，表示的是这个 Consumer 当前消费到的 Topic 分区的位置。\n\nConsumer 端丢失消息主要原因是：先移动了 offset 然后丢消息，出现意外情况停止读消息，但 offset 已移动，导致部分消息丢失。\n\n**解决方法**\n\nConsumer先消费消息，再更新 offset 的顺序。这样会导致重复读。\n\n- Consumer 程序开启多个线程异步处理消息导致丢失消息\n- \n\nConsumer 程序开启了多个线程异步处理消息，其中某个线程读取失败，而 Consumer 程序自动地向前更新位移。\n\n\n**解决方法**\n\nConsumer 程序不要开启自动提交位移，而是要应用程序手动提交位移。\n```java\nenable.auto.commit=false\n```\n在这里我要提醒你一下，单个 Consumer 程序使用多线程来消费消息说起来容易，写成代码却异常困难，因为你很难正确地处理位移的更新，也就是说避免无消费消息丢失很简单，但极易出现消息被消费了多次的情况。\n\n### Kafka 无消息丢失的配置\n\n1. 不要使用 producer.send(msg)，而要使用 producer.send(msg, callback)。记住，一定要使用带有回调通知的 send 方法。\n2. 设置 acks = all。acks 是 Producer 的一个参数，代表了你对“已提交”消息的定义。如果设置成 all，则表明所有副本 Broker 都要接收到消息，该消息才算是“已提交”。这是最高等级的“已提交”定义。\n3. 设置 retries 为一个较大的值。这里的 retries 同样是 Producer 的参数，对应前面提到的 Producer 自动重试。当出现网络的瞬时抖动时，消息发送可能会失败，此时配置了 retries > 0 的 Producer 能够自动重试消息发送，避免消息丢失。\n4. 设置 unclean.leader.election.enable = false。这是 Broker 端的参数，它控制的是哪些 Broker 有资格竞选分区的 Leader。如果一个 Broker 落后原先的 Leader 太多，那么它一旦成为新的 Leader，必然会造成消息的丢失。故一般都要将该参数设置成 false，即不允许这种情况的发生。\n5. 设置 replication.factor >= 3。这也是 Broker 端的参数。其实这里想表述的是，最好将消息多保存几份，毕竟目前防止消息丢失的主要机制就是冗余。\n6. 设置 min.insync.replicas > 1。这依然是 Broker 端参数，控制的是消息至少要被写入到多少个副本才算是“已提交”。设置成大于 1 可以提升消息持久性。在实际环境中千万不要使用默认值 1。\n7. 确保 replication.factor > min.insync.replicas。如果两者相等，那么只要有一个副本挂机，整个分区就无法正常工作了。我们不仅要改善消息的持久性，防止数据丢失，还要在不降低可用性的基础上完成。推荐设置成 replication.factor = min.insync.replicas + 1。确保消息消费完成再提交。\n8. Consumer 端有个参数 enable.auto.commit，最好把它设置成 false，并采用手动提交位移的方式。就像前面说的，这对于单 Consumer 多线程处理的场景而言是至关重要的。\n\n## 第五章 Kafka 拦截器\n\nKafka 拦截器分为生产者拦截器和消费者拦截器。生产者拦截器允许你在发送消息前以及消息提交成功后植入你的拦截器逻辑；而消费者拦截器支持在消费消息前以及提交位移后编写特定逻辑。值得一提的是，这两种拦截器都支持链的方式，即你可以将一组拦截器串连成一个大的拦截器，Kafka 会按照添加顺序依次执行拦截器逻辑。\n\n当前 Kafka 拦截器的设置方法是通过参数配置完成的。生产者和消费者两端有一个相同的参数，名字叫 interceptor.classes，它指定的是一组类的列表，每个类就是特定逻辑的拦截器实现类。拿上面的例子来说，假设第一个拦截器的完整类路径是 com.yourcompany.kafkaproject.interceptors.AddTimeStampInterceptor，第二个类是 com.yourcompany.kafkaproject.interceptors.UpdateCounterInterceptor，那么你需要按照以下方法在 Producer 端指定拦截器：\n```java\nProperties props = new Properties();\nList<String> interceptors = new ArrayList<>();\ninterceptors.add(\"com.yourcompany.kafkaproject.interceptors.AddTimestampInterceptor\"); // 拦截器1\ninterceptors.add(\"com.yourcompany.kafkaproject.interceptors.UpdateCounterInterceptor\"); // 拦截器2\nprops.put(ProducerConfig.INTERCEPTOR_CLASSES_CONFIG, interceptors);\n```\n### Producer 端拦截器\n\nAddTimeStampInterceptor 和 UpdateCounterInterceptor 类继承 org.apache.kafka.clients.producer.ProducerInterceptor 接口实现。该接口是 Kafka 提供的，里面有两个核心的方法。\n1. onSend：该方法会在消息发送之前被调用。如果你想在发送之前对消息“美美容”，这个方法是你唯一的机会。\n2. onAcknowledgement：该方法会在消息成功提交或发送失败之后被调用。还记得我在上一期中提到的发送回调通知 callback 吗？onAcknowledgement 的调用要早于 callback 的调用。值得注意的是，这个方法和 onSend 不是在同一个线程中被调用的，因此如果你在这两个方法中调用了某个共享可变对象，一定要保证线程安全哦。还有一点很重要，这个方法处在 Producer 发送的主路径中，所以最好别放一些太重的逻辑进去，否则你会发现你的 Producer TPS 直线下降。\n\n### Consumer 端拦截器\n\n指定消费者拦截器也是同样的方法，只是具体的实现类要实现 org.apache.kafka.clients.consumer.ConsumerInterceptor 接口，这里面也有两个核心方法。\n1. onConsume：该方法在消息返回给 Consumer 程序之前调用。也就是说在开始正式处理消息之前，拦截器会先拦一道，搞一些事情，之后再返回给你。\n2. onCommit：Consumer 在提交位移之后调用该方法。通常你可以在该方法中做一些记账类的动作，比如打日志等。\n\n### 拦截器使用场景\n\nKafka 拦截器可以应用于包括客户端监控、端到端系统性能检测、消息审计等多种功能在内的场景。\n\n\n### 拦截器案例\n\n**需求：** 某个业务只有一个 Producer 和一个 Consumer，他们想知道该业务消息从被生产出来到最后被消费的平均总时长是多少，但是目前 Kafka 并没有提供这种端到端的延时统计。\n\n**解决思路：** 使用 Redis 保存总时延，平均时延 = 总时延 / 消息数；\n\n\n#### 生产者拦截器\n```java\n\n```\n\n#### 消费者拦截器\n```java\n\n```\n\n## 第六章 Java生产者是如何管理TCP连接的\n\nApache Kafka 的所有通信都是基于 TCP 的。无论是生产者、消费者，还是 Broker 之间的通信都是如此。\n\n### Kafka 生产者程序概览\nKafka 的 Java 生产者 API 主要的对象就是 KafkaProducer。通常我们开发一个生产者的步骤有 4 步。\n- 第 1 步：构造生产者对象所需的参数对象。\n- 第 2 步：利用第 1 步的参数对象，创建 KafkaProducer 对象实例。\n- 第 3 步：使用 KafkaProducer 的 send 方法发送消息。\n- 第 4 步：调用 KafkaProducer 的 close 方法关闭生产者并释放各种系统资源。上面这 4 步写成 Java 代码的话大概是这个样子：\n\n```java\nProperties props = new Properties ();\nprops.put(“参数1”, “参数1的值”)；\nprops.put(“参数2”, “参数2的值”)；\n……\ntry (Producer<String, String> producer = new KafkaProducer<>(props)) {\n    producer.send(new ProducerRecord<String, String>(……), callback);\n    ……\n}\n```\n\n### 何时创建 TCP 连接\n\n客户端向 Kafka 集群指定的 topic 发送消息时会与 Kafka Broker 创建 TCP 连接。在创建 KafkaProducer 实例时，生产者应用会在后台创建并启动一个名为 Sender 的线程，该 Sender 线程开始运行时首先会创建与 Broker 的连接。\n\n在调用 send 方法前，Producer 不知道给哪个主题发消息，因此，Producer 启动时会连接 bootstrap.servers 参数指定的所有 Broker。（ps：bootstrap.servers 参数是 Producer 的核心参数之一，指定了这个 Producer 启动时要连接的 Broker 地址。）\n\n在实际使用过程中，并不建议把集群中所有的 Broker 信息都配置到 bootstrap.servers 中，通常指定 3～4 台就足以了。因为 Producer 一旦连接到集群中的任一台 Broker，就能拿到整个集群的 Broker 信息，故没必要为 bootstrap.servers 指定所有的 Broker。\n\n\n\n\n\n\n\n","tags":["Kafka","消息队列"],"categories":["Kafka"]},{"title":"记录一次SpirngBoot项目版本冲突","url":"/2022/05/09/记录一次SpirngBoot项目版本冲突/","content":"\n## 在使用 @NotEmpty 注解，发起请求时出现以下错误：\n```text\nHV000030:No validator could be found for constraint 'javax.validation.constraints.NotEmpty' validating type 'java.lang.String'. Check configuration for 'name'\n```\n\n代码如下：\n```java\nimport javax.validation.constraints.NotEmpty;\nimport javax.validation.constraints.NotNull;\n\n@Getter\n@Setter\n@ToString\npublic class NewCoffeeRequest {\n    @NotEmpty\n    private String name;\n    @NotNull\n    private Money price;\n}\n```\n\n@NotEmpty 本身只支持String类型的，但报错，考虑到版本问题。\n\n查看 pom.xml 发现存在版本冲突。\n![版本冲突](https://img2018.cnblogs.com/blog/280044/202001/280044-20200112172002066-1066604554.png)\n\n![Spring Web MVC 中的上下文层次结构](https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/images/mvc-contexts.gif)\n\n查看 spring boot 依赖的包版本。\n![](记录一次SpirngBoot项目版本冲突/1151652090011_.pic.jpg)\n\n\n发现时 2.0.1.Final，但 pom.xml 中指定为 1.1.0.Final ，因此将 pom.xml 改为 2.0.1.Final 即可。","tags":["SpringBoot","版本冲突"],"categories":["Debug"]},{"title":"java8新特性","url":"/2022/04/28/java8新特性/","content":"\n## java8 新特性\n\n- 接口的默认方法(Default Methods for Interfaces)\n- Lambda表达式\n- 函数式接口\n- 内置的函数式接口(Built-in Functional Interfaces)\n- Optional\n- Streams(流)\n- Parallel Streams(并行流)\n- Date API(日期相关API)\n- Annotations(注解)\n\n链接总结的很棒: [java8 新特性](https://github.com/Snailclimb/JavaGuide/blob/main/docs/java/new-features/java8-tutorial-translate.md)。\n\n### 1、接口的默认方法(Default Methods for Interfaces)\n\n```java\npackage com.learnjava.java8;\n\npublic class java8 {\n    public static void main(String[] args) {\n        Formula formula = new Formula() {\n            @Override\n            public double calculate(double a, double b) {\n                return a + b;\n            }\n        };\n        System.out.println(formula.calculate(10, 12));\n\n        //使用 default 关键字向接口添加的非抽象方法可以直接调用\n        System.out.println(formula.mul(10, 12));\n    }\n}\n\n@FunctionalInterface\ninterface Formula{\n    double calculate(double a, double b);\n    // Java 8使我们能够通过使用 default 关键字向接口添加非抽象方法实现。 此功能也称为虚拟扩展方法。\n   default double mul(int a, int b){\n       return a*b;\n   }\n}\n```\n\n### 2、Lambda 表达式\n\n#### 一个简单的例子\n```java\npublic void lambda() {\n\t\tList<String> names = Arrays.asList(\"peter\", \"anna\", \"mike\", \"xenia\");\n\n\t\t// 写法一\n\t\tCollections.sort(names, new Comparator<String>() {\n\t\t\t@Override\n\t\t\tpublic int compare(String o1, String o2) {\n\t\t\t\treturn o2.compareTo(o1);\n\t\t\t}\n\t\t});\n\t\tnames.forEach(c -> log.info(c + \"  \"));\n\n\t\t// 写法二\n\t\tCollections.sort(names, (a, b) -> {\n\t\t\treturn b.compareTo(a);\n\t\t});\n\n\t\t// 写法三\n\t\tnames.sort((a, b) -> b.compareTo(a));\n\t}\n```\n\n#### lambda 表达式作用域\n可以直接在 lambda 表达式中访问 lambda 表达式外部的局部变量（注意和类变量和类属性区分），但不可以修改，其实就是会将次局部变量隐性的设置为final。\n```java\n@SpringBootApplication\n@Slf4j\npublic class javaDemoApplication implements CommandLineRunner{\n\n\tstatic int outerStaticNum;\n\tint outerNum;\n\n\tvoid testScopes() {\n\t\tConverter<Integer, String> stringConverter1 = (from) -> {\n\t\t\touterNum = 23;  // 修改类属性(成员变量)\n\t\t\treturn String.valueOf(from);\n\t\t};\n        log.info(stringConverter1.Converter(1));\n\n\t\tConverter<Integer, String> stringConverter2 = (from) -> {\n\t\t\touterStaticNum = 72;    // 修改类变量\n\t\t\treturn String.valueOf(from);\n\t\t};\n        log.info(stringConverter2.Converter(2));\n\n\n\t\tint num = 10; // lambda 表达式外部的局部变量\n\t\tConverter<Integer, String> stringConverter3 = (from) -> {\n//\t\t\tnum = 72; // 可以访问，但是修改会报错\n            log.info(String.valueOf(num));\n\t\t\treturn String.valueOf(from);\n\t\t};\n        log.info(stringConverter3.Converter(3));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(javaDemoApplication.class, args);\n\t}\n\n\t@Override\n\tpublic void run(String... args) throws Exception {\n\t\ttestScopes();\n\t}\n}\n\n@FunctionalInterface\ninterface Converter<F, T> {\n\tT Converter(F from);\t// 只能有一个抽象方法\n\n\t/*\n\t* 可以有多个非抽象方法\n\t* */\n\tdefault int add(int a){\n\t\treturn a + 10;\n\t}\n\n\tdefault int mul(int a, int b){\n\t\treturn a * 10;\n\t}\n}\n```\n\n### 3、函数式接口\n\n函数式接口主要用于搭配 lambda 表达式使用。“函数式接口”是指仅仅只包含一个抽象方法的接口。 像这样的接口，可以被隐式转换为lambda表达式。java.lang.Runnable 与 java.util.concurrent.Callable 是函数式接口最典型的两个例子。只要接口只包含一个抽象方法，虚拟机会自动判断该接口为函数式接口。大部分函数式接口都不用我们自己写，Java8都给我们实现好了，这些接口都在java.util.function包里。（from Guide）\n\n#### 函数式接口使用例子\n```java\n@SpringBootApplication\n@Slf4j\npublic class javaDemoApplication implements CommandLineRunner{\n\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(javaDemoApplication.class, args);\n\t}\n\n\t@Override\n\tpublic void run(String... args) throws Exception {\n        /*\n\t\t* 方法一：Lambda 形式实现函数式接口\n\t\t* */\n\n\t\t// 方法一的非简化版本\n//\t\tConverter<String, Integer> converter = (from) -> {\n//\t\t\treturn Integer.valueOf(from);\n//\t\t};\n\n\t\t// 方法一的简化版本\n\t\tConverter<String, Integer> converter = (from) -> Integer.valueOf(from);\n\n\n\t\t// 方法一使用函数式接口\n\t\tInteger to = converter.Converter(\"12\");\n\t\tlog.info(String.valueOf(to));\n\n        /*\n\t\t* 方法二: 非 Lambda 形式实现函数式接口使用函数式接口\n\t\t* */\n\t\tConverter<String, Integer> converter2 = new Converter<String, Integer>() {\n\t\t\t@Override\n\t\t\tpublic Integer Converter(String from) {\n\t\t\t\treturn Integer.valueOf(from);\n\t\t\t}\n\t\t};\n\t\tconverter2.Converter(\"12\");\n\t\tlog.info(String.valueOf(to));\n\t}\n}\n\n// 定义函数式接口\n@FunctionalInterface\ninterface Converter<F, T> {\n\tT Converter(F from);\n}\n```\n\n#### 内置的函数式接口(Built-in Functional Interfaces)\n- Predicate\n- Function\n- Supplier\n- Consumer\n- Comparator\n\n### 4、Optional\nOptional不是函数式接口，而是用于防止 NullPointerException 的漂亮工具。Optional 是一个简单的容器，在Java 8 之前一般某个函数应该返回非空对象但是有时却什么也没有返回，而在Java 8 中，你应该返回 Optional 而不是 null。（from Guide）\n```java\n//为非null的值创建一个Optional\nOptional<String> optional = Optional.of(\"bam\");\n\n//如果Optional实例有值则为其调用consumer，否则不做处理\noptional.ifPresent((s) -> System.out.println(s.charAt(0)));     // \"b\"\n\n// 如果值存在返回true，否则返回false\noptional.isPresent();           // true\n\n//如果Optional有值则将其返回，否则抛出NoSuchElementException\noptional.get();                 // \"bam\"\n\n//如果有值则将其返回，否则返回指定的其它值\noptional.orElse(\"fallback\");    // \"bam\"\n```\n强烈推荐 [Java8 如何正确使用 Optional](https://blog.kaaass.net/archives/764)\n\n### 5、Streams(流)\n在 java.util.Stream 包中实现，可以分为中间操作和最终操作两类。\n- 中间操作：中间操作返回Stream本身。包含的方法有：Filter、Sorted、Map\n- 最终操作：最终操作返回一特定类型的计算结果。包含的方法有：Match、Count、Reduce\n  \nStream 的创建需要指定一个数据源，比如 java.util.Collection 的子类，List 或者 Set， Map 不支持。Map接口本身没有可用的 stream()方法，但是你可以在键，值上创建专门的流或者通过 map.keySet().stream(),map.values().stream()和map.entrySet().stream()。Stream 的操作可以串行执行或者并行执行。\n\n#### Streams 应用实例\n```java\npublic void stream(){\n        List<String> stringList = new ArrayList<>();\n        stringList.add(\"ddd2\");\n        stringList.add(\"aaa2\");\n        stringList.add(\"bbb1\");\n        stringList.add(\"aaa1\");\n        stringList.add(\"bbb3\");\n        stringList.add(\"ccc\");\n        stringList.add(\"bbb2\");\n        stringList.add(\"ddd1\");\n\n        // Filter\n        stringList.stream().filter(s -> s.startsWith(\"a\")).forEach(s -> System.out.println(s));\n        System.out.println();\n\n        // Sorted\n        stringList.stream().sorted().filter(s -> s.startsWith(\"a\")).forEach(s -> System.out.println(s));\n        System.out.println();\n\n        // Map 通过map来将对象转换成其他类型\n        stringList.stream().map(s -> s.toUpperCase()).sorted().forEach(s -> System.out.println(s));\n        System.out.println();\n\n        // Match\n        boolean anyStartWithA = stringList.stream().anyMatch(s -> s.startsWith(\"a\"));\n        System.out.println(anyStartWithA);  // true\n\n        boolean allStartWithA = stringList.stream().allMatch(s -> s.startsWith(\"a\"));\n        System.out.println(allStartWithA);  // false\n\n        // Count\n        long startWithB = stringList.stream().filter(s -> s.startsWith(\"b\")).count();\n        System.out.println(startWithB);\n        System.out.println();\n\n        // Reduce\n\t\t// 方法一\n\t\tOptional<String> reduced =\n        stringList\n                .stream()\n                .sorted()\n                .reduce((s1, s2) -> s1 + \"#\" + s2);\n\n        reduced.ifPresent(s -> System.out.println(s.toString()));\n        // 方法二\n        stringList.stream().sorted().reduce(new BinaryOperator<String>() {\n            @Override\n            public String apply(String s, String s2) {\n                s = s + \"#\" + s2;\n                return s;\n            }\n        });\n        reduced.ifPresent(s -> System.out.println(s.toString()));\n    }\n```\n\n#### Parallel Streams (并行流)\n```java\npublic void testParallelStreams(){\n\t\t// 创建一个没有重复元素的大表：\n\t\tint max = 10;\n\t\tList<String> values = new ArrayList<>(max);\n\t\tfor (int i = 0; i < max; i++) {\n\t\t\tUUID uuid = UUID.randomUUID();\n\t\t\tvalues.add(uuid.toString());\n\t\t}\n\n\t\t// 并行排序\n\t\tparallelSort(values);\n\n\t\t// 串行排序\n\t\tsequentialSort(values);\n\n\t}\n\n\tpublic void sequentialSort(List<String> values){\n\t\tlong start = System.nanoTime();\n\t\tlong count = values.stream().sorted((a, b) -> a.compareTo(b)).count();\n\t\tlog.info(String.valueOf(count));\n\t\tlong end = System.nanoTime();\n\n\t\tlong millis = TimeUnit.NANOSECONDS.toMillis(end - start);\n\t\tlog.info(String.format(\"sequential sort took: %d ms\", millis)); // sequential sort took: 2020 ms\n\t}\n\n\tpublic void parallelSort(List<String> values){\n\t\tlong start = System.nanoTime();\n\t\tlong count = values.parallelStream().sorted((a, b) -> a.compareTo(b)).count();\n\t\tlog.info(String.valueOf(count));\n\t\tlong end = System.nanoTime();\n\n\t\tlong millis = TimeUnit.NANOSECONDS.toMillis(end - start);\n\t\tlog.info(String.format(\"parallel sort took: %d ms\", millis)); // parallel sort took: 653 ms\n\t}\n```\n\n### 6、Parallel Streams(并行流)\n\n### 7、Date API\n- java.util.Date（处理麻烦，不推荐）\n- java.sql.Date（适用于Sql）\n- java.util.Calendar（线程不安全）\n- java 8新版的API（推荐使用）\n\n参考[Java 日期相关的几种API](https://blog.csdn.net/c_o_d_e_/article/details/113576761)\n\n### 8、Annotations(注解)\nJava 8允许我们把同一个类型的注解使用多次，只需要给该注解标注一下`@Repeatable`即可。\n\n#### 多重注解实例\n```java\n@SpringBootApplication\n@Slf4j\npublic class javaDemoApplication implements CommandLineRunner{\n\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(javaDemoApplication.class, args);\n\t}\n\n\t@Override\n\tpublic void run(String... args) throws Exception {\n\t\ttestAnnotations();\n\t}\n\n\n\tpublic void testAnnotations(){\n\t\t/*\n\t\t* java 8 多重注解用法\n\t\t* */\n\t\t// 正确方法一：使用反射获取注解信息\n\t\tHint[] hints = Test.class.getAnnotationsByType(Hint.class);\n\t\tlog.info(String.valueOf(hints.length)); // 2\n\n\t\t// 正确方法二：使用反射获取注解信息\n\t\tHints hints1 = Test.class.getAnnotation(Hints.class);\n\t\tint len = hints1.value().length;\n\t\tlog.info(String.valueOf(len)); // 2\n\n\t\t// 错误方法二：使用反射获取注解信息\n\t\tHint hint = Test.class.getAnnotation(Hint.class);\n\t\tlog.info(String.valueOf(hint)); // null\n\n\t\t/*\n\t\t* java 8 之前注解用法。\n\t\t* */\n\t\tHint[] hints2 = Test2.class.getAnnotationsByType(Hint.class);\n\t\tlog.info(String.valueOf(hints2.length)); // 2\n\t}\n}\n\n/*\n* 定义注解\n* */\n\n// RetentionPolicy.SOURCE：注解只保留在源文件，当Java文件编译成class文件的时候，注解被遗弃；\n// RetentionPolicy.CLASS：注解被保留到class文件，但jvm加载class文件时候被遗弃，这是默认的生命周期；\n// RetentionPolicy.RUNTIME：注解不仅被保存到class文件中，jvm加载class文件之后，仍然存在；\n@Retention(RetentionPolicy.RUNTIME)\n@interface Hints {\n\tHint[] value();\n}\n\n// Java 8允许我们把同一个类型的注解使用多次，只需要给该注解标注一下@Repeatable即可。\n@Repeatable(Hints.class)\n@interface Hint{\n\tString value();\n}\n\n/*\n * java 8 多重注解\n * */\n@Hint(\"hint1\")\n@Hint(\"hint2\")\nclass Test{\n}\n\n/*\n* java 8 之前注解\n* */\n@Hints({@Hint(\"hint1\"), @Hint(\"hint2\")})\nclass Test2 {}\n```\n\n\n\n\n\n\n\n","tags":["java"],"categories":["java 语言"]},{"title":"gulimall配置","url":"/2022/04/20/gulimall配置/","content":"\n## 1、环境配置\n\n- 项目结构搭建\n- 配置Mysql\n- 配置renren-fast和renren-fast-vue\n\n\n\n高版本的springboot默认不加载bootstrap.yml文件，需要在pom里加上依赖。\n\n```java\n  <dependency>\n   <groupId>org.springframework.cloud</groupId>\n   <artifactId>spring-cloud-starter-bootstrap</artifactId>\n  </dependency>\n```\n","tags":["java"],"categories":["项目相关"]},{"title":"开发环境安装杂项","url":"/2022/04/18/开发环境安装杂项/","content":"\n## 1、配置git\n\n- 生成ssh\n- 配置到github\n- 测试\n\n### 生成ssh\n\n```shell\nssh-keygen -t rsa -C \"jiaoqiang2014@163.com\"\n```\n\n### 配置到github\n\n在`~/.ssh`目录下生成`id_rsa.pub`和`id_rsa`公钥和私钥。打开公钥，复制到github\n\n```shell\ncat /Users/jq/.ssh/id_rsa.pub\n```\n\n### 测试连接\n\n```shell\nsudo ssh -T git@github.com\n```\n**PS：**git clone 的时候有 https 和 ssh 两种方式，如果使用 https 会要求你输入账号和密码。\n\n## 配置两个 git 账号\n\n一个是公司的git账号，另一个是github的。\n\n### 生成ssh\n生成ssh时要主要使用不同的命名，以区分不同的账号。\n\n```shell\nssh-keygen -t rsa -C \"jiaoqiang2014@163.com\"\nssh-keygen -t rsa -C \"XXXX@XXX\"\n```\n\n### 配置两个账号的 ssh\n在`~/.ssh`路径下生成一个`config`文件。（其中Host和HostName填写git服务器的域名，IdentityFile指定私钥的路径）内容如下：\n\n```xml\n# 公司\nHost gitee.com\nHostName gitee.com\nPreferredAuthentications publickey\nIdentityFile ~/.ssh/id_rsa_gitee\n\n# github\nHost github.com\nHostName github.com\nPreferredAuthentications publickey\nIdentityFile ~/.ssh/id_rsa_github\n```\n\n### 用ssh命令分别测试\n\n```shell\nssh -T git@gitee.com\nssh -T git@github.com\n```\n\n如果显示`Hi jiaoqiang2014! You've successfully authenticated, but GitHub does not provide shell access.`表示，使用https没有使用ssh，切换到项目`.git`同级目录下，设置一下使用ssh就行。\n\n```shell\ngit remote set-url origin git@github.com:lut/EvolutionApp.git\n```\n\n## 2、docker 安装\n\n使用官方 docker doc 说明安装。\n\n### 设置docker开机自启动\n\n```shell\nsudo systemctl enable docker\n```\n\n### docker安装mysql\n\n#### 正常芯片\n\n```shell\nsudo docker pull mysql:8.0.28\n```\n\n#### M1芯片\n\n```shell\nsudo docker pull --platform linux/x86_64 mysql:8.0.28\n```\n\n### 查看安装的服务\n\n```shell\nsudo docker images\n```\n\n### 删除容器\n```shell\ndocker container rm <container id>\n```\n\n### 删除镜像\n```shell\ndocker image rm <image id>\n```\n\n### docker 启动 mysql\n\n```shell\nsudo docker run -p 3306:3306 --name mysql \\\n-v /var/mysql/log:/var/log/mysql \\\n-v /var/mysql/data:/var/lib/mysql \\\n-v /var/mysql/conf:/etc/mysql \\\n-e MYSQL_ROOT_PASSWORD=123456aa \\\n-d mysql:8\n```\n\n上面代码不知道为啥启动不了\n\n```shell\ndocker run -p 3306:3306 --name mysql -e MYSQL_ROOT_PASSWORD=123456aa -d mysql:8\n```\n\n### 启动mysql容器\n\n```shell\ndocker start mysql\n```\n\n### 进入 Mysql 容器\n\n```shell\ndocker exec -it mysql bash\n```\n\n### navicat 连接 docker mysql\n\n在腾讯云选择该服务器——>管理->防火墙中需要添加 mysql 3306端口的规则，不然会被屏蔽。\n\n### 安装redis\n\n```shell\ndocker pull redis\nmkdir -p /mydata/redis/conf\ntouch /mydata/redis/conf\n```\n\n启动 redis 镜像\n\n```shell\ndocker run -p 6379:6379 --name redis \\\n-v /mydata/redis/data:/data \\\n-v /mydata/redis/conf/redis.conf:/etc/redis/redis.conf \\\n-d redis redis-server /etc/redis/redis.conf\n```\n\n检查redis安装是否成功\n\n```shell\ndocker exec -it redis redis-cli\nauth 123456\nset key1 111\nget key1\n```\n\n#### 持久化redis\n\nredis重启之后会丢失内存中的数据，可以设置持久化到磁盘中。\n\n```shell\nvim /mydata/redis/conf/redis.conf\n```\n\n添加以下内容。\n\n```shell\nappendonly yes\nbind 0.0.0.0 -::1\nrequirepass 123456\n```\n\n给redis存值，重启，检查是否还存在。开启服务端TCP的6379端口。\n\n### docker 服务器重启自动启动程序\n\n```shell\nsudo docker update mysql --restart=always\n```\n\n## 3、前端项目配置杂项\n\n在项目目录下下载需要的组件。\n\n```shell\nnmp install\n```\n\n报错\n\n```shell\nnpm ERR! command failed\nnpm ERR! command sh -c node install.js\nnpm ERR! Only Mac 64 bits supported.\n```\n\n使用下面命令可以解决。\n\n```shell\nnpm install --ignore-scripts\nnpm uninstall node-saas      //卸载node -saas\nnpm install node-sass --save-dev      //重新安装node -saas\n```\n\n运行前端项目\n\n```shell\nnpm run dev\n```\n\n如果报错可以试试下面代码。\n\n```shell\nnpm cache --force clean && npm install --force node-sass\n```\n\n## 4、renrenfast 生成","tags":["git","docker"],"categories":["杂项"]},{"title":"玩转Spring全家桶学习笔记","url":"/2022/04/17/玩转Spring全家桶学习笔记/","content":"\n## 第二章 JDBC必知必会\n\n### 1、配置单个数据源\n\n建立h2、web、lombak的springboot。\n```java\npackage com.example.learn;\nimport com.example.learn.config.ProfileProperties;\nimport com.example.learn.service.LibraryProperties;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.beans.factory.InitializingBean;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.CommandLineRunner;\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.EnableAutoConfiguration;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration;\nimport org.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration;\nimport org.springframework.boot.autoconfigure.jdbc.JdbcTemplateAutoConfiguration;\nimport org.springframework.boot.context.properties.EnableConfigurationProperties;\nimport org.springframework.jdbc.core.JdbcTemplate;\n\nimport javax.sql.DataSource;\nimport java.sql.Connection;\nimport java.sql.SQLException;\n\n@SpringBootApplication()\npublic class DemoApplication implements CommandLineRunner {\n\n\tprivate static final Logger log = LoggerFactory.getLogger(DemoApplication.class);\n\n\t@Autowired\n\tDataSource dataSource;\n\n\t@Autowired\n\tJdbcTemplate jdbcTemplate;\n\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(DemoApplication.class, args);\n\n\t}\n\n\t@Override\n\tpublic void run(String... args) throws Exception {\n\t\tshowConnection();\n\t\tshowData();\n\t}\n\n\tprivate void showData() {\n\t\tjdbcTemplate.queryForList(\"SELECT * FROM FOO\").forEach(row -> log.info(row.toString()));\n\t}\n\n\tprivate void showConnection() throws SQLException {\n\t\tlog.info(dataSource.toString());\n\t\tConnection conn = dataSource.getConnection();\n\t\tlog.info(conn.toString());\n\t\tconn.close();\n\t}\n}\n```\n在resource目录先创建schema.sql文件，写入：\n```sql\nCREATE TABLE FOO (ID INT IDENTITY, BAR VARCHAR(64));\n```\n\n在resource目录先创建data.sql文件，写入：\n```sql\nINSERT INTO FOO (ID, BAR) VALUES(1, 'aaa')\nINSERT INTO FOO (ID, BAR) VALUES(2, 'bbb')\n```\n\n\n### 2、配置多个数据源\n\n配置文件`application.properties`中写入数据源的信息。\n```java\nfoo.datasource.url=jdbc:h2:mem:foo\nfoo.datasource.username=sa\nfoo.datasource.password=\n\nbar.datasource.url=jdbc:h2:mem:bar\nbar.datasource.username=sa\nbar.datasource.password=\n```\n\n需要指定使用什么连接池：COMMONS-DBCP、TOMCAT-JDBC、HIKARICP。\n```xml\n\t\t<dependency>\n\t\t\t<groupId>com.zaxxer</groupId>\n\t\t\t<artifactId>HikariCP</artifactId>\n\t\t\t<version>3.2.0</version>\n\t\t</dependency>\n```\n\n配置数据源\n```java\npackage multiDatasource;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.CommandLineRunner;\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration;\nimport org.springframework.boot.autoconfigure.jdbc.DataSourceProperties;\nimport org.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration;\nimport org.springframework.boot.autoconfigure.jdbc.JdbcTemplateAutoConfiguration;\nimport org.springframework.boot.context.properties.ConfigurationProperties;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.jdbc.core.JdbcTemplate;\nimport org.springframework.jdbc.datasource.DataSourceTransactionManager;\nimport org.springframework.transaction.PlatformTransactionManager;\n\nimport javax.annotation.Resource;\nimport javax.sql.DataSource;\nimport java.sql.Connection;\nimport java.sql.SQLException;\n\n// 排除自动配置，进行手动配置\n@SpringBootApplication(exclude = {DataSourceAutoConfiguration.class,\n\t\tDataSourceTransactionManagerAutoConfiguration.class,\n\t\tJdbcTemplateAutoConfiguration.class})\npublic class MultiDataSourceApplication {\n\n\tprivate static final Logger log = LoggerFactory.getLogger(MultiDataSourceApplication.class);\n\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(MultiDataSourceApplication.class, args);\n\n\t}\n\n\t@Bean\n\t@ConfigurationProperties(\"foo.datasource\")\n\tpublic DataSourceProperties fooDataSourceProperties(){\n\t\treturn new DataSourceProperties();\n\t}\n\n\t@Bean\n\tpublic DataSource fooDataSource(){\n\t\tDataSourceProperties dataSourceProperties = fooDataSourceProperties();\n\t\tlog.info(\"foo datasource:{}\", dataSourceProperties.getUrl());\n\t\treturn dataSourceProperties.initializeDataSourceBuilder().build();\n\t}\n\n\t@Bean\n\t@Resource\n\tpublic PlatformTransactionManager fooTxManager(DataSource fooDataSource){\n\t\treturn new DataSourceTransactionManager(fooDataSource);\n\t}\n\n\n\t@Bean\n\t@ConfigurationProperties(\"bar.datasource\")\n\tpublic DataSourceProperties barDataSourceProperties(){\n\t\treturn new DataSourceProperties();\n\t}\n\n\t@Bean\n\tpublic DataSource barDataSource(){\n\t\tDataSourceProperties dataSourceProperties = barDataSourceProperties();\n\t\tlog.info(\"bar datasource:{}\", dataSourceProperties.getUrl());\n\t\treturn dataSourceProperties.initializeDataSourceBuilder().build();\n\t}\n\n\t@Bean\n\t@Resource\n\tpublic PlatformTransactionManager barTxManager(DataSource barDataSource){\n\t\treturn new DataSourceTransactionManager(barDataSource);\n\t}\n}\n```\n\n### 3、数据库连接池推荐\n- druid：快\n- HikariCP：监控、SQL防注入\n\n### 4、JdbcTemplate 的使用\n\n首先，添加H2数据库的依赖。\n```xml\n\t\t<dependency>\n\t\t\t<groupId>com.h2database</groupId>\n\t\t\t<artifactId>h2</artifactId>\n\t\t\t<scope>runtime</scope>\n\t\t</dependency>\n```\n\n然后,创建和表对应的Entiy。\n```java\n@Data\n@Builder\npublic class Foo {\n\n    private Long id;\n    private String bar;\n}\n```\n\n接下来，完成数据库的查询，添加等功能。\n```java\npackage simplejdbcdemo;\n\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.jdbc.core.JdbcTemplate;\nimport org.springframework.jdbc.core.RowMapper;\nimport org.springframework.jdbc.core.simple.SimpleJdbcInsert;\nimport org.springframework.stereotype.Repository;\n\nimport javax.swing.*;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\n\n@Slf4j\n@Repository\npublic class FooDao {\n    @Autowired\n    private JdbcTemplate jdbcTemplate;\n    @Autowired\n    private SimpleJdbcInsert simpleJdbcInsert;\n\n    public void insertData(){\n\t\t// 方法一：使用jdbcTemplate\n        Arrays.asList(\"a\", \"b\").forEach(bar -> {\n            jdbcTemplate.update(\"insert into Foo (bar) values (?)\", bar);\n        });\n\n\t\t//方法二：使用simpleJdbcInsert\n\t\tHashMap<String, String> row = new HashMap<>();\n        row.put(\"bar\", \"d\");\n        Number id = simpleJdbcInsert.executeAndReturnKey(row);\n        log.info(\"ID of d: {}\", id.longValue());\n    }\n\n    public void listData(){\n        log.info(\"Count: {}\",jdbcTemplate.queryForObject(\"select count(*) from foo\", Long.class));\n\n        List<String> list = jdbcTemplate.queryForList(\"select bar from foo\", String.class);\n        list.forEach(s -> {log.info(\"Bar: {}\", s);});\n\n        List<Foo> fooList = jdbcTemplate.query(\"select * from foo\", new RowMapper<Foo>() {\n            @Override\n            public Foo mapRow(ResultSet rs, int rowNum) throws SQLException {\n                return Foo.builder().id(rs.getLong(1)).bar(rs.getString(2)).build();\n            }\n        });\n        fooList.forEach(f -> log.info(\"Foo: {}\", f));\n    }\n}\n```\n\n最后，在程序入口调用数据库操作。\n```java\npackage simplejdbcdemo;\n\nimport lombok.extern.slf4j.Slf4j;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.CommandLineRunner;\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.jdbc.core.JdbcTemplate;\nimport org.springframework.jdbc.core.simple.SimpleJdbcInsert;\n\n@Slf4j\n@SpringBootApplication\npublic class SiampleJdbcDemoApplication implements CommandLineRunner {\n\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(SiampleJdbcDemoApplication.class, args);\n\t}\n\n\t@Autowired\n\tFooDao fooDao;\n\n\t@Bean\n\t@Autowired\n\tpublic SimpleJdbcInsert simpleJdbcInsert(JdbcTemplate jdbcTemplate) {\n\t\t// 将 FOO 和 ID 绑定。\n\t\treturn new SimpleJdbcInsert(jdbcTemplate)\n\t\t\t\t.withTableName(\"FOO\").usingGeneratedKeyColumns(\"ID\");\n\t}\n\n\t@Override\n\tpublic void run(String... args) throws Exception {\n\t\tfooDao.insertData();\n\t\tfooDao.listData();\n\t}\n}\n```\n\n### 5、NamedParameterJdbcTemplate\n\n\n### 6、事务\n- 编程式事务\n- 声明式事务（推荐使用）\n#### 编程式事务\n- TransactionTemplate\n- PlatformTransactionTemplate  \n\n引入H2数据库的依赖。\n```java\npackage transaction;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.CommandLineRunner;\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.jdbc.core.JdbcTemplate;\nimport org.springframework.transaction.TransactionStatus;\nimport org.springframework.transaction.support.TransactionCallbackWithoutResult;\nimport org.springframework.transaction.support.TransactionTemplate;\n\nimport javax.sql.DataSource;\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\n\n@SpringBootApplication()\npublic class TransactionDemoApplication implements CommandLineRunner {\n\n\tprivate static final Logger log = LoggerFactory.getLogger(TransactionDemoApplication.class);\n\n\t@Autowired\n\tJdbcTemplate jdbcTemplate;\n\t@Autowired\n\tTransactionTemplate transactionTemplate;\n\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(TransactionDemoApplication.class, args);\n\n\t}\n\n\t@Override\n\tpublic void run(String... args) throws Exception {\n\t\tlog.info(\"count before transaction: {}\", getCount());\n\n\t\ttransactionTemplate.execute(new TransactionCallbackWithoutResult() {\n\t\t\t@Override\n\t\t\tprotected void doInTransactionWithoutResult(TransactionStatus status) {\n\t\t\t\tjdbcTemplate.execute(\"INSERT INTO FOO (ID, BAR) VALUES (1, 'AAA')\");\n\t\t\t\tlog.info(\"count in transaction: {}\", getCount());\n\t\t\t\tstatus.setRollbackOnly();\n\t\t\t}\n\t\t});\n\n\t\tlog.info(\"count after transaction: {}\", getCount());\n\t}\n\n\tprivate long getCount(){\n//\t\tList<Integer> list = jdbcTemplate.queryForList(\"select count(*) as cnt from FOO\", Integer.class);\n//\t\tlog.info(String.valueOf(list.get(0)));\n\t\treturn (long)jdbcTemplate.queryForList(\"select count(*) as cnt from FOO\").get(0).get(\"cnt\");\n\t}\n}\n\n```\n\n#### 声明式事务\n在 XML 配置文件中配置或者基于注解，实际是通过 AOP 实现（基于@Transactional 的全注解方式使用最多）。\n\n测试声明式事务核心方法。\n```java\npackage DeclarativeTransaction;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.jdbc.core.JdbcTemplate;\nimport org.springframework.stereotype.Component;\nimport org.springframework.transaction.annotation.Transactional;\n\n@Component\npublic class FooServiceImpl implements FooService {\n\n    @Autowired\n    JdbcTemplate jdbcTemplate;\n\n\t@Autowired\n    FooService fooService;\n\n    @Override\n    @Transactional\n    public void insertRecord() {\n        jdbcTemplate.execute(\"INSERT INTO FOO (BAR) VALUES ('AAA')\");\n    }\n\n    @Override\n    @Transactional(rollbackFor = RollbackException.class)\n    public void insertThenRollback() throws RollbackException {\n        jdbcTemplate.execute(\"INSERT INTO FOO (BAR) VALUES ('BBB')\");\n        throw new RollbackException();\n    }\n\n    @Override\n    public void invokeInsertThenRollback() throws RollbackException {\n                // 思考这两个方法的不同。\n//        insertThenRollback();\n        fooService.insertThenRollback();\n    }\n}\n```\n\n开始调用时需要开启事务注解。\n```java\npackage DeclarativeTransaction;\n\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.CommandLineRunner;\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.context.annotation.AdviceMode;\nimport org.springframework.jdbc.core.JdbcTemplate;\nimport org.springframework.transaction.annotation.EnableTransactionManagement;\n\n@SpringBootApplication\n@Slf4j\n@EnableTransactionManagement(mode = AdviceMode.PROXY)   // 开启事务注解\npublic class DeclarativeTransactionDemoApplication implements CommandLineRunner {\n\n    @Autowired\n    FooService fooService;\n\n    @Autowired\n    JdbcTemplate jdbcTemplate;\n\n    public static void main(String[] args) {\n        SpringApplication.run(DeclarativeTransactionDemoApplication.class, args);\n\n    }\n\n    @Override\n    public void run(String... args) throws Exception {\n        fooService.insertRecord();\n        log.info(\"AAA: {}\", jdbcTemplate. queryForObject(\"SELECT COUNT(*) FROM FOO WHERE BAR='AAA'\", Long.class));\n\n        try {\n            fooService.insertThenRollback();\n        } catch (RollbackException e) {\n            log.info(\"BBB {}\",jdbcTemplate.queryForObject(\"SELECT COUNT(*) FROM FOO WHERE BAR='BBB'\", Long.class));\n        }\n\n        try {\n            fooService.invokeInsertThenRollback();\n        } catch (RollbackException e) {\n            log.info(\"BBB {}\",jdbcTemplate.queryForObject(\"SELECT COUNT(*) FROM FOO WHERE BAR='BBB'\", Long.class));\n        }\n    }\n}\n```\n\n定义的接口。\n```java\npackage DeclarativeTransaction;\n\npublic interface FooService {\n\n    public void insertRecord();\n    public void insertThenRollback() throws RollbackException;\n    public void invokeInsertThenRollback() throws RollbackException;\n}\n```\n\n定义的异常。\n```java\npackage DeclarativeTransaction;\n\npublic class RollbackException extends Throwable {\n}\n```\n\n#### 事务的传播特性\n**TransactionDefinition.PROPAGATION_REQUIRED**\n使用的最多的一个事务传播行为，我们平时经常使用的@Transactional注解默认使用就是这个事务传播行为。\n如果当前存在事务，则加入该事务，不会创建新事务；如果当前没有事务，则创建一个新的事务。\n\n**TransactionDefinition.PROPAGATION_REQUIRES_NEW**\n始终新起一个事务，两个事务没有关联。\n\n**TransactionDefinition.PROPAGATION_NESTED**\n- 有事务：在原事务内启动一个内嵌事务。两个事务有关联，外部事务回滚，内嵌事务也会回滚。\n\n**TransactionDefinition.PROPAGATION_MANDATORY**\n如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。（mandatory：强制性）\n\n代码实例如下：\n```java\npackage DeclarativeTransaction;\n\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.jdbc.core.JdbcTemplate;\nimport org.springframework.stereotype.Component;\nimport org.springframework.transaction.annotation.Propagation;\nimport org.springframework.transaction.annotation.Transactional;\n\n@Slf4j\n@Component\npublic class FooServiceImpl implements FooService {\n\n    @Autowired\n    JdbcTemplate jdbcTemplate;\n\n    @Autowired\n    FooService fooService;\n\n    @Override\n    @Transactional(rollbackFor = RollbackException.class, propagation = Propagation.REQUIRES_NEW)\n    public void insertThenRollback() throws RollbackException {\n        jdbcTemplate.execute(\"INSERT INTO FOO (BAR) VALUES ('BBB')\");\n        // throw new RollbackException();\n    }\n\n    @Override\n    @Transactional(rollbackFor = RollbackException.class)\n    public void invokeInsertThenRollback() throws RollbackException {\n        jdbcTemplate.execute(\"INSERT INTO FOO (BAR) VALUES ('AAA')\");\n        try {\n            fooService.insertThenRollback();\n        }catch (RollbackException e){\n            log.error(\"RollbackException\", e);\n        }\n        throw new RollbackException();\n    }\n}\n```\n\n![事务的传播特性](../../images/8d1542c72a220d01da05ce791304e2803b1fb05f16400305babfafdf9b0289bb.png)\n\n\n![事务的传播特性2](../../images/fe7f6ebc510e9a192a19749197febf38cb9950cebdeae177e6a9c8daf9d89287.png)  \n\n### 7、慢 SQL 日志\n\n开启慢 SQL 日志，设置超过 100ms 的sql为慢sql。\n```java\nspring.datasource.druid.filter.stat.log-slow-sql=true\nspring.datasource.druid.filter.stat.slow-sql-millis=100\n```\n\n测试代码如下：\n\n```java\n@Override\n@Transactional\npublic void selectForUpdate(){\n\tjdbcTemplate.queryForObject(\"select id from foo where id = 1 for update\", Long.class);\n\ttry{\n\t\tThread.sleep(200);\n\t}catch (InterruptedException e){\n\t}\n}\n```\n\n调用代码如下：\n```java\npackage DeclarativeTransaction;\n\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.CommandLineRunner;\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.context.annotation.AdviceMode;\nimport org.springframework.jdbc.core.JdbcTemplate;\nimport org.springframework.transaction.annotation.EnableTransactionManagement;\n\nimport javax.sql.DataSource;\n\n@SpringBootApplication\n@Slf4j\n@EnableTransactionManagement(mode = AdviceMode.PROXY)   // 开启事务注解\npublic class DeclarativeTransactionDemoApplication implements CommandLineRunner {\n\n    @Autowired\n    FooService fooService;\n\n    @Autowired\n    JdbcTemplate jdbcTemplate;\n\n    @Autowired\n    DataSource dataSource;\n\n    public static void main(String[] args) {\n        SpringApplication.run(DeclarativeTransactionDemoApplication.class, args);\n    }\n\n    @Override\n    public void run(String... args) throws Exception {\n        log.info(dataSource.toString());\n        new Thread(() -> fooService.selectForUpdate()).start();\n        new Thread(() -> fooService.selectForUpdate()).start();\n    }\n}\n```\n\n控制台输出\n```java\nc.alibaba.druid.filter.stat.StatFilter: slow sql 212 millis. select id from foo where id = 1 for update[]\n```\n\n## 第三章 O/R Mapping 实践\nORM（Object/Relational Mapping）\"对象-关系映射\"。简单说，ORM 就是通过实例对象的语法，完成关系型数据库的操作的技术。\n\n### 1、Spring Data JPA\nJava 持久层框架访问数据库的方式大致分为两种。一种以 SQL 核心，封装一定程度的 JDBC 操作，比如： MyBatis。另一种是以 Java 实体类为核心，将实体类的和数据库表之间建立映射关系，也就是我们说的ORM框架，如：Hibernate、Spring Data JPA（Java Persistence API Java持久层API）。\n\n**JPA、Hibernate、Spring Data JPA 之间的关系**\n- JPA 是Java EE 5规范中提出的Java持久化接口（规范）。\n- Hibernate 是 JPA 的一种实现，是一个框架。\n- Spring Data JPA 是一种 JPA 的抽象层，底层依赖Hibernate\n\n推荐阅读: [JPA、Hibernate、Spring Data JPA之间的关系](https://zhuanlan.zhihu.com/p/115507328)\n\n#### Spring Data JPA 提供的支持\n- @EnableJpaRepositories\n- Repository 接口：\n  - CrudRepository<T, ID>\n  - PagingAndSortingRepository<T, ID>\n  - JpaRepository<T, ID>\n- Repository 实现类：\n  - SimpleJpaRepository\n  - QueryDslJpaRepository\n\n### 2、使用 Spring Data JPA 操作数据库\n\n#### 创建实体（表）\n使用SpringBoot内嵌的H2数据库。创建一个咖啡表和一个咖啡订单表。\\\n**咖啡表**\n```java\npackage com.jq.coffe.model;\n\nimport lombok.*;\nimport lombok.extern.slf4j.Slf4j;\nimport org.hibernate.annotations.CreationTimestamp;\nimport org.hibernate.annotations.Type;\nimport org.hibernate.annotations.UpdateTimestamp;\nimport org.joda.money.Money;\n\nimport javax.persistence.*;\nimport java.io.Serializable;\nimport java.util.Date;\n\n@Data\n@Entity\t// 实体\n@Table(name = \"T_MENU\")\n@Builder  // @Builder声明表示实体可以使用Builder方式初始化\n@Slf4j\n@NoArgsConstructor\n@AllArgsConstructor\n@ToString(callSuper = true)\npublic class Coffee extends BaseEntity implements Serializable {\n\n    private String name;\n\n    @Column\n    @Type(type = \"org.jadira.usertype.moneyandcurrency.joda.PersistentMoneyMinorAmount\",\n    parameters = {@org.hibernate.annotations.Parameter(name = \"currencyCode\", value = \"CNY\")})\n    private Money price;\n}\n```\n\n**咖啡订单表**\n```java\npackage com.jq.coffe.model;\n\nimport com.jq.coffe.model.BaseEntity;\nimport com.jq.coffe.model.Coffee;\nimport com.jq.coffe.model.OrderState;\nimport lombok.AllArgsConstructor;\nimport lombok.Builder;\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\nimport lombok.ToString;\n\nimport javax.persistence.Column;\nimport javax.persistence.Entity;\nimport javax.persistence.Enumerated;\nimport javax.persistence.JoinTable;\nimport javax.persistence.ManyToMany;\nimport javax.persistence.OrderBy;\nimport javax.persistence.Table;\nimport java.io.Serializable;\nimport java.util.List;\n\n@Entity\n@Table(name = \"T_ORDER\")\n@Data\n@ToString(callSuper = true)\n@NoArgsConstructor\n@AllArgsConstructor\n@Builder\npublic class CoffeeOrder extends BaseEntity implements Serializable {\n    private String customer;\n    @ManyToMany\n    @JoinTable(name = \"T_ORDER_COFFEE\")\t// 创建一个 T_ORDER_COFFEE 表\n    @OrderBy(\"id\")\n    private List<Coffee> items;\n    @Enumerated\n    @Column(nullable = false)\t// 可以为空\n    private OrderState state;\n}\n```\n\n**父类**\n```java\npackage com.jq.coffe.model;\n\nimport lombok.AllArgsConstructor;\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\nimport org.hibernate.annotations.CreationTimestamp;\nimport org.hibernate.annotations.Type;\nimport org.hibernate.annotations.UpdateTimestamp;\nimport org.joda.money.Money;\n\nimport javax.persistence.*;\nimport java.io.Serializable;\nimport java.util.Date;\n\n// 编写一个父类,将这些共同属性放到这个父类中, 并且在父类上加上@MappedSuperclass注解.注意:标注为@MappedSuperclass的类将不是一个完整的实体类，他将不会映射到数据库表，但是他的属性都将映射到其子类的数据库字段中。\n@MappedSuperclass\t\n@Data\n@NoArgsConstructor\n@AllArgsConstructor\npublic class BaseEntity implements Serializable {\n    @Id\t// 表示主键\n    @GeneratedValue\t// 主键生成规则\n    private Long id;\n    @Column(updatable = false)\t// 不可以更新\n    @CreationTimestamp\n    private Date createTime;\n    @UpdateTimestamp\n    private Date updateTime;\n}\n```\n\n#### 实现 操作数据库的接口\n这些接口的命名是固定好的，只要按规定格式命名，Spring Boot JPA 就会帮我们做具体操作数据库的逻辑。\n```java\npackage com.jq.coffe.repository;\nimport org.springframework.data.repository.NoRepositoryBean;\nimport org.springframework.data.repository.PagingAndSortingRepository;\nimport java.util.List;\n\n@NoRepositoryBean   // 表示不会作为一个Bean\npublic interface BaseRepository<T, Long> extends PagingAndSortingRepository<T, Long> {\n    List<T> findTop3ByOrderByUpdateTimeDescIdAsc();\n}\n```\n\n**操作咖啡表的接口**\n```java\npackage com.jq.coffe.repository;\nimport com.jq.coffe.model.Coffee;\n\npublic interface CoffeeRepository extends BaseRepository<Coffee, Long> {\n}\n```\n\n**操作咖啡订单表的接口**\n```java\npackage com.jq.coffe.repository;\nimport com.jq.coffe.model.CoffeeOrder;\nimport org.springframework.data.repository.CrudRepository;\nimport java.util.List;\n\npublic interface CoffeeOrderRepository extends BaseRepository<CoffeeOrder, Long> {\n    List<CoffeeOrder> findByCustomerOrderById(String customer);\n    List<CoffeeOrder> findByItems_Name(String name);\n}\n```\n\n#### 测试代码\n```java\npackage com.jq.coffe;\n\nimport com.jq.coffe.model.Coffee;\nimport com.jq.coffe.model.CoffeeOrder;\nimport com.jq.coffe.model.OrderState;\nimport com.jq.coffe.repository.CoffeeOrderRepository;\nimport com.jq.coffe.repository.CoffeeRepository;\nimport lombok.extern.slf4j.Slf4j;\nimport org.joda.money.CurrencyUnit;\nimport org.joda.money.Money;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.ApplicationArguments;\nimport org.springframework.boot.ApplicationRunner;\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.data.domain.Sort;\nimport org.springframework.data.jpa.repository.config.EnableJpaRepositories;\nimport org.springframework.transaction.annotation.EnableTransactionManagement;\nimport org.springframework.transaction.annotation.Transactional;\n\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.stream.Collectors;\n\n@SpringBootApplication\n@Slf4j\n@EnableJpaRepositories\n@EnableTransactionManagement\npublic class CoffeApplication implements ApplicationRunner {\n\n\t@Autowired\n\tCoffeeRepository coffeeRepository;\n\n\t@Autowired\n\tCoffeeOrderRepository orderRepository;\n\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(CoffeApplication.class, args);\n\t}\n\n\t@Override\n\t@Transactional\n\tpublic void run(ApplicationArguments args) throws Exception {\n\t\tinitOrders();\n\t\tfindOrders();\n\t}\n\n\tprivate void initOrders(){\n\t\tCoffee espresso = Coffee.builder().name(\"espresso\")\n\t\t\t\t.price(Money.of(CurrencyUnit.of(\"CNY\"), 20.0))\n\t\t\t\t.build();\n\t\tcoffeeRepository.save(espresso);\n\t\tlog.info(\"Coffee: {}\", espresso);\n\n\t\tCoffee latte = Coffee.builder().name(\"latte\")\n\t\t\t\t.price(Money.of(CurrencyUnit.of(\"CNY\"), 30.0))\n\t\t\t\t.build();\n\t\tcoffeeRepository.save(latte);\n\t\tlog.info(\"Coffee: {}\", latte);\n\n\t\tCoffeeOrder order = CoffeeOrder.builder()\n\t\t\t\t.customer(\"Li Lei\")\n\t\t\t\t.items(Collections.singletonList(espresso))\t// 创建不可变List的单个元素\n\t\t\t\t.state(OrderState.INIT)\n\t\t\t\t.build();\n\t\torderRepository.save(order);\n\t\tlog.info(\"Order: {}\", order);\n\n\t\torder = CoffeeOrder.builder()\n\t\t\t\t.customer(\"Li Lei\")\n\t\t\t\t.items(Arrays.asList(espresso, latte))\n\t\t\t\t.state(OrderState.INIT)\n\t\t\t\t.build();\n\t\torderRepository.save(order);\n\t\tlog.info(\"Order: {}\", order);\n\t}\n\n\tprivate void findOrders() {\n\t\tcoffeeRepository\n\t\t\t\t.findAll(Sort.by(Sort.Direction.DESC, \"id\"))\n\t\t\t\t.forEach(c -> log.info(\"Loading {}\", c));\n\n\t\tList<CoffeeOrder> list = orderRepository.findTop3ByOrderByUpdateTimeDescIdAsc();\n\t\tlog.info(\"findTop3ByOrderByUpdateTimeDescIdAsc: {}\", getJoinedOrderId(list));\n\n\t\tlist = orderRepository.findByCustomerOrderById(\"Li Lei\");\n\t\tlog.info(\"findByCustomerOrderById: {}\", getJoinedOrderId(list));\n\n\t\t// 不开启事务会因为没Session而报LazyInitializationException\n\t\tlist.forEach(o -> {\n\t\t\tlog.info(\"Order {}\", o.getId());\n\t\t\to.getItems().forEach(i -> log.info(\"  Item {}\", i));\n\t\t});\n\n\t\tlist = orderRepository.findByItems_Name(\"latte\");\n\t\tlog.info(\"findByItems_Name: {}\", getJoinedOrderId(list));\n\t}\n\n\tprivate String getJoinedOrderId(List<CoffeeOrder> list) {\n\t\treturn list.stream().map(o -> o.getId().toString())\n\t\t\t\t.collect(Collectors.joining(\",\"));\n\t}\n}\n```\n\n\n### 3、MyBatis 操作数据库\n- [推荐阅读](https://www.cnblogs.com/ityouknow/p/6037431.html)\n- [代码仓库](https://gitee.com/geektime-geekbang/geektime-spring-family/tree/master/Chapter%203/mybatis-demo)\n  \n一款持久化框架，支持定制化SQL、存储过程和高级映射。JPA中SQL是框架自动生成的，MyBatis是自己手写的。结合 Mybatis 的官方 Demo 和文档可以将 Mybatis 的是用法总结为最简的两种模式：注解方式和XML方式。一般大型项目会使用XML方式，因为XML方式将SQL放在同一个XML文件中，方便对SQL进行优化。注解方式以注解形式将SQL添加在方法开头，开发方便，因此适合较小项目的开发。\n\n#### 注解方式\n定义`Coffee`，其中 Price 使用`Joda-Money`。\n```java\npackage com.example.mybatis.model;\n\nimport lombok.AllArgsConstructor;\nimport lombok.Builder;\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\nimport org.joda.money.Money;\n\nimport java.util.Date;\n\n@Data\n@AllArgsConstructor\n@NoArgsConstructor\n@Builder\npublic class Coffee {\n\n    private Long id;\n    private String name;\n    private Money price;\n    private Date createTime;\n    private Date updateTime;\n}\n```\n\n创建表：新建 schema.sql 文件\n```sql\ncreate table t_coffee (\n    id bigint not null auto_increment,\n    name varchar(255),\n    price bigint not null,\n    create_time timestamp,\n    update_time timestamp,\n    primary key (id)\n);\n```\n\n Mapper sql语句\n```java\npackage com.example.mybatis.mapper;\n\nimport com.example.mybatis.model.Coffee;\nimport org.apache.ibatis.annotations.*;\n\n@Mapper\npublic interface CoffeeMapper {\n\n    // insert into t_coffee (name, price, create_time, update_time) values (\"latte\",30.0, '2022-05-06', '2022-05-06');\n    @Insert(\"insert into t_coffee (name, price, create_time, update_time) values (#{name}, #{price}, #{createTime}, #{updateTime})\")\n    @Options(useGeneratedKeys = true, keyColumn = \"id\", keyProperty = \"id\") // 指定在数据库中的字段名 id，实例对象中主键的属性名 id。\n    int save(Coffee coffee);    // 返回的是变动记录的条数\n\n    // select * from t_coffee where id = #{id}\n    @Select(\"select * from t_coffee where id = #{id}\")\n    @Results({\n            @Result(id = true, column = \"id\", property = \"id\"),\n            @Result(column = \"create_time\", property = \"createTime\"), // 实例对象名字为 create_time，数据库中名字为 createTime。\n            // map-underscore-to-camel-case = true 可以实现一样的效果\n            // @Result(column = \"update_time\", property = \"updateTime\")\n    })\n    // @Param(\"id\")对应where id = #{id}里的#{id}，给个例子，万一大家以后变量名和参数名不一样，也好知道怎么写。\n    Coffee findById(@Param(\"id\") Long id);\n}\n```\n\n引入类型转换的配置\n```java\n# 表示是类型转化时包的前缀\nmybatis.type-handlers-package=com.example.mybatis.handler\n# 将下划线转化为驼峰规则\nmybatis.configuration.map-underscore-to-camel-case=true\n```\n\n定义自己的handle，用于处理Money的类型转换（类中使用 Money 类型的price，数据库中使用 bigint 类型的price）\n```java\npackage com.example.mybatis.handler;\n\nimport org.apache.ibatis.type.BaseTypeHandler;\nimport org.apache.ibatis.type.JdbcType;\nimport org.joda.money.CurrencyUnit;\nimport org.joda.money.Money;\n\nimport java.sql.CallableStatement;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\n\n/**\n * 类中使用 Money 类型的price，数据库中使用 bigint 类型的price。\n * mybatis在没有配置handler时，会根据参数或者返回结果的不同，默认为我们选择合适的TypeHandler处理。\n * 当我们需要特殊的字段处理时，可以配置自己的handler。\n * 首先，在配置文件中引入 配置的包。\n * 然后，实现 BaseTypeHandler 接口完成自己的类。\n * 在 Money 与 Long 之间转换的 TypeHandler，处理 CNY 人民币\n */\npublic class MoneyTypeHandler extends BaseTypeHandler<Money> {\n    @Override\n    public void setNonNullParameter(PreparedStatement ps, int i, Money parameter, JdbcType jdbcType) throws SQLException {\n        ps.setLong(i, parameter.getAmountMinorLong());\n    }\n\n    @Override\n    public Money getNullableResult(ResultSet rs, String columnName) throws SQLException {\n        return parseMoney(rs.getLong(columnName));\n    }\n\n    @Override\n    public Money getNullableResult(ResultSet rs, int columnIndex) throws SQLException {\n        return parseMoney(rs.getLong(columnIndex));\n    }\n\n    @Override\n    public Money getNullableResult(CallableStatement cs, int columnIndex) throws SQLException {\n        return parseMoney(cs.getLong(columnIndex));\n    }\n\n    private Money parseMoney(Long value) {\n        return Money.of(CurrencyUnit.of(\"CNY\"), value / 100.0);\n    }\n}\n```\n\n调用代码\n```java\npackage com.example.mybatis;\n\nimport com.example.mybatis.mapper.CoffeeMapper;\nimport com.example.mybatis.model.Coffee;\nimport lombok.extern.slf4j.Slf4j;\nimport org.apache.ibatis.annotations.Mapper;\nimport org.joda.money.CurrencyUnit;\nimport org.joda.money.Money;\nimport org.mybatis.spring.annotation.MapperScan;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.ApplicationArguments;\nimport org.springframework.boot.ApplicationRunner;\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\n@SpringBootApplication\n@Slf4j\n@MapperScan(\"com.example.mybatis.mapper\")\t// 扫描对应包里边的mapper映射\npublic class MybatisApplication implements ApplicationRunner {\n\n\t@Autowired\n\tCoffeeMapper coffeeMapper;\n\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(MybatisApplication.class, args);\n\t}\n\n\t@Override\n\tpublic void run(ApplicationArguments args) throws Exception {\n\n\t\t// 将 name 的值设置为 espresso，将price的值设置为 20.0。和sql中的${name}和${price}对应。\n\t\t// @Insert(\"insert into t_coffee (name, price, create_time, update_time) values (#{name}, #{price}, now(), now())\")\n\t\tCoffee coffee = Coffee.builder().name(\"espresso\")\n\t\t\t\t.price(Money.of(CurrencyUnit.of(\"CNY\"), 20.0))\n\t\t\t\t.createTime(new Date())\n\t\t\t\t.updateTime(new Date())\n\t\t\t\t.build();\n\t\tint count = coffeeMapper.save(coffee);\n\t\tlog.info(\"Save {} Coffee: {}\", count, coffee);\n\n\t\tcoffee = Coffee.builder().name(\"latte\")\n\t\t\t\t.price(Money.of(CurrencyUnit.of(\"CNY\"), 25.0))\n\t\t\t\t.createTime(new Date())\n\t\t\t\t.updateTime(new Date()).build();\n\t\tcount = coffeeMapper.save(coffee);\n\t\tlog.info(\"Save {} Coffee: {}\", count, coffee);\n\n\t\tcoffeeMapper.findById(coffee.getId());\n\t\tlog.info(\"Find Coffee: {}\", coffee);\n\t}\n}\n```\n\n#### XML 方式\n\n[代码](https://github.com/jiaoqiang2014/testMybatis)\n\n### 4、MaBatis Generator\n\n[代码仓库](https://gitee.com/geektime-geekbang/geektime-spring-family/tree/master/Chapter%203/mybatis-generator-demo)\n\n### 5、MaBatis PageHelper\n\n[代码仓库](https://gitee.com/geektime-geekbang/geektime-spring-family/tree/master/Chapter%203/mybatis-pagehelper-demo)\n\n## 第四章 NoSQL 实践\n\n### 1、docker 的一些环境安装\n```shell\ndocker run --name mongo -p 27017:27017 -v ~/docker-data/mongo:/data/db -e MONGO_INITDB_ROOT_USERNAME=admin -e MONGO_INITDB_ROOT_PASSWORD=admin -d mongo\n```\n\n### 2、MongoDB\nMongoDB 是一款开源的文档型数据库。Spring 对 MongoDB 的支持：\n- Spring Data MongoDB\n   - MongoTemplate\n   - Repository 支持\n- 注解\n   - @Document 和 @Entity 类似，表示类是一个文档（@Entity中是表）\n   - @Id 每个文档都会对应一个 Id ，通过@Id表明类中哪一个属性是id。加上 @Id 之后，Spring Data Mongo 会将属性的类型转化为 MongoDB 中的 object ID。\n- MongoTemplate\n  - save / remove\n  - Criteria / Query / Update\n- Spring Data MongoDB 的 Repository\n  - @EnableMongoRepositories\n  - 对应接口\n    - MongoRepository<T, ID>\n    - PagingAndSortingRepository<T, ID>\n    - CrudRepository<T, ID>\n\n### 3、Spring 中访问 MongoDB\n[代码仓库](https://gitee.com/geektime-geekbang/geektime-spring-family/tree/master/Chapter%204/mongo-demo)\n#### 3.1 安装 MongoDB\n使用 docker 安装。\n```shell\ndocker pull Mongo\ndocker exec -it mongo bash\nmongo -u admin -p admin\n\n// 显示当前存在的库\nshow dbs\n\n// 使用springbucks库，没有会默认创建一个\nuse springbucks\n\n// 创建 createUser，用户名和密码都为springbucks。\ndb.createUser(\n\t{\n\t\tuser: \"springbucks\",\n\t\tpwd: \"springbucks\",\n\t\troles: [\n\t\t\t{role: \"readWrite\", db: \"springbucks\"}\n\t\t]\n\t}\n)\n\nshow users\n\nshow collections;\n\ndb.coffee.find();\n\n// 删除 coffee 中所有名为 espresso 的 Document 。\ndb.coffee.remove({\"name\":\"espresso\"});\n```\n#### 3.2 基于 MongoTemplate 的方法\n##### 创建 Coffee 类\n```java\npackage com.example.mongo.model;\n\nimport lombok.AllArgsConstructor;\nimport lombok.Builder;\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\nimport org.joda.money.Money;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.data.annotation.Id;\nimport org.springframework.data.mongodb.core.mapping.Document;\nimport java.util.Date;\n\n// 表示类是一个文档\n@Document\n@Data\n@AllArgsConstructor\n@NoArgsConstructor\n@Builder\npublic class Coffee {\n    @Id\n    private String id;  // 加上 @Id 之后，Spring Data Mongo 会将String类型转化为 MongoDB 中的 object ID。\n    private String name;\n    private Money price;\n    private Date createTime;\n    private Date updateTime;\n}\n```\n\n##### 配置 MongoDB\n```java\n# 用户名密码对应 springbucks:springbucks ，使用 springbucks 库。\nspring.data.mongodb.uri=mongodb://springbucks:springbucks@124.220.171.2:27017/springbucks\nspring.main.allow-circular-references=true\n```\n\n##### 编写特殊类型 Money 的转化代码（ Mongo -> Money 类型）\n从 Money 类型转化为 Mongo 中的 Document 是自动转化的，不需要我们自己手写。其实就是转化为 Dson 类型（和json相似）。\n**mongo 中存储的 Coffee 对象格式如下，这是一条 Document**\n```json        \n\t{ \"_id\" : ObjectId(\"626b59f24eb80121ff790475\"),\n\t\"name\" : \"espresso\",\n\t\"price\" :\n\t\t{ \"money\" :\n\t\t\t{ \"currency\" :\n\t\t\t\t{ \"code\" : \"CNY\",\n\t\t\t\t\t\"numericCode\" : 156,\n\t\t\t\t\t\"decimalPlaces\" : 2\n\t\t\t\t\t},\n\t\t\t\t\"amount\" : \"20.00\"\n\t\t\t\t}\n\t\t\t},\n\t\"createTime\" : ISODate(\"2022-04-29T03:22:26.240Z\"),\n\t\"updateTime\" : ISODate(\"2022-04-29T03:22:26.240Z\"),\n\t\"_class\" : \"com.example.mongo.model.Coffee\" }\n```\n\n**Mongo -> Money 类型**\n```java\npackage com.example.mongo.converter;\n\nimport org.bson.Document;\nimport org.joda.money.CurrencyUnit;\nimport org.joda.money.Money;\nimport org.springframework.core.convert.converter.Converter;\n\n/*\n* Document 转化为 Money。\n* */\npublic class MoneyReadConverter implements Converter<Document, Money> {\n    @Override\n    public Money convert(Document source) {\n        // Mongo 取出 Document 的数据，从中取出 money。\n        Document money = (Document) source.get(\"money\");\n        // 从 money 中解析出金额。\n        double amount = Double.parseDouble(money.getString(\"amount\"));\n        String currency = ((Document) money.get(\"currency\")).getString(\"code\");\n        return Money.of(CurrencyUnit.of(currency), amount);\n    }\n}\n```\n\n##### 调用代码\n```java\npackage com.example.mongo;\n\nimport com.example.mongo.converter.MoneyReadConverter;\nimport com.example.mongo.model.Coffee;\nimport com.mongodb.client.result.UpdateResult;\nimport com.mongodb.internal.bulk.UpdateRequest;\nimport lombok.extern.slf4j.Slf4j;\nimport org.joda.money.CurrencyUnit;\nimport org.joda.money.Money;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.ApplicationArguments;\nimport org.springframework.boot.ApplicationRunner;\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.data.mongodb.ClientSessionException;\nimport org.springframework.data.mongodb.core.MongoTemplate;\nimport org.springframework.data.mongodb.core.convert.MongoCustomConversions;\nimport org.springframework.data.mongodb.core.query.Criteria;\nimport org.springframework.data.mongodb.core.query.Query;\nimport org.springframework.data.mongodb.core.query.Update;\n\nimport java.util.Arrays;\nimport java.util.Date;\nimport java.util.List;\n\nimport static org.springframework.data.mongodb.core.query.Criteria.where;\nimport static org.springframework.data.mongodb.core.query.Query.query;\n\n@SpringBootApplication\n@Slf4j\npublic class MongoApplication implements ApplicationRunner {\n\n\t@Autowired\n\tMongoTemplate mongoTemplate;\n\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(MongoApplication.class, args);\n\t}\n\n\t// 查看 spring-boot-autoconfigure -> data -> mongo -> MongoDataAutoConfiguration.class\n\t// 可以看出构造一个 MongoCustomConversions 类型的 bean ，可以替代 MongoDataAutoConfiguration 中的一部分配置。\n\t@Bean\n\tpublic MongoCustomConversions mongoCustomConversions(){\n\t\treturn new MongoCustomConversions(Arrays.asList(new MoneyReadConverter()));\n\t}\n\n\t@Override\n\tpublic void run(ApplicationArguments args) throws Exception {\n\t\t//插入\n\t\tCoffee espresso = Coffee.builder()\n\t\t\t\t.name(\"espresso\")\n\t\t\t\t.price(Money.of(CurrencyUnit.of(\"CNY\"), 20.0))\n\t\t\t\t.createTime(new Date())\n\t\t\t\t.updateTime(new Date()).build();\n\t\tCoffee saved = mongoTemplate.save(espresso);\n\t\tlog.info(\"Coffee {}\", saved);\n\n\t\t// 查询\n\t\tList<Coffee> list = mongoTemplate.find(query(where(\"name\").is(\"espresso\")), Coffee.class);\n\t\tlog.info(\"Find {} Coffee\", list.size());\n\t\tlist.forEach(c -> log.info(\"Coffee {}\", c));\n\n\t\t// 更新\n\t\tThread.sleep(1000); // 为了看更新时间 1s\n\t\tUpdateResult result = mongoTemplate.updateFirst(query(where(\"name\").is(\"espresso\")),\n\t\t\t\t new Update().set(\"price\", Money.ofMajor(CurrencyUnit.of(\"CNY\"), 30))\n\t\t\t\t\t\t .currentDate(\"updateTime\"),\n\t\t\t\t Coffee.class);\n\t\t log.info(\"Update Result: {}\", result.getModifiedCount());\n\n\t\t Coffee updateOne = mongoTemplate.findById(saved.getId(), Coffee.class);\n\t\t log.info(\"Update Result: {}\", updateOne);\n\n\t\t// 删除\n\t\t mongoTemplate.remove(updateOne);\n\t}\n}\n```\n\n#### 3.3 基于 Spring Data MongoDB 的 Repository 的方法\n[代码仓库](https://gitee.com/geektime-geekbang/geektime-spring-family/tree/master/Chapter%204/mongo-repository-demo)\n**在基于 MongoTemplate 的方法基础上实现 MongoRepository 接口**\n```java\npackage com.example.mongo.repository;\n\nimport com.example.mongo.model.Coffee;\nimport org.springframework.data.mongodb.repository.MongoRepository;\n\nimport java.util.List;\n\npublic interface CoffeeRepository extends MongoRepository<Coffee, String> {\n    List<Coffee> findByName(String name);\n}\n```\n\n**添加`@EnableMongoRepositories`注解，修改调用代码如下**\n```java\npackage com.example.mongo;\n\nimport com.example.mongo.converter.MoneyReadConverter;\nimport com.example.mongo.model.Coffee;\nimport com.example.mongo.repository.CoffeeRepository;\nimport com.mongodb.client.result.UpdateResult;\nimport com.mongodb.internal.bulk.UpdateRequest;\nimport lombok.extern.slf4j.Slf4j;\nimport org.joda.money.CurrencyUnit;\nimport org.joda.money.Money;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.ApplicationArguments;\nimport org.springframework.boot.ApplicationRunner;\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.data.domain.Sort;\nimport org.springframework.data.mongodb.ClientSessionException;\nimport org.springframework.data.mongodb.core.MongoTemplate;\nimport org.springframework.data.mongodb.core.convert.MongoCustomConversions;\nimport org.springframework.data.mongodb.core.query.Criteria;\nimport org.springframework.data.mongodb.core.query.Query;\nimport org.springframework.data.mongodb.core.query.Update;\nimport org.springframework.data.mongodb.repository.config.EnableMongoRepositories;\n\nimport java.util.Arrays;\nimport java.util.Date;\nimport java.util.List;\n\nimport static org.springframework.data.mongodb.core.query.Criteria.where;\nimport static org.springframework.data.mongodb.core.query.Query.query;\n\n@SpringBootApplication\n@Slf4j\n@EnableMongoRepositories\npublic class MongoApplication implements ApplicationRunner {\n\n\t@Autowired\n\tCoffeeRepository coffeeRepository;\n\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(MongoApplication.class, args);\n\t}\n\n\t// 查看 spring-boot-autoconfigure -> data -> mongo -> MongoDataAutoConfiguration.class\n\t// 可以看出构造一个 MongoCustomConversions 类型的 bean ，可以替代 MongoDataAutoConfiguration 中的一部分配置。\n\t@Bean\n\tpublic MongoCustomConversions mongoCustomConversions(){\n\t\treturn new MongoCustomConversions(Arrays.asList(new MoneyReadConverter()));\n\t}\n\n\t@Override\n\tpublic void run(ApplicationArguments args) throws Exception {\n\t\t//插入\n\t\tCoffee espresso = Coffee.builder()\n\t\t\t\t.name(\"espresso\")\n\t\t\t\t.price(Money.of(CurrencyUnit.of(\"CNY\"), 20.0))\n\t\t\t\t.createTime(new Date())\n\t\t\t\t.updateTime(new Date()).build();\n\t\tCoffee latte = Coffee.builder()\n\t\t\t\t.name(\"latte\")\n\t\t\t\t.price(Money.of(CurrencyUnit.of(\"CNY\"), 30.0))\n\t\t\t\t.createTime(new Date())\n\t\t\t\t.updateTime(new Date()).build();\n\n\t\tcoffeeRepository.insert(Arrays.asList(espresso, latte));\n\t\tcoffeeRepository.findAll(Sort.by(\"name\")).forEach(c -> log.info(\"Saved Coffee {}\", c));\n\n\t\tThread.sleep(1000);\n\t\tlatte.setPrice(Money.of(CurrencyUnit.of(\"CNY\"), 35.0));\n\t\tlatte.setUpdateTime(new Date());\n\t\tcoffeeRepository.save(latte);\n\t\tcoffeeRepository.findByName(\"latte\").forEach(c -> log.info(\"Coffee {}\", c));\n\t\tcoffeeRepository.deleteAll();\n\t}\n}\n\n```\n\n\n### 4、Redis\nSpring 对 Redis 的支持 -- Spring Data Redis\n- 支持客户端Jedis / Lettuce\n- RedisTemplate\n- Repository 支持\n\n#### Jedis 客户端的简单使用-[代码仓库](https://gitee.com/geektime-geekbang/geektime-spring-family/tree/master/Chapter%204/jedis-demo)\n- Jedis 不是线程安全的\n- 通过 JedisPool 获得 Jedis 实例。\\\n  **原因：** Jedis 不安全，不能在多个线程中中使用同一个 jeid ，因此使用 JedisPool 管理 jedis，每次使用时从 JedisPool 中取。\n- 直接使用 Jedis 中的方法\n  \n**实现功能**\n在前面 MongDB 的基础上，使用 Jedis 连接 Redis ，并且测试基本的增删改查。\n\n**新建 scheme.sql 文件。**\n```java\ndrop table t_coffee if exists;\ndrop table t_order if exists;\ndrop table t_order_coffee if exists;\n\ncreate table t_coffee (\n    id bigint auto_increment,\n    create_time timestamp,\n    update_time timestamp,\n    name varchar(255),\n    price bigint,\n    primary key (id)\n);\n\ncreate table t_order (\n    id bigint auto_increment,\n    create_time timestamp,\n    update_time timestamp,\n    customer varchar(255),\n    state integer not null,\n    primary key (id)\n);\n\ncreate table t_order_coffee (\n    coffee_order_id bigint not null,\n    items_id bigint not null\n);\n```\n\n**新建 data.sql 文件。**\n```java\ninsert into t_coffee (name, price, create_time, update_time) values ('espresso', 2000, now(), now());\ninsert into t_coffee (name, price, create_time, update_time) values ('latte', 2500, now(), now());\ninsert into t_coffee (name, price, create_time, update_time) values ('capuccino', 2500, now(), now());\ninsert into t_coffee (name, price, create_time, update_time) values ('mocha', 3000, now(), now());\ninsert into t_coffee (name, price, create_time, update_time) values ('macchiato', 3000, now(), now());\n```\n  \n**配置 Jedis**\n```java\nspring.jpa.hibernate.ddl-auto=none\nspring.jpa.properties.hibernate.show_sql=true\nspring.jpa.properties.hibernate.form_sql=true\n\n# redis\nredis.host=124.220.171.2\nredis.password=123456\nredis.port=6379\nredis.maxTotal=5\nredis.maxIdle=5\n# 向资源池借用连接时是否做连接有效性检测（ping）。检测到的无效连接将会被移除。\nredis.testOnBorrow=false\n\nspring.main.allow-circular-references=true\n```\n\n**测试 Jedis 代码。**\n```java\npackage com.jq.coffe;\n\nimport com.jq.coffe.model.Coffee;\nimport com.jq.coffe.model.CoffeeOrder;\nimport com.jq.coffe.model.OrderState;\nimport com.jq.coffe.repository.CoffeeOrderRepository;\nimport com.jq.coffe.repository.CoffeeRepository;\nimport com.jq.coffe.service.CoffeeOrderService;\nimport com.jq.coffe.service.CoffeeService;\nimport lombok.extern.slf4j.Slf4j;\nimport org.joda.money.CurrencyUnit;\nimport org.joda.money.Money;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.boot.ApplicationArguments;\nimport org.springframework.boot.ApplicationRunner;\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.boot.context.properties.ConfigurationProperties;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.data.domain.Sort;\nimport org.springframework.data.jpa.repository.config.EnableJpaRepositories;\nimport org.springframework.transaction.annotation.EnableTransactionManagement;\nimport org.springframework.transaction.annotation.Transactional;\nimport redis.clients.jedis.Jedis;\nimport redis.clients.jedis.JedisCluster;\nimport redis.clients.jedis.JedisPool;\nimport redis.clients.jedis.JedisPoolConfig;\n\nimport javax.swing.text.html.Option;\nimport java.util.*;\nimport java.util.stream.Collectors;\n\n@SpringBootApplication\n@Slf4j\n@EnableJpaRepositories\n@EnableTransactionManagement\npublic class CoffeApplication implements ApplicationRunner {\n\n\t@Autowired\n\tCoffeeRepository coffeeRepository;\n\n\t@Autowired\n\tCoffeeService coffeeService;\n\n\t@Autowired\n\tCoffeeOrderService coffeeOrderService;\n\n\t@Autowired\n\tJedisPool jedisPool;\n\n\t@Autowired\n\tJedisPoolConfig jedisPoolConfig;\n\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(CoffeApplication.class, args);\n\t}\n\n\t@Override\n\t@Transactional\n\tpublic void run(ApplicationArguments args) throws Exception {\n\t\tlog.info(\"All Coffee: {}\", coffeeRepository.findAll());\n\t\tOptional<Coffee> mocha = coffeeService.findOneCoffee(\"mocha\");\n\t\tOptional<Coffee> latte = coffeeService.findOneCoffee(\"latte\");\n\n\t\tCoffeeOrder order = coffeeOrderService.createOrder(\"Li Lei\", mocha.get(), latte.get());\n\n\t\tlog.info(\"Update INIT to PAID: {}\", coffeeOrderService.updateState(order, OrderState.PAID));\n\t\tlog.info(\"Update PAID to INIT: {}\", coffeeOrderService.updateState(order, OrderState.INIT));\n\n//\t\ttestRedis();\n\t\ttestJedis();\n\t}\n\n\t@Bean\n\t@ConfigurationProperties(\"redis\")\t// 解析配置文件中 redis 开头的选项。\n\tpublic JedisPoolConfig jedisPoolConfig(){\n\t\treturn new JedisPoolConfig();\n\t}\n\n\t@Bean(destroyMethod = \"close\")\t// Bean 关闭时调用他的close方法。\n\tpublic JedisPool jedisPool(@Value(\"${redis.host}\") String host){\n\t\treturn new JedisPool(jedisPoolConfig(), host);\n\t}\n\n\n\tpublic void testRedis(){\n\t\ttry (Jedis jedis = jedisPool.getResource()) {\n\t\t\tjedis.set(\"key1\", \"1233\");\n\n\t\t\tString value = jedis.get(\"key1\");\n\t\t\tlog.info(\"Menu: {}\", value);\n\t\t}\n\t}\n\n\tpublic void testJedis(){\n\t\tlog.info(jedisPoolConfig.toString());\n\n\t\ttry (Jedis jedis = jedisPool.getResource()) {\n\t\t\tcoffeeService.findAllCoffee().forEach(c -> {\n\t\t\t\tjedis.hset(\"springbucks-menu\",\n\t\t\t\t\t\tc.getName(),\n\t\t\t\t\t\tLong.toString(c.getPrice().getAmountMinorLong()));\n\t\t\t});\n\n\t\t\tMap<String, String> menu = jedis.hgetAll(\"springbucks-menu\");\n\t\t\tlog.info(\"Menu: {}\", menu);\n\t\t}\n\t}\n}\n```\n\n#### Redis 的两种部署方式\n- 哨兵模式\n- 集群模式\n\n##### 哨兵模式\nRedis Sentinel 是 Redis 的一种高可用方案。\n- 监控、通知、自动故障转移、服务发现\n\n**哨兵**\nJedisSentinePool\n\n**集群**\nRedis Cluster\n- 数据自动分片（分成16384个Hash Slot）\n- 在部分节点失效时有一定的可用性\n  \nJedisCluster\n- Jedis 只从 Master 读数据，如果想要自动读写分离，可以定制\n\n### 5、Spring Boot 缓存抽象\n\n#### Spring boot 为不同的缓存提供一层抽象\n- 为java方法增加缓存，缓存执行结果\n- 支持 Redis、ConcurrentMap、EhCache、Caffeine、JCache（JSR-107）等缓存抽象\n- 接口\n  - org.springframework.cache.Cache\n  - org.springframework.cache.CacheManager\n  \n#### Spring boot 默认缓存（本地缓存） - [代码仓库](https://gitee.com/geektime-geekbang/geektime-spring-family/tree/master/Chapter%204/cache-demo)\n\nSpring boot 自带的默认缓存，也可以集成 Redis、EhCache等其他缓存。\n\n**EnableCaching**\t开启缓存支持\n- @Cacheable \\\nSpring会在其被调用后将其返回值缓存起来，以保证下次利用同样的参数来执行该方法时可以直接从缓存中获取结果，而不需要再次执行该方法。Spring在缓存方法的返回值时是以键值对进行缓存的，值就是方法的返回结果。\n\n- @CacheEvict \\\n  @CachEvict主要针对方法配置，能够根据一定的条件对特定的缓存进行清空。该注解有两个特别的属性：\n\t- allEntries 是否清空所有缓存内容，缺省为 false，如果指定为 true，则方法调用后将立即清空所有缓存。注意不能跟key参数同时使用。\n\t- beforeInvocation 是否在方法执行前就清空，缺省为 false，如果指定为 true，则在方法还没有执行的时候就清空缓存，缺省情况下，如果方法执行抛出异常，则不会清空缓存。\n\n- @CachePut \\\n  @CachePut每次都将执行方法并将返回值K-V放入缓存，如果该K存在则进行更新。\n\n- @Caching \\\n  该注解是个组合注解。有时候我们需要在一个方法上同时使用多个相同注解但是java是不支持一个注解在同一个方法上多次使用。这时就可以使用该注解进行组合。\n\n- @CacheConfig \\\n  作用于缓存接口上，来对该接口下的一些重复配置（缓存名称、key生成器、缓存管理器、缓存处理器）进行归纳处理。其他属性可参考Cacheable。\n\n**流程**\n- 开启缓存支持（@EnableCaching(proxyTargetClass = true)\t// 开启缓存支持）\n- 配置缓存（@CacheConfig(cacheNames = \"coffee\") // 该缓存的名字为coffee）\n- 指定缓存的具体方法\n\n\n**配置缓存和为方法添加缓存注解**\n```java\npackage com.jq.coffe.service;\n\nimport com.jq.coffe.model.Coffee;\nimport com.jq.coffe.repository.CoffeeRepository;\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.cache.annotation.CacheConfig;\nimport org.springframework.cache.annotation.CacheEvict;\nimport org.springframework.cache.annotation.Cacheable;\nimport org.springframework.data.domain.Example;\nimport org.springframework.data.domain.ExampleMatcher;\nimport org.springframework.stereotype.Service;\n\nimport java.util.List;\nimport java.util.Optional;\n\nimport static org.springframework.data.domain.ExampleMatcher.GenericPropertyMatchers.exact;\n\n@Service\n@Slf4j\n@CacheConfig(cacheNames = \"coffee\") // 该缓存的名字为coffee。（类级别共享的缓存配置）\npublic class CoffeeService {\n\n    @Autowired\n    CoffeeRepository coffeeRepository;\n\n    public Optional<Coffee> findOneCoffee(String name){\n        Example<Coffee> example = new Example<Coffee>() {\n            @Override\n            public Coffee getProbe() {\n                return Coffee.builder().name(name).build();\n            }\n\n            @Override\n            public ExampleMatcher getMatcher() {\n                ExampleMatcher exampleMatcher = ExampleMatcher.matching().withMatcher(\"name\", exact().ignoreCase());\n                return exampleMatcher;\n            }\n        };\n\n        Optional<Coffee>  coffee = coffeeRepository.findOne(example);\n\n        log.info(\"Coffee Found: {}\", coffee);\n        return coffee;\n    }\n\n    @Cacheable // 为该方法添加缓存\n    public List<Coffee> findAllCoffee() {\n        return coffeeRepository.findAll();\n    }\n\n    @CacheEvict // 清除缓存\n    public void reloadCoffee(){\n\n    }\n}\n```\n\n**开启缓存支持**\n```java\npackage com.jq.coffe;\n\nimport com.jq.coffe.model.Coffee;\nimport com.jq.coffe.model.CoffeeOrder;\nimport com.jq.coffe.model.OrderState;\nimport com.jq.coffe.repository.CoffeeOrderRepository;\nimport com.jq.coffe.repository.CoffeeRepository;\nimport com.jq.coffe.service.CoffeeOrderService;\nimport com.jq.coffe.service.CoffeeService;\nimport lombok.extern.slf4j.Slf4j;\nimport org.joda.money.CurrencyUnit;\nimport org.joda.money.Money;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.boot.ApplicationArguments;\nimport org.springframework.boot.ApplicationRunner;\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.boot.context.properties.ConfigurationProperties;\nimport org.springframework.cache.annotation.EnableCaching;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.data.domain.Sort;\nimport org.springframework.data.jpa.repository.config.EnableJpaRepositories;\nimport org.springframework.transaction.annotation.EnableTransactionManagement;\nimport org.springframework.transaction.annotation.Transactional;\nimport redis.clients.jedis.Jedis;\nimport redis.clients.jedis.JedisCluster;\nimport redis.clients.jedis.JedisPool;\nimport redis.clients.jedis.JedisPoolConfig;\n\nimport javax.swing.text.html.Option;\nimport java.util.*;\nimport java.util.stream.Collectors;\n\n@SpringBootApplication\n@Slf4j\n@EnableJpaRepositories\n@EnableTransactionManagement\n@EnableCaching(proxyTargetClass = true)\t// 开启缓存支持\npublic class CoffeApplication implements ApplicationRunner {\n\n\t@Autowired\n\tCoffeeRepository coffeeRepository;\n\n\t@Autowired\n\tCoffeeOrderRepository orderRepository;\n\n\t@Autowired\n\tCoffeeService coffeeService;\n\n\t@Autowired\n\tCoffeeOrderService coffeeOrderService;\n\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(CoffeApplication.class, args);\n\t}\n\n\t@Override\n\t@Transactional\n\tpublic void run(ApplicationArguments args) throws Exception {\n\t\tlog.info(\"All Coffee: {}\", coffeeRepository.findAll());\n\t\tOptional<Coffee> mocha = coffeeService.findOneCoffee(\"mocha\");\n\t\tOptional<Coffee> latte = coffeeService.findOneCoffee(\"latte\");\n\n\t\tCoffeeOrder order = coffeeOrderService.createOrder(\"Li Lei\", mocha.get(), latte.get());\n\n\t\tlog.info(\"Update INIT to PAID: {}\", coffeeOrderService.updateState(order, OrderState.PAID));\n\t\tlog.info(\"Update PAID to INIT: {}\", coffeeOrderService.updateState(order, OrderState.INIT));\n\n\t\ttestSpringCache();\n\t}\n\n\tpublic void testSpringCache(){\n\t\tlog.info(\"Count: {}\", coffeeService.findAllCoffee().size());\n\n\t\tfor (int i = 0; i < 10; i++) {\n\t\t\tlog.info(\"Reading from cache.\");\n\t\t\tcoffeeService.findAllCoffee();\n\t\t}\n\n\t\tcoffeeService.reloadCoffee();\n\n\t\tlog.info(\"Reading after refresh.\");\n\n\t\tcoffeeService.findAllCoffee().forEach(c -> log.info(\"Coffee {}\", c.getName()));\n\t}\n}\n```\n\n#### 集成 redis 缓存\n\n**依赖**\n```xml\n\t\t<dependency>\n\t\t\t<groupId>org.springframework.boot</groupId>\n\t\t\t<artifactId>spring-boot-starter-cache</artifactId>\n\t\t</dependency>\n\t\t<dependency>\n\t\t\t<groupId>org.springframework.boot</groupId>\n\t\t\t<artifactId>spring-boot-starter-data-redis</artifactId>\n\t\t</dependency>\n```\n\n**配置缓存**\n```properties\nspring.jpa.hibernate.ddl-auto=none\nspring.jpa.properties.hibernate.show_sql=true\nspring.jpa.properties.hibernate.format_sql=true\n\nmanagement.endpoints.web.exposure.include=*\n\n#使用redis缓存\nspring.cache.type=redis\n#配置默认缓存的，启动时会把其中指定的缓存创建出来，运行时的缓存不能超出我这指定的范围（有同学反馈这个与底层的缓存实现有关，因此补充一下，比如Simple的不能超过，但Redis的可以），不配的话就看代码里用到哪些动态创建。@CacheConfig用来配置类级别共享的缓存配置，配置不在@CacheConfig里，就需要加在@Cacheable里。\nspring.cache.cache-names=coffee\n#在缓存中的存活时间\nspring.cache.redis.time-to-live=5000\nspring.cache.redis.cache-null-values=false\n\nspring.redis.host=localhost\n```\n\n**配置缓存和为方法添加缓存注解**\n```java\n@Slf4j\n@Service\n@CacheConfig(cacheNames = \"coffee\")\npublic class CoffeeService {\n    @Autowired\n    private CoffeeRepository coffeeRepository;\n\n    @Cacheable\n    public List<Coffee> findAllCoffee() {\n        return coffeeRepository.findAll();\n    }\n\n    @CacheEvict\n    public void reloadCoffee() {\n    }\n\n    public Optional<Coffee> findOneCoffee(String name) {\n        ExampleMatcher matcher = ExampleMatcher.matching()\n                .withMatcher(\"name\", exact().ignoreCase());\n        Optional<Coffee> coffee = coffeeRepository.findOne(\n                Example.of(Coffee.builder().name(name).build(), matcher));\n        log.info(\"Coffee Found: {}\", coffee);\n        return coffee;\n    }\n}\n\n```\n\n**调用代码**\n```java\npackage com.jq.coffe;\n\nimport com.jq.coffe.model.Coffee;\nimport com.jq.coffe.model.CoffeeOrder;\nimport com.jq.coffe.model.OrderState;\nimport com.jq.coffe.repository.CoffeeOrderRepository;\nimport com.jq.coffe.repository.CoffeeRepository;\nimport com.jq.coffe.service.CoffeeOrderService;\nimport com.jq.coffe.service.CoffeeService;\nimport lombok.extern.slf4j.Slf4j;\nimport org.joda.money.CurrencyUnit;\nimport org.joda.money.Money;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.boot.ApplicationArguments;\nimport org.springframework.boot.ApplicationRunner;\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.boot.context.properties.ConfigurationProperties;\nimport org.springframework.cache.annotation.EnableCaching;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.data.domain.Sort;\nimport org.springframework.data.jpa.repository.config.EnableJpaRepositories;\nimport org.springframework.transaction.annotation.EnableTransactionManagement;\nimport org.springframework.transaction.annotation.Transactional;\nimport redis.clients.jedis.Jedis;\nimport redis.clients.jedis.JedisCluster;\nimport redis.clients.jedis.JedisPool;\nimport redis.clients.jedis.JedisPoolConfig;\n\nimport javax.swing.text.html.Option;\nimport java.util.*;\nimport java.util.stream.Collectors;\n\n@SpringBootApplication\n@Slf4j\n@EnableJpaRepositories\n@EnableTransactionManagement\n@EnableCaching(proxyTargetClass = true)\t// 开启缓存支持\npublic class CoffeApplication implements ApplicationRunner {\n\n\t@Autowired\n\tCoffeeRepository coffeeRepository;\n\n\t@Autowired\n\tCoffeeService coffeeService;\n\n\t@Autowired\n\tCoffeeOrderService coffeeOrderService;\n\n\t@Autowired\n\tJedisPool jedisPool;\n\n\t@Autowired\n\tJedisPoolConfig jedisPoolConfig;\n\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(CoffeApplication.class, args);\n\t}\n\n\t@Override\n\t@Transactional\n\tpublic void run(ApplicationArguments args) throws Exception {\n\t\tlog.info(\"All Coffee: {}\", coffeeRepository.findAll());\n\t\tOptional<Coffee> mocha = coffeeService.findOneCoffee(\"mocha\");\n\t\tOptional<Coffee> latte = coffeeService.findOneCoffee(\"latte\");\n\n\t\tCoffeeOrder order = coffeeOrderService.createOrder(\"Li Lei\", mocha.get(), latte.get());\n\n\t\tlog.info(\"Update INIT to PAID: {}\", coffeeOrderService.updateState(order, OrderState.PAID));\n\t\tlog.info(\"Update PAID to INIT: {}\", coffeeOrderService.updateState(order, OrderState.INIT));\n\t\ttestRedisCache();\n\t}\n\n\tpublic void testRedisCache() throws InterruptedException {\n\t\tlog.info(\"Count: {}\", coffeeService.findAllCoffee().size());\n\t\tfor (int i = 0; i < 5; i++) {\n\t\t\tlog.info(\"Reading from cache.\");\n\t\t\tcoffeeService.findAllCoffee();\n\t\t}\n\t\tThread.sleep(5000);\n\t\tlog.info(\"Reading after refresh.\");\n\t\tcoffeeService.findAllCoffee().forEach(c -> log.info(\"Coffee {}\", c.getName()));\n\t}\n\n\tpublic void testSpringCache(){\n\t\tlog.info(\"Count: {}\", coffeeService.findAllCoffee().size());\n\t\tfor (int i = 0; i < 10; i++) {\n\t\t\tlog.info(\"Reading from cache.\");\n\t\t\tcoffeeService.findAllCoffee();\n\t\t}\n\t\tcoffeeService.reloadCoffee();\n\t\tlog.info(\"Reading after refresh.\");\n\t\tcoffeeService.findAllCoffee().forEach(c -> log.info(\"Coffee {}\", c.getName()));\n\t}\n\n\t@Bean\n\t@ConfigurationProperties(\"redis\")\t// 解析配置文件中 redis 开头的选项。\n\tpublic JedisPoolConfig jedisPoolConfig(){\n\t\treturn new JedisPoolConfig();\n\t}\n\n\t@Bean(destroyMethod = \"close\")\t// Bean 关闭时调用他的close方法。\n\tpublic JedisPool jedisPool(@Value(\"${spring.redis.host}\") String host){\n\t\treturn new JedisPool(jedisPoolConfig(), host);\n\t}\n```\n\n### 6、Redis 在 Spring 中的其他用法\n\n#### 与 Redis 建立连接\n**配置连接工厂**\n- LettuceConnecetionFactory 与 JedisConnectionFactory\n  - RedsiStandaloneConfiguration\n  - RedsiaSentinelConfiguration\n  - RedsiClusterConfiguraion\n\n#### 读写分离\n**Lettuce 内置支持读写分离**\n- 只读主、只读从\n- 优先读主、优先读从\n\nLettuceClientConfiguration\t\\\nLettucePollingClientConfiguration\t\\\nLettuceClientConfigurationBuildercustonizer\n\n#### RedisTemplate\n**对Redis 的操作一定设置过期时间！！！**\n**对Redis 的操作一定设置过期时间！！！**\n**对Redis 的操作一定设置过期时间！！！**\n\nRedisTemplate<K, V>\n- opsForXxx()\n\nStringRedisTemplate\n\n**配置 RedisTemplate**\n```java\npackage com.jq.coffe;\n\nimport com.jq.coffe.model.Coffee;\nimport com.jq.coffe.model.CoffeeOrder;\nimport com.jq.coffe.model.OrderState;\nimport com.jq.coffe.repository.CoffeeOrderRepository;\nimport com.jq.coffe.repository.CoffeeRepository;\nimport com.jq.coffe.service.CoffeeOrderService;\nimport com.jq.coffe.service.CoffeeService;\nimport lombok.extern.slf4j.Slf4j;\nimport org.joda.money.CurrencyUnit;\nimport org.joda.money.Money;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.boot.ApplicationArguments;\nimport org.springframework.boot.ApplicationRunner;\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.boot.context.properties.ConfigurationProperties;\nimport org.springframework.cache.annotation.EnableCaching;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.data.domain.Sort;\nimport org.springframework.data.jpa.repository.config.EnableJpaRepositories;\nimport org.springframework.data.redis.connection.RedisConnectionFactory;\nimport org.springframework.data.redis.core.RedisTemplate;\nimport org.springframework.transaction.annotation.EnableTransactionManagement;\nimport org.springframework.transaction.annotation.Transactional;\nimport redis.clients.jedis.Jedis;\nimport redis.clients.jedis.JedisCluster;\nimport redis.clients.jedis.JedisPool;\nimport redis.clients.jedis.JedisPoolConfig;\n\nimport javax.swing.text.html.Option;\nimport java.util.*;\nimport java.util.stream.Collectors;\n\n@SpringBootApplication\n@Slf4j\n@EnableJpaRepositories\n@EnableTransactionManagement\npublic class CoffeApplication implements ApplicationRunner {\n\n\t@Autowired\n\tCoffeeRepository coffeeRepository;\n\n\t@Autowired\n\tCoffeeService coffeeService;\n\n\t@Autowired\n\tCoffeeOrderService coffeeOrderService;\n\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(CoffeApplication.class, args);\n\t}\n\n\t@Override\n\t@Transactional\n\tpublic void run(ApplicationArguments args) throws Exception {\n\n\t\tlog.info(\"All Coffee: {}\", coffeeRepository.findAll());\n\t\tOptional<Coffee> mocha = coffeeService.findOneCoffee(\"mocha\");\n\t\tOptional<Coffee> latte = coffeeService.findOneCoffee(\"latte\");\n\n\t\tCoffeeOrder order = coffeeOrderService.createOrder(\"Li Lei\", mocha.get(), latte.get());\n\n\t\tlog.info(\"Update INIT to PAID: {}\", coffeeOrderService.updateState(order, OrderState.PAID));\n\t\tlog.info(\"Update PAID to INIT: {}\", coffeeOrderService.updateState(order, OrderState.INIT));\n\t\ttestRedisTemplate();\n\t}\n\n\t/*\n\t* 配置 RedisTemplate\n\t* */\n\t@Bean\n\tpublic RedisTemplate<String, Coffee> redisTemplate(RedisConnectionFactory redisConnectionFactory){\n\t\tRedisTemplate<String, Coffee> template = new RedisTemplate<>();\n\t\ttemplate.setConnectionFactory(redisConnectionFactory);\n\t\treturn template;\n\t}\n\n\tpublic void testRedisTemplate(){\n\t\tOptional<Coffee> c = coffeeService.findOneCoffee(\"mocha\");\n\t\tlog.info(\"Coffee {}\", c);\n\n\t\tfor (int i = 0; i < 5; i++) {\n\t\t\tcoffeeService.findOneCoffee(\"mocha\");\n\t\t}\n\t\tlog.info(\"Value from Redis: {}\", c);\n\t}\n}\n```\n\n**具体的操作**\n```java\npackage com.jq.coffe.service;\n\nimport com.jq.coffe.model.Coffee;\nimport com.jq.coffe.repository.CoffeeRepository;\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.cache.annotation.CacheConfig;\nimport org.springframework.cache.annotation.CacheEvict;\nimport org.springframework.cache.annotation.Cacheable;\nimport org.springframework.data.domain.Example;\nimport org.springframework.data.domain.ExampleMatcher;\nimport org.springframework.data.redis.core.HashOperations;\nimport org.springframework.data.redis.core.RedisTemplate;\nimport org.springframework.stereotype.Service;\n\nimport java.util.List;\nimport java.util.Optional;\nimport java.util.concurrent.TimeUnit;\n\nimport static org.springframework.data.domain.ExampleMatcher.GenericPropertyMatchers.exact;\n\n@Service\n@Slf4j\npublic class CoffeeService {\n    private static final String CACHE = \"springbucks-coffee\";\n    @Autowired\n    CoffeeRepository coffeeRepository;\n\n    @Autowired\n    RedisTemplate<String, Coffee> redisTemplate;\n\n    public Optional<Coffee> findOneCoffee(String name) {\n\n        // 查询缓存\n        // HashOperations<String, String, Coffee> 用于存储 Map 类型，第一个 String 是Reids中key的一部分；\n        // 第二个String是map中的key，Coffee是map的value；一个map是redis中的value\n        HashOperations<String, String, Coffee> hashOperations = redisTemplate.opsForHash();\n        if (redisTemplate.hasKey(CACHE) && hashOperations.hasKey(CACHE, name)){\n            log.info(\"Get coffee {} from Redsi.\", name);\n            return Optional.of(hashOperations.get(CACHE, name));\n        }\n\n        hashOperations.get(CACHE, name);\n\n        // 写入数据库\n        Example<Coffee> example = new Example<Coffee>() {\n            @Override\n            public Coffee getProbe() {\n                return Coffee.builder().name(name).build();\n            }\n            @Override\n            public ExampleMatcher getMatcher() {\n                ExampleMatcher exampleMatcher = ExampleMatcher.matching().withMatcher(\"name\", exact().ignoreCase());\n                return exampleMatcher;\n            }\n        };\n        Optional<Coffee>  coffee = coffeeRepository.findOne(example);\n        log.info(\"Coffee Found: {}\", coffee);\n        // 写入缓存\n        if (coffee.isPresent()){\n            log.info(\"Put coffee {} to Redis.\", name);\n            hashOperations.put(CACHE, name, coffee.get());\n            redisTemplate.expire(CACHE, 1, TimeUnit.MINUTES);\n        }\n        return coffee;\n    }\n}\n```\n\n#### Redis Repository\n实体注解\n- @RedisHash （类似Entity）\n- @Id\n- @Indexed （二级索引）\n  \n##### 出了不同类型（JPA、Mongn、Redis）数据源的 Repository\n如何区分这些 Repsitory\n- 根据实体的注解\n- 根据继承的接口类型\n- 扫描不同的包\n\n#### Redis Repository 的简单实例\n- 配置 redis\n- 开启 Redis Repositories 的支持\n- 类中的特殊类型自定义 RedisCustomConversions\n- 实现具体操作\n\n**配置 Redis**\n```java\n# redis\nspring.redis.host=124.220.171.2\nspring.redis.password=123456\nspring.redis.port=6379\nspring.redis.maxTotal=5\nspring.redis.maxIdle=5\n```\n\n**ReisHash**\n```java\npackage com.jq.coffe.model;\n\nimport lombok.AllArgsConstructor;\nimport lombok.Builder;\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\nimport org.joda.money.Money;\nimport org.springframework.data.redis.core.RedisHash;\nimport org.springframework.data.redis.core.index.Indexed;\n\nimport javax.persistence.Id;\n\n@RedisHash(value = \"springbucks-coffee\", timeToLive = 60)\n@Data\n@AllArgsConstructor\n@NoArgsConstructor\n@Builder\npublic class CoffeeCache {\n\n    @Id\n    private Long id;\n    @Indexed\n    private String name;\n    private Money price;\n}\n```\n\n**实现 CrudRepository 接口**\n```java\npackage com.jq.coffe.repository;\n\nimport com.jq.coffe.model.CoffeeCache;\nimport org.springframework.data.repository.CrudRepository;\n\nimport java.util.Optional;\n\npublic interface CoffeeCacheRepository extends CrudRepository<CoffeeCache, Long> {\n    Optional<CoffeeCache> findOneByName(String name);\n}\n```\n\n**实现特殊类型（Money）写入到 Reids 的转化**\n```java\npackage com.jq.coffe.converter;\n\nimport org.joda.money.Money;\nimport org.springframework.core.convert.converter.Converter;\nimport org.springframework.data.convert.WritingConverter;\n\nimport java.nio.charset.StandardCharsets;\n\n// 写入到 Redis 中\n@WritingConverter\npublic class MoneyToBytesConverter implements Converter<Money, byte[]> {\n    @Override\n    public byte[] convert(Money source) {\n        String value = Long.toString(source.getAmountMinorLong());\n        return value.getBytes(StandardCharsets.UTF_8);\n    }\n}\n```\n\n**实现特殊类型（Money）从 Reids 中读出转化为 Money**\n```java\npackage com.jq.coffe.converter;\n\nimport org.joda.money.CurrencyUnit;\nimport org.joda.money.Money;\nimport org.springframework.core.convert.converter.Converter;\nimport org.springframework.data.convert.ReadingConverter;\n\nimport java.nio.charset.StandardCharsets;\n\n\n@ReadingConverter\npublic class BytesToMoneyConverter implements Converter<byte[], Money> {\n    @Override\n    public Money convert(byte[] source) {\n        String value = new String(source, StandardCharsets.UTF_8);\n        return Money.ofMinor(CurrencyUnit.of(\"CNY\"), Long.parseLong(value));\n    }\n}\n```\n\n**将自定义的 Converter 注入到容器中**\n```java\n\t@Bean\n\tpublic RedisCustomConversions redisCustomConversions(){\n\t\treturn new RedisCustomConversions(Arrays.asList(new MoneyToBytesConverter(), new BytesToMoneyConverter()));\n\t}\n```\n\n**实现 Service 层具体的操作**\n```java\npackage com.jq.coffe.service;\n\nimport com.jq.coffe.model.Coffee;\nimport com.jq.coffe.model.CoffeeCache;\nimport com.jq.coffe.repository.CoffeeCacheRepository;\nimport com.jq.coffe.repository.CoffeeRepository;\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.cache.annotation.CacheConfig;\nimport org.springframework.cache.annotation.CacheEvict;\nimport org.springframework.cache.annotation.Cacheable;\nimport org.springframework.data.domain.Example;\nimport org.springframework.data.domain.ExampleMatcher;\nimport org.springframework.data.redis.core.HashOperations;\nimport org.springframework.data.redis.core.RedisTemplate;\nimport org.springframework.stereotype.Service;\n\nimport java.util.List;\nimport java.util.Optional;\nimport java.util.concurrent.TimeUnit;\n\nimport static org.springframework.data.domain.ExampleMatcher.GenericPropertyMatchers.exact;\n\n@Service\n@Slf4j\npublic class CoffeeService {\n    private static final String CACHE = \"springbucks-coffee\";\n    @Autowired\n    CoffeeRepository coffeeRepository;\n\n    @Autowired\n    RedisTemplate<String, Coffee> redisTemplate;\n\n    @Autowired\n    CoffeeCacheRepository coffeeCacheRepository;\n\n    public Optional<Coffee> findOneCoffee(String name) {\n\n        // 查询缓存\n        // HashOperations<String, String, Coffee> 用于存储 Map 类型，第一个 String 是Reids中key的一部分；\n        // 第二个String是map中的key，Coffee是map的value；一个map是redis中的value\n        HashOperations<String, String, Coffee> hashOperations = redisTemplate.opsForHash();\n        if (redisTemplate.hasKey(CACHE) && hashOperations.hasKey(CACHE, name)){\n            log.info(\"Get coffee {} from Redsi.\", name);\n            return Optional.of(hashOperations.get(CACHE, name));\n        }\n\n        hashOperations.get(CACHE, name);\n\n        // 写入数据库\n        Example<Coffee> example = new Example<Coffee>() {\n            @Override\n            public Coffee getProbe() {\n                return Coffee.builder().name(name).build();\n            }\n            @Override\n            public ExampleMatcher getMatcher() {\n                ExampleMatcher exampleMatcher = ExampleMatcher.matching().withMatcher(\"name\", exact().ignoreCase());\n                return exampleMatcher;\n            }\n        };\n        Optional<Coffee>  coffee = coffeeRepository.findOne(example);\n        log.info(\"Coffee Found: {}\", coffee);\n        // 写入缓存\n        if (coffee.isPresent()){\n            log.info(\"Put coffee {} to Redis.\", name);\n            hashOperations.put(CACHE, name, coffee.get());\n            redisTemplate.expire(CACHE, 1, TimeUnit.MINUTES);\n        }\n        return coffee;\n    }\n\n    public Optional<Coffee> findSimpleCoffeeFromCache(String name){\n        Optional<CoffeeCache> cached = coffeeCacheRepository.findOneByName(name);\n        if (cached.isPresent()){\n            CoffeeCache coffeeCache = cached.get();\n            Coffee coffee = Coffee.builder()\n                    .name(coffeeCache.getName())\n                    .price(coffeeCache.getPrice()).build();\n            log.info(\"Coffee {} found in cache.\", coffeeCache);\n            return Optional.of(coffee);\n        }else {\n            Optional<Coffee> raw = findOneCoffee(name);\n\n            raw.ifPresent(c -> {\n                CoffeeCache coffeeCache = CoffeeCache.builder()\n                        .id(c.getId())\n                        .name(c.getName())\n                        .price(c.getPrice()).build();\n                log.info(\"Save Coffee {} to cache.\", coffeeCache);\n                coffeeCacheRepository.save(coffeeCache);\n            });\n            return raw;\n        }\n    }\n}\n```\n\n**测试代码**\n```java\npackage com.jq.coffe;\n\nimport com.jq.coffe.converter.BytesToMoneyConverter;\nimport com.jq.coffe.converter.MoneyToBytesConverter;\nimport com.jq.coffe.model.Coffee;\nimport com.jq.coffe.model.CoffeeOrder;\nimport com.jq.coffe.model.OrderState;\nimport com.jq.coffe.repository.CoffeeOrderRepository;\nimport com.jq.coffe.repository.CoffeeRepository;\nimport com.jq.coffe.service.CoffeeOrderService;\nimport com.jq.coffe.service.CoffeeService;\nimport lombok.extern.slf4j.Slf4j;\nimport org.joda.money.CurrencyUnit;\nimport org.joda.money.Money;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.boot.ApplicationArguments;\nimport org.springframework.boot.ApplicationRunner;\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.boot.context.properties.ConfigurationProperties;\nimport org.springframework.cache.annotation.EnableCaching;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.data.domain.Sort;\nimport org.springframework.data.jpa.repository.config.EnableJpaRepositories;\nimport org.springframework.data.redis.connection.RedisConnectionFactory;\nimport org.springframework.data.redis.core.RedisTemplate;\nimport org.springframework.data.redis.core.convert.RedisCustomConversions;\nimport org.springframework.data.redis.repository.configuration.EnableRedisRepositories;\nimport org.springframework.transaction.annotation.EnableTransactionManagement;\nimport org.springframework.transaction.annotation.Transactional;\nimport redis.clients.jedis.Jedis;\nimport redis.clients.jedis.JedisCluster;\nimport redis.clients.jedis.JedisPool;\nimport redis.clients.jedis.JedisPoolConfig;\n\nimport javax.swing.text.html.Option;\nimport java.util.*;\nimport java.util.stream.Collectors;\n\n@SpringBootApplication\n@Slf4j\n@EnableTransactionManagement\n@EnableRedisRepositories\t// 开启Redis Repositories 的支持\npublic class CoffeApplication implements ApplicationRunner {\n\n\t@Autowired\n\tCoffeeRepository coffeeRepository;\n\t@Autowired\n\tCoffeeService coffeeService;\n\n\t@Autowired\n\tCoffeeOrderService coffeeOrderService;\n\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(CoffeApplication.class, args);\n\t}\n\n\t@Override\n\t@Transactional\n\tpublic void run(ApplicationArguments args) throws Exception {\n\t\tlog.info(\"All Coffee: {}\", coffeeRepository.findAll());\n\t\tOptional<Coffee> mocha = coffeeService.findOneCoffee(\"mocha\");\n\t\tOptional<Coffee> latte = coffeeService.findOneCoffee(\"latte\");\n\n\t\tCoffeeOrder order = coffeeOrderService.createOrder(\"Li Lei\", mocha.get(), latte.get());\n\n\t\tlog.info(\"Update INIT to PAID: {}\", coffeeOrderService.updateState(order, OrderState.PAID));\n\t\tlog.info(\"Update PAID to INIT: {}\", coffeeOrderService.updateState(order, OrderState.INIT));\n\t\ttestRedisRepository();\n\t}\n\n\t// 将自定义的 Converter 注入到容器中\n\t@Bean\n\tpublic RedisCustomConversions redisCustomConversions(){\n\t\treturn new RedisCustomConversions(Arrays.asList(new MoneyToBytesConverter(), new BytesToMoneyConverter()));\n\t}\n\n\tpublic void testRedisRepository(){\n\t\tOptional<Coffee> c = coffeeService.findSimpleCoffeeFromCache(\"mocha\");\n\t\tlog.info(\"Coffee {}\", c);\n\n\t\tfor (int i = 0; i < 5; i++) {\n\t\t\tc = coffeeService.findSimpleCoffeeFromCache(\"mocha\");\n\t\t}\n\t\tlog.info(\"Value from Redis: {}\", c);\n\t}\n}\n```\n\n## 第五章 数据访问进阶\n\n### 1、Project Reactor 介绍\n\n**Reactor Programming（响应式编程）:** c = a + b; 当结果计算出来之后，a和b变化，c不在受影响，Reactor 编程可以将变化传给c。\\\n**Reactor Programming（响应式编程）** 是一种基于数据流（data stream）和变化传递（propagation of change）的声明式（declarative）的编程范式。具体理解强烈推荐 - [什么是响应式编程](https://blog.csdn.net/get_set/article/details/79455258)。\n\n必读 - [Reactor 3 快速上手](https://blog.csdn.net/get_set/article/details/79480172),该专栏其他文章也建议阅读。\n\n##### 一些核心概念\n**Publisher / Subscriber**\n- Nothing Happens Until You subscribe() \n- Flux [ 0..N ] - onNext()、onComplete()、onError()\n- Mono [ 0..1 ] - onNext()、onComplete()、onError() \n\n**Backpressure （“回压”机制）**\n- Subscription \n- onRequest(n) 指定每次订阅n个序列\n- onCancel() 取消订阅的过程\n- onDispose() 终止订阅的过程\n\n**线程调度 Schedulers**\n- immediate() 当前在哪个线程上\n- single() 独占一个线程\n- newSingle()\n- elastic() elastic 的一个线程池，里面线程空闲60s就会被回收\n- parallel() 与CPU核数相对应的线程池，线程不会被回收\n- newParallel()  \n\n**错误处理**\n- onError 类似 try catch\n- onErrorReturn 出现异常返回特定值\n- onErrorResume 出现异常使用特定的Lambda的处理异常\n- doOnError\n- doFinally 正常执行完还是遇到异常，都会执行 doFinally 中的方法。\n\n**依赖**\n```java\n<dependency>\n\t\t\t<groupId>io.projectreactor</groupId>\n\t\t\t<artifactId>reactor-core</artifactId>\n\t\t</dependency>\n```\n\n**Demo**\n```java\n/*\n* 在调用 subscribe 方法之前不会有任何实际的动作\n* */\n\t@Override\n\tpublic void run(ApplicationArguments args) throws Exception {\n\t\t// 创建包含从 0 起始的 6 个数量的 Integer 对象的序列（数据流），其实就是将其打包起来，或者理解成声明，在 执行 subscribe 方法前什么都不会发生。\n\t\tFlux.range(0, 6)\n\t\t\t\t.publishOn(Schedulers.elastic())\t// 发布到 Schedulers.elastic() 上\n\t\t\t\t.doOnRequest(n -> log.info(\"Request {} number\", n))\n\t\t\t\t.doOnComplete(() -> log.info(\"Publisher Complete\"))\t// 当整个序列完成时执行\n\t\t\t\t.map(i -> {\n\t\t\t\t\tlog.info(\"Publish {}, {}\", Thread.currentThread(), i);\n\t\t\t\t\treturn 10 / (i - 3);\n//\t\t\t\t\treturn i;\n\t\t\t\t})\n//\t\t\t\t.onErrorReturn(-1)\t// 异常，发布-1，并返回\n\t\t\t\t.onErrorResume(e -> {\t// 异常处理逻辑\n\t\t\t\t\tlog.error(\"Exception {}\", e.toString());\n\t\t\t\t\treturn Mono.just(-1);\n\t\t\t\t})\n\t\t\t\t.doOnComplete(() -> log.info(\"Publish Complete 2\"))\n\t\t\t\t.subscribeOn(Schedulers.single())\t// 指定从 Schedulers.single() 订阅\n\t\t\t\t.subscribe(i -> log.info(\"Subscribe {}: {}\", Thread.currentThread(), i),\t// 订阅\n\t\t\t\t\t\te -> log.error(\"error {}\", e.toString()),\n\t\t\t\t\t\t() -> log.info(\"Subscribe Complete\"),\n\t\t\t\t\t\ts -> s.request(4)\t// 取出 4 个，“回压”机制\n\t);\n\t\tThread.sleep(2000);\n\t}\n```\n\n### 2、Reactor 方式访问 Redis\nSpring Data Redis 中的客户端 Lettuce 支持 Reactive 方式，Jedis不支持。\n\n#### Spring Data Redis 中对 Reactive 的支持\n- ReactiveRedisConnection\n- ReactiveRedisConnectionFactory\n- ReactiveRedistemplate\n  - opsForXxx()\n\n使用 ReactiveRedisConnection 建立连接，这个连接是通过 ReactiveRedisConnectionFactory 构造的，与 Redistemplate 类似提供了 ReactiveRedistemplate。\n\n##### 一个简单的通过 Reactor 能力访问 Redis 的例子\n**创建表**\n```java\ndrop table t_coffee if exists;\n\ncreate table t_coffee (\n    id bigint auto_increment,\n    create_time timestamp,\n    update_time timestamp,\n    name varchar(255),\n    price bigint,\n    primary key (id)\n);\n```\n\n**插入数据**\n```java\ninsert into t_coffee (name, price, create_time, update_time) values ('espresso', 2000, now(), now());\ninsert into t_coffee (name, price, create_time, update_time) values ('latte', 2500, now(), now());\ninsert into t_coffee (name, price, create_time, update_time) values ('capuccino', 2500, now(), now());\ninsert into t_coffee (name, price, create_time, update_time) values ('mocha', 3000, now(), now());\ninsert into t_coffee (name, price, create_time, update_time) values ('macchiato', 3000, now(), now());\n```\n\n**构造对应的类**\n```java\npackage com.example.reactor_redis;\n\nimport lombok.AllArgsConstructor;\nimport lombok.Builder;\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\n\n@Data\n@AllArgsConstructor\n@NoArgsConstructor\n@Builder\npublic class Coffee {\n\n    private Long id;\n    private String name;\n    private Long price;\n}\n```\n\n**主要代码**\n```java\npackage com.example.reactor_redis;\n\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.ApplicationArguments;\nimport org.springframework.boot.ApplicationRunner;\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.data.redis.connection.ReactiveListCommands;\nimport org.springframework.data.redis.connection.ReactiveRedisConnectionFactory;\nimport org.springframework.data.redis.core.ReactiveHashOperations;\nimport org.springframework.data.redis.core.ReactiveStringRedisTemplate;\nimport org.springframework.jdbc.core.JdbcTemplate;\nimport org.springframework.transaction.annotation.EnableTransactionManagement;\nimport org.springframework.transaction.annotation.Transactional;\nimport reactor.core.publisher.Flux;\nimport reactor.core.publisher.Mono;\nimport reactor.core.scheduler.Schedulers;\n\nimport java.time.Duration;\nimport java.util.List;\nimport java.util.concurrent.CountDownLatch;\n\n@SpringBootApplication\n@Slf4j\npublic class DemoApplication implements ApplicationRunner {\n\tprivate static final String KEY = \"COFFEE_MENU\";\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(DemoApplication.class, args);\n\t}\n\n\t@Autowired\n\tJdbcTemplate jdbcTemplate;\n\t@Autowired\n\tReactiveStringRedisTemplate redisTemplate;\n\n\t/*\n\t* 使用 ReactiveRedisConnectionFactory 配置连接\n\t* */\n\t@Bean\n\tReactiveStringRedisTemplate reactiveStringRedisTemplate (ReactiveRedisConnectionFactory factory){\n\t\treturn new ReactiveStringRedisTemplate(factory);\n\t}\n\n\t@Override\n\tpublic void run(ApplicationArguments args) throws Exception {\n\t\tReactiveHashOperations<String, String, String> hasOps = redisTemplate.opsForHash();\n\t\tCountDownLatch cdl = new CountDownLatch(1);\n\n\t\tList<Coffee> list = jdbcTemplate.query(\"select * from t_coffee\", (rs, i) ->\n\t\t\tCoffee.builder()\n\t\t\t\t\t.id(rs.getLong(\"id\"))\n\t\t\t\t\t.name(rs.getString(\"name\"))\n\t\t\t\t\t.price(rs.getLong(\"price\"))\n\t\t\t\t\t.build());\n\n\t\tFlux.fromIterable(list)\n\t\t\t\t.publishOn(Schedulers.single())\t// 调用一个单线程\n\t\t\t\t.doOnComplete(() -> log.info(\"list ok\"))\n\t\t\t\t.flatMap(c -> {\t// flatMap将元素映射为流。map操作可以将数据元素进行转换/映射，得到一个新元素。\n\t\t\t\t\tlog.info(\"try to put {}, {}\", c.getName(), c.getPrice());\n\t\t\t\t\treturn hasOps.put(KEY, c.getName(), c.getPrice().toString());\n\t\t\t\t})\n\t\t\t\t.doOnComplete(() -> log.info(\"set to redis ok\"))\n\t\t\t\t.concatWith(redisTemplate.expire(KEY, Duration.ofMinutes(1)))\t// 设置有效期\n\t\t\t\t.doOnComplete(() -> log.info(\"set expire ok\"))\n\t\t\t\t.onErrorResume(e -> {\n\t\t\t\t\tlog.error(\"exception {}\", e.getMessage());\n\t\t\t\t\treturn Mono.just(false);\t// just就是一种比较直接的声明数据流的方式，其参数就是数据元素。\n\t\t\t\t})\n\t\t\t\t.subscribe(b -> log.info(b.toString()),\n\t\t\t\t\t\te -> log.error(\"Exception {}\", e.getMessage()),\n\t\t\t\t\t\t() -> cdl.countDown()); // 等待前面的执行完\n\n\t\tlog.info(\"Waiting\");\n\t\tcdl.await();\n\t}\n}\n```\n\n**在Redis中查看**\n```shell\nkeys *\nhgetall COFFEE_MENU\n```\n\n### 3、Reactive 方式访问 MongoDB\n**MongoDB 官方提供了支持 Reactive 的驱动**\n- mongodb-driver-reactivestreams\n\n**Spring Data MongoDB 中对 Reactive 的支持**\n- ReactiveMongoClientFactoryBean\n- ReactiveMongoDatabaseFactory\n- ReactiveMongoTemplate\n\n### 4、Reactive 方式访问 RDBMS\n\n#### Spring Data R2DBC\n**R2DBC （https://spring.io/projects/spring-data-r2dbc）**\n- Reactive Relational Database Connectivity \n\n**支持的数据库**\n- Postgres（io.r2dbc:r2dbc-postgresql） \n- H2（io.r2dbc:r2dbc-h2） \n- Microsoft SQL Server（io.r2dbc:r2dbc-mssql）\n\n**Spring Data R2DBC 提供的主要的类**\n- ConnectionFactory  \n- DatabaseClient\n- execute().sql(SQL) \n- inTransaction(db -> {})   \n- R2dbcExceptionTranslator  \n- SqlErrorCodeR2dbcExceptionTranslator\n  \n#### R2DBC Repository ⽀支持\n一些主要的类 \n- @EnableR2dbcRepositories  \n- ReactiveCrudRepository<T, ID>  \n  - @Table / @Id  \n  - 其中的⽅法返回都是 Mono 或者 Flux  \n  - 自定义查询需要⾃自⼰己写 @Query \n\n\n### 5、通过 AOP 打印数据访问层摘要\n\n#### AOP (面向切面编程)\n\n**AOP (Aspect OrientedProgramming):** 利用AOP可以对边缘业务进行隔离，降低无关业务逻辑耦合性。提高程序的可重用性，同时提高了开发的效率。\\\n**使用场景：** 一般用于日志记录，性能统计，安全控制，权限管理，事务处理，异常处理，资源池管理。\n\n#### Spring AOP 的⼀些核心概念\n- Aspect： 切⾯\n- Join Point： 连接点，Spring AOP里总是代表一次⽅法执行\n- Advice： 通知，在连接点执行的动作\n- Pointcut： 切入点，说明如何匹配连接点\n- Introduction： 引入，为现有类型声明额外的⽅法和属性\n- Target object： 目标对象\n- AOP proxy： AOP 代理对象，可以是 JDK 动态代理，也可以是 CGLIB 代理\n- Weaving： 织⼊，连接切⾯与⽬标对象或类型创建代理的过程\n\n#### 常用注解\n- @EnableAspectJAutoProxy 开启 Aspect 的支持，对于添加该注解的相关类去做一个 Proxy。\n- @Aspect 声明类是一个切面，另外需要添加一个可以成为Bean的注解。\n- 通知注解\n  - @Pointcut\t[切点表达式写法](https://blog.51cto.com/u_5914679/2092253)\n  - @Before\n  - @After 运行结束去 Advice\n  - @AfterReturning 返回之后 Advice\n  - @AfterThrowing 抛出异常才去做 Advice\n  - @Around 在被通知的方法调用之前和调用之后执行自定义的方法\n- Order 指定切面的执行顺序\n\n#### AOP 流程\n- 声明切面（@Aspect）\n- 定义切点（@Pointcut）\n- 定义通知（@Before / @After / @AfterReturning / @AfterThrowing / @Around）\n\n#### 性能拦截器的简单例子\n[代码仓库](https://gitee.com/geektime-geekbang/geektime-spring-family/tree/master/Chapter%205/performance-aspect-demo)\n##### PS：如何打印SQL\n- HikariCP: 本身不支持SQL输出，可以依赖 P6Spy 的库实现。\n- Alibaba Druid\n  - 具有内置的 SQL 输出。\n  - https://github.com/alibaba/druid/wiki/Druid 中使⽤ log4j2 进行⽇志输出 \n\n实例中使用 HikariCP 所以使用 P6Spy\n\n##### 导入依赖\n```xml\n<dependency>\n\t<groupId>p6spy</groupId>\n\t<artifactId>p6spy</artifactId>\n\t<version>3.9.1</version>\n</dependency>\n```\n\n##### 配置 p6spy\n```properties\nspring.datasource.driver-class-name=com.p6spy.engine.spy.P6SpyDriver\nspring.datasource.url=jdbc:p6spy:h2:mem:testdb\nspring.datasource.username=sa\nspring.datasource.password=\n```\n\n##### 新建 psy.properties 添加 p6spy 配置\n```properties\n# 单行日志\nlogMessageFormat=com.p6spy.engine.spy.appender.SingleLineFormat\n\n# 使用Slf4J记录sql\nappender=com.p6spy.engine.spy.appender.Slf4JLogger\n\n# 是否开启慢SQL记录\noutagedetection=true\n\n# 慢SQL记录标准，单位秒\noutagedetectioninterval=2\n```\n\n##### 声明切面、定义切点和通知\n```java\npackage aspect;\n\nimport lombok.extern.slf4j.Slf4j;\nimport org.aspectj.lang.ProceedingJoinPoint;\nimport org.aspectj.lang.annotation.Around;\nimport org.aspectj.lang.annotation.Aspect;\nimport org.aspectj.lang.annotation.Pointcut;\nimport org.springframework.stereotype.Component;\n\n// 1、声明切面\n@Aspect\n@Component\n@Slf4j\npublic class PerformanceAspect {\n\n\t// 3、定义通知\n    @Around(\"repositoryOps()\")\n    public Object logPerformance(ProceedingJoinPoint pjp) throws Throwable {\n        long startTime = System.currentTimeMillis();\n        String name = \"_\";\n        String result = \"Y\";\n\n        try{\n\t\t\t // 获取方法的名字\n            name = pjp.getSignature().toShortString();\n            return pjp.proceed();\n        }catch (Throwable t){\n            result = \"N\";\n            throw t;\n        }finally {\n            long endTime = System.currentTimeMillis();\n            log.info(\"{}; {}; {}ms\", name, result, endTime - startTime);\n        }\n    }\n\t// 2、定义切点\n\t// 增强 com.jq.coffe.repository 包下面的所有方法\n\t// execution 表示当\"()\"中指定的方法执行时被触发；第一个 \"*\" 表示返回任意类型；\"com.jq.coffe.repository\" 表示包名；\n    // 第一个 \"..\" 表示 repository 包及其子包；第二个 \"*\" 表示任意类；\"(..)\" 表示方法的任意参数个数\n    @Pointcut(\"execution(* com.jq.coffe.repository..*(..))\")\n    private void repositoryOps(){\n\n    }\n}\n```\n\n## 第六章 Spring MVC\n\n**Spring MVC 基本概念**\nDispatcherServlet\n- Controller\n- xxxResolver\n  - ViewResolver\n  - HandleExceptionResolver\n  - MultipartResolver\n- HandlerMapping\n\n**Spring MVC常用注解**\n- @Controller\n  - RestController (= @Controller + @ResponseBody)\n- RequetMapping\n  - @GetMapping / @PostMapping\n  - @PutMapping / @DeleteMapping\n- @RequestBody / @ResponseBody / @ResponseBody\n\n[一个简单的 Controller 实例](https://gitee.com/geektime-geekbang/geektime-spring-family/tree/master/Chapter%206/simple-controller-demo)\n\n### 1、Spring Application Context\n\n**关于上下文常用的接口及其实现**\n- BeanFactory\n  - DefaultListableBeanFactory\n- ApplicationContext\n  - ClassPathXmlApplicationContext\n  - FileSystemXmlApplicationContext\n  - AnnotationConfigApplicationContext\n- WebApplicationContext\n  \n一般情况下不直接使用 BeanFactory ，而是使用 ApplicationContext 。\n\n\n**Spring Web MVC 中的上下文层次结构**\n\n![Spring Web MVC 中的上下文层次结构](https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/images/mvc-contexts.gif)\n\nSpring Web MVC 上下文主要包含 Servlet WebApplicationContext 和 root WebApplicationContext，Servlet WebApplicationContext 继承 root WebApplicationContext。Servlet WebApplicationContext 主要包含 Controller、ViewResolver、handlerMapping等的Bean。root WebApplicationContext，Servlet 包含 Service、Repositories 等的Bean。程序先去 Servlet WebApplicationContext 中找 Bean ，如果找不到会进一步去 root WebApplicationContext 中找。在 AOP 增强时，如果需要增强子类中的 Bean，需要将增强放到子类的上下文中，如果需要增强父类中的 Bean，需要将增强放到父类的上下文中。如果是通用的将其放在父类中。[代码](https://gitee.com/geektime-geekbang/geektime-spring-family/tree/master/Chapter%206/context-hierarchy-demo)如下，[视频讲解](https://time.geekbang.org/course/detail/100023501-85418)。\n\n**写一个需要增强的类**\n```java\npackage com.example.context.model;\n\nimport lombok.AllArgsConstructor;\nimport lombok.extern.slf4j.Slf4j;\n\n@Slf4j\n@AllArgsConstructor\npublic class TestBean {\n\n    private String context;\n    public void hello(){\n        log.info(\"hello \" + context);\n    }\n}\n```\n\n**增强代码**\n```java\npackage com.example.context.foo;\n\nimport lombok.extern.slf4j.Slf4j;\nimport org.aspectj.lang.annotation.AfterReturning;\nimport org.aspectj.lang.annotation.Aspect;\n\n@Aspect\n@Slf4j\npublic class FooAspect {\n\n    @AfterReturning(\"bean(testBean*)\")  // 以 testBean 开头的Bean返回时增强\n    public void printAfter(){\n        log.info(\"after hello()\");\n    }\n}\n```\n\n**使用注解创建几个Bean，供后面增强功能测试**\n```java\npackage com.example.context.foo;\n\nimport com.example.context.model.TestBean;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.context.annotation.EnableAspectJAutoProxy;\n\n@Configuration\n@EnableAspectJAutoProxy\npublic class FooConfig {\n\n    @Bean\n    public TestBean testBeanX(){\n        return new TestBean(\"foo\");\n    }\n\n    @Bean\n    public TestBean testBeanY(){\n        return new TestBean(\"foo\");\n    }\n\n    // 增强\n    @Bean\n    public FooAspect fooAspect(){\n        return new FooAspect();\n    }\n}\n```\n\n**使用XML创建几个Bean，供后面增强功能测试**\n```java\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:aop=\"http://www.springframework.org/schema/aop\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n        http://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/aop\n        http://www.springframework.org/schema/aop/spring-aop.xsd\">\n\n    <aop:aspectj-autoproxy/>\n\n    <!-- 定义一个 id 为 testBeanX 的 Bean -->\n    <bean id=\"testBeanX\" class=\"com.example.context.model.TestBean\">\n        <!-- constructor-arg 是构造函数，构造函数初始化成员变量 -->\n        <constructor-arg name=\"context\" value=\"Bar\" />\n    </bean>\n\n\n<!--    定义一个 Bean，和下面的代码功能一样-->\n<!--    @Bean-->\n<!--    public FooAspect fooAspect(){-->\n<!--        return new FooAspect();-->\n<!--    }-->\n    <bean id=\"fooAspect\" class=\"com.example.context.foo.FooAspect\" />\n</beans>\n```\n\n**测试代码**\n```java\npackage com.example.context;\n\nimport com.example.context.foo.FooConfig;\nimport com.example.context.model.TestBean;\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.boot.ApplicationArguments;\nimport org.springframework.boot.ApplicationRunner;\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.context.annotation.AnnotationConfigApplicationContext;\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\n\n@SpringBootApplication\n@Slf4j\npublic class ContextApplication implements ApplicationRunner {\n\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(ContextApplication.class, args);\n\t}\n\n\t@Override\n\tpublic void run(ApplicationArguments args) throws Exception {\n\t\t// 加载 FooConfig 类中的一个 Context\n\t\tApplicationContext fooContext = new AnnotationConfigApplicationContext(FooConfig.class);\n\n\t\t// 使用给定的 fooContext 为父级，创建一个新的 ClassPathXmlApplicationContext，从给定的 XML 文件加载定义并自动刷新上下文。\n\t\tClassPathXmlApplicationContext barContext = new ClassPathXmlApplicationContext(\n\t\t\t\tnew String[] {\"applicationContext.xml\"}, fooContext);\n\n\t\t// 从 fooContext 中取名为 testBeanX 的 Bean，观察是否被增强\n\t\tTestBean bean = fooContext.getBean(\"testBeanX\", TestBean.class);\n\t\tbean.hello();\n\t\tlog.info(\"===============\");\n\n\t\t// 从 barContext 中取名为 testBeanX 的 Bean，观察是否被增强\n\t\tbean = barContext.getBean(\"testBeanX\", TestBean.class);\n\t\tbean.hello();\n\n\t\t// 从 barContext 中取父级 fooContext 中 testBeanY 的 Bean，观察是否被增强\n\t\tbean = barContext.getBean(\"testBeanY\", TestBean.class);\n\t\tbean.hello();\n\n\t}\n}\n```\n\n### 2、Spring MVC 的请求处理机制\nSpring MVC 是三层架构：表现层、业务层和持久层，具体如下图。推荐阅读[彻底读懂 springMVC 请求处理流程](https://cloud.tencent.com/developer/article/1649425)。\n\n![Spring MVC 架构图](https://ask.qcloudimg.com/http-save/6296056/ih4rv8o45f.png?imageView2/2/w/1620)\n\n#### Spring MVC 的请求处理流程\n\n所有请求都会通过 DispatcherServlet 来执行。一个请求的大致处理流程(可以看看 DispatcherServlet 的源码，主要方法是 doService ): \\\n\n**绑定一些 Attribute**\n- WebApplicationContext / LocaleResolver / Themeresolver\n\n**处理 Multipart**\n- 如果是 Multipart，则请求转为 MultipartHttpServletRequest\n\n**Handler 处理**\n- 找到对应的 Handler，执行 Controller 及前后置处理器逻辑\n\n**处理返回的 Model，渲染视图**\n\n详细流程如下图。\n![spring MVC 请求处理流程](https://ask.qcloudimg.com/http-save/6296056/h8202u7yaw.png?imageView2/2/w/1620)\n\n### 3、定义 Controller 处理方法\n#### 定义映射关系\n@Controller \\\n@RequestMapping\n- path / method  指定映射路径与⽅法 \n- params / headers 限定映射范围 \n- consumes / produces 限定请求与响应格式 \n\n一些快捷⽅式 \n- @RestController  \n- @GetMapping / @PostMapping / @PutMapping / @DeleteMapping / @PatchMapping\n\n\n#### 定义处理方法\n- @RequestBody / @ResponseBody / @ResponseStatus  \n- @PathVariable / @RequestParam / @RequestHeader\n- HttpEntity / ResponseEntity \n\n#### 定义类型转换\n⾃己实现 WebMvcConfigurer \n- Spring Boot 在 WebMvcAutoConfiguration 中实现了一个 \n- 添加自定义的 Converter (前面有例子，可以看看)\n- 添加自定义的 Formatter\n\n\n##### 添加自定义的 Formatter 实现类型转换\n```java\npackage com.example.springmvc.support;\n\nimport lombok.extern.slf4j.Slf4j;\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.lang3.math.NumberUtils;\nimport org.joda.money.CurrencyUnit;\nimport org.joda.money.Money;\nimport org.springframework.format.Formatter;\nimport org.springframework.stereotype.Component;\n\nimport java.text.ParseException;\nimport java.util.Locale;\n\n@Component\n@Slf4j\npublic class MoneyFormatter implements Formatter<Money> {\n    /**\n     * 处理 CNY 10.00 / 10.00 形式的字符串\n     * 校验不太严密，仅作演示\n     */\n    @Override\n    public Money parse(String text, Locale locale) throws ParseException {\n        // text 可能是是\"CNY 25.0\"或\"25.0\",这样两种形式。\n        log.info(\"Json to Money, Json: {}, Locale: {}\", text, locale);\n        if (NumberUtils.isParsable(text)) { // 检查字符串是否是可以转化为 number\n            return Money.of(CurrencyUnit.of(\"CNY\"), NumberUtils.createBigDecimal(text));\n        } else if (StringUtils.isNotEmpty(text)) {\n            String[] split = StringUtils.split(text, \" \");\n            if (split != null && split.length == 2 && NumberUtils.isParsable(split[1])) {\n                return Money.of(CurrencyUnit.of(split[0]),\n                        NumberUtils.createBigDecimal(split[1]));\n            } else {\n                throw new ParseException(text, 0);\n            }\n        }\n        throw new ParseException(text, 0);\n    }\n\n    @Override\n    public String print(Money money, Locale locale) {\n        if (money == null) {\n            return null;\n        }\n        return money.getCurrencyUnit().getCode() + \" \" + money.getAmount();\n    }\n}\n```\n\n#### 定义校\n- 通过 Validator 对绑定结果进⾏行行校验 \n- Hibernate Validator \n- @Valid 注解 \n- BindingResult  \n\n#### Multipart 上传\n- 配置 MultipartResolver  \n- Spring Boot ⾃自动配置 MultipartAutoConfiguration \n- ⽀持类型 multipart/form-data \n- MultipartFile 类型\n\n\n#### 代码实例\n\n##### 创建一个 NewCoffeeRequest 类。\n```java\npackage com.example.springmvc.controller.reqeust;\n\nimport lombok.Getter;\nimport lombok.Setter;\nimport lombok.ToString;\nimport org.joda.money.Money;\n\nimport javax.validation.constraints.NotEmpty;\nimport javax.validation.constraints.NotNull;\n\n@Getter\n@Setter\n@ToString\npublic class NewCoffeeRequest {\n    @NotEmpty\n    private String name;\n    @NotNull\n    private Money price;\n}\n```\n\n##### 具体的 Controller 方法\n```java\npackage com.example.springmvc.controller;\n\n\nimport com.example.springmvc.controller.reqeust.NewCoffeeRequest;\nimport com.example.springmvc.model.Coffee;\nimport com.example.springmvc.service.CoffeeService;\nimport lombok.extern.slf4j.Slf4j;\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.lang3.math.NumberUtils;\nimport org.apache.tomcat.util.http.fileupload.IOUtils;\nimport org.joda.money.CurrencyUnit;\nimport org.joda.money.Money;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.http.MediaType;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.validation.BindingResult;\nimport org.springframework.web.bind.annotation.*;\nimport org.springframework.web.multipart.MultipartFile;\n\nimport javax.validation.Valid;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.List;\n\n@Slf4j\n@Controller\n@RequestMapping(\"/coffee\")\npublic class CoffeeController {\n\n    @Autowired\n    private CoffeeService coffeeService;\n\n\t// 表单形式，此处表单提交的值会自动注入到对应的类对象 newCoffee 中，其实完整形式是：\n\t// addCoffee(@Valid @ModelAttribute NewCoffeeRequest newCoffee, BindingResult result)，但 @ModelAttribute 可以省略。\n\t// 如果是 Json 提交，需要使用 @RequestBody 接受。\n    @PostMapping(path = \"/\", consumes = MediaType.APPLICATION_FORM_URLENCODED_VALUE)\n    @ResponseBody\n    @ResponseStatus(HttpStatus.CREATED)\n    public Coffee addCoffee(@Valid NewCoffeeRequest newCoffee, BindingResult result){   //@Valid 是和 NewCoffeeRequest 类中的校验绑定的\n        if (result.hasErrors()){    // @Valid 抛出的错误，绑定到 BindingResult 上\n            log.warn(\"Binding Errors: {}\", result);\n            return null;\n        }\n        log.info(\"Receive new Coffee {}\", newCoffee);\n        Coffee coffee = Coffee.builder()\n                .name(newCoffee.getName())\n                .price(newCoffee.getPrice())\n                .build();\n        return coffeeService.saveCoffee(coffee);\n    }\n\n    /*\n    * 批量创建多个coffee，\n    * */\n    @PostMapping(path = \"/\", consumes = MediaType.MULTIPART_FORM_DATA_VALUE)\n    @ResponseBody\n    @ResponseStatus(HttpStatus.CREATED)\n    public List<Coffee> batchAddCoffee(MultipartFile file){\n        List<Coffee> coffees = new ArrayList<>();\n        BufferedReader reader = null;\n        try {\n            reader = new BufferedReader(new InputStreamReader(file.getInputStream()));\n            String str;\n            while ((str = reader.readLine()) != null){\n                String[] arr = StringUtils.split(str, \" \");\n                if (arr != null && arr.length == 2){\n                    Coffee coffee = Coffee.builder()\n                            .name(arr[0])\n                            .price(Money.of(CurrencyUnit.of(\"CNY\"), NumberUtils.createBigDecimal(arr[1])))\n                            .build();\n                    coffees.add(coffeeService.saveCoffee(coffee));\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            IOUtils.closeQuietly(reader);\n        }\n        return coffees;\n    }\n}\n```\n\n##### Postman 测试\n创建咖啡\n![](玩转Spring全家桶学习笔记/WX20220511-094520.png)\n\n批量创建咖啡\n\n![](玩转Spring全家桶学习笔记/WX20220511-094749.png)\n\n### 4、Spring MVC 中的各种机制 -- 视图处理\n\n#### 视图解析的实现基础\n\n视图解析是基于 ViewResolver 和 View 接口实现的\n- AbstracachingViewResolver\n- UrlBasedViewResolver\n- FreeMarkerViewResolver\n- ContentNegotiatiatingViewResolver\n- InternalResurceViewResolver\n\n#### DispatcherServlet 中的视图解析逻辑\n- initStrategies()\n  - initViewResolvers() 初始化了了对应 ViewResolver  \n- doDispatch()  \n  - processDispatchResult()  \n    - 没有返回视图的话，尝试 RequestToViewNameTranslator \n    - resolveViewName() 解析 View 对象\n\n#### @ResponseBody 的视图解析逻辑\n- 在 HandlerAdapter.handle() 的中完成了 Response 输出 \n  - RequestMappingHandlerAdapter.invokeHandlerMethod()  \n    - HandlerMethodReturnValueHandlerComposite.handleReturnValue()  \n      - RequestResponseBodyMethodProcessor.handleReturnValue() \n\n#### 重定向\n两种不同的重定向前缀 \n- redirect:  客户端发起 302 的跳转，url会变化\n- forward:   服务端发起的，url不会变化\n\n### 5、Spring MVC 中的常用视图\n\n#### Spring Boot 对 Jackson 的支持\n- JacksonAutoConfiguration\n  - Spring Boot 通过 @JsonComponent 注册 JSON 序列化组件\n  - Jackson20bjectMapperBuilderCustiomizer\n- JacksonHttpMessageConvertersConfiguration\n  - 增加 jackson-dataformat-xml 以支持 XML 序列化\n\n#### Spring Boot 中关于 Jackson 的实例\n将 Money 类**序列化**为 Json 格式输入到响应中；从请求中表示 Money 对象的字符串，**反序列化**为Moey对象。\n引入依赖\n```xml\n\t<!-- 增加Jackson的Hibernate类型支持 -->\n\t<dependency>\n\t\t<groupId>com.fasterxml.jackson.datatype</groupId>\n\t\t<artifactId>jackson-datatype-hibernate5</artifactId>\n\t\t<version>2.9.8</version>\n\t</dependency>\n\n\t<!-- 增加Jackson XML支持 -->\n\t<dependency>\n\t\t<groupId>com.fasterxml.jackson.dataformat</groupId>\n\t\t<artifactId>jackson-dataformat-xml</artifactId>\n\t\t<version>2.9.0</version>\n\t</dependency>\n```\n\n继承 StdSerializer 实现序列化器\n```java\npackage com.example.springmvc.support;\n\nimport com.fasterxml.jackson.core.JsonGenerator;\nimport com.fasterxml.jackson.databind.SerializerProvider;\nimport com.fasterxml.jackson.databind.ser.std.StdSerializer;\nimport org.joda.money.Money;\nimport org.springframework.boot.jackson.JsonComponent;\n\nimport java.io.IOException;\n\n/*\n* Money 序列化器，将 Money 序列化为字符串，写入文件。\n* */\n@JsonComponent\npublic class MoneySerializer extends StdSerializer<Money> {\n\n    protected MoneySerializer() {\n        super(Money.class);\n    }\n\n    @Override\n    public void serialize(Money money, JsonGenerator jsonGenerator, SerializerProvider serializerProvider) throws IOException {\n        jsonGenerator.writeNumber(money.getAmount());\n    }\n}\n```\n\n继承 StdDeserializer 实现序列化器\n```java\npackage com.example.springmvc.support;\n\nimport com.fasterxml.jackson.core.JacksonException;\nimport com.fasterxml.jackson.core.JsonParser;\nimport com.fasterxml.jackson.databind.DeserializationContext;\nimport com.fasterxml.jackson.databind.deser.std.StdDeserializer;\nimport org.joda.money.CurrencyUnit;\nimport org.joda.money.Money;\nimport org.springframework.boot.jackson.JsonComponent;\n\nimport java.io.IOException;\n\n/*\n* Money 反序列化器\n* */\n\n// 注册 JSON 序列化组件\n@JsonComponent\npublic class MoneyDeserializer extends StdDeserializer<Money> {\n    protected MoneyDeserializer() {\n        super(Money.class);\n    }\n\n    @Override\n    public Money deserialize(JsonParser jsonParser, DeserializationContext ctxt) throws IOException, JacksonException {\n        return Money.of(CurrencyUnit.of(\"CNY\"), jsonParser.getDecimalValue());\n    }\n}\n```\n\n注入 Hibernate5Module 模版\n```java\n\t/*\n\t* 注册一个额外的Jackson模块\n\t* 此处注释对程序似乎没有影响。\n\t* */\n\t// @Bean\n\t// public Hibernate5Module hibernate5Module() {\n\t// \treturn new Hibernate5Module();\n\t// }\n\n\t/*\n\t* 设置 json 输出缩紧，使用 curl 请求测试。\n\t* 测试方法：curl http://localhost:8080/coffee/4\n\t* */\n\t@Bean\n\tpublic Jackson2ObjectMapperBuilderCustomizer jacksonBuilderCustomizer(){\n\t\treturn builder ->builder.indentOutput(true);\n\t}\n```\n\n测试方案\n- 使用 Json 格式请求创建coffee\n- 使用 Form 格式请求创建coffee\n- 使用 curl http://localhost:8080/coffee/4 查看缩减效果\n- 请求头中添加 Accept: application/xml 查看响应效果\n\n[Json View demo](https://gitee.com/geektime-geekbang/geektime-spring-family/tree/master/Chapter%206/json-view-demo)\n\n#### thymeleaf 页面调用的简单例子\n\n[thymeleaf view demo](https://gitee.com/geektime-geekbang/geektime-spring-family/tree/master/Chapter%206/thymeleaf-view-demo)\n\n\n##### 创建一个简单的 create-order-form.html 页面\n```html\n<html xmlns:th=\"http://www.thymeleaf.org\">\n<body>\n<h2>Coffee Available Today</h2>\n<table>\n    <thead>\n    <tr>\n        <th>Coffee Name</th>\n        <th>Price</th>\n    </tr>\n    </thead>\n    <tbody>\n    <tr th:each=\"coffee : ${coffeeList}\">\n        <td th:text=\"${coffee.name}\">Espresso</td>\n        <td th:text=\"${coffee.price}\">CNY 12.0</td>\n    </tr>\n    </tbody>\n</table>\n<h2>Your Order</h2>\n<form action=\"#\" th:action=\"@{/order/}\" method=\"post\">\n    <label>Customer Name</label>\n    <input type=\"text\" name=\"customer\" />\n    <ul>\n        <li th:each=\"coffee : ${coffeeList}\">\n            <input type=\"checkbox\" name=\"items\" th:value=\"${coffee.name}\" />\n            <label th:text=\"${coffee.name}\">Espresso</label>\n        </li>\n    </ul>\n    <input type=\"submit\" value=\"Submit\"/>\n    <p th:text=\"${message}\">Message</p>\n</form>\n</body>\n</html>\n```\n\n##### 调用 html 页面\n```java\n/*\n* 呈现视图：\"create-order-form\"，thymeleaf 有一些默认的配置，包括前缀和后缀，\"create-order-form\"会拼接前缀和后缀返回。\n* */\n@GetMapping(path = \"/\")\npublic ModelAndView showCreateForm(){\n\treturn new ModelAndView(\"create-order-form\");\n}\n```\n\n##### form 创建订单，并且重定向\n```java\n@PostMapping(path = \"/\", consumes = MediaType.APPLICATION_FORM_URLENCODED_VALUE)\npublic String createOrder(@Valid NewOrderRequest newOrder, BindingResult result, ModelMap map){\n\t// ps: 使用@RequestBody会报错，参考： https://blog.csdn.net/qq_24089175/article/details/102568409\n\tif (result.hasErrors()){\n\t\tlog.warn(\"Binding Result: {}\", result);\n\t\tmap.addAttribute(\"message\", result.toString());\n\t\treturn \"create-order-form\";\n\t}\n\n\tlog.info(\"Receive new Order through Form {}\", newOrder);\n\tCoffee[] coffees = coffeeService.getCoffeeByName(newOrder.getItems()).toArray(new Coffee[]{});\n\tCoffeeOrder order = orderService.createOrder(newOrder.getCustomer(), coffees);\n\t// 重定向\n\treturn \"redirect:/order/\" + order.getId();\n}\n```\n\n##### 测试\n- 使用浏览器输入`http://localhost:8080/order/`。\n- 在页面上提交订单，发现会重定向。\n\n### 6、静态资源与缓存\n\n不建议在java程序中提供静态资源的服务，去设置缓存。一般有更合适的技术，比如 Nginx 、CMS 系统。\n\n**建议的资源访问⽅式**\n\n![](玩转Spring全家桶学习笔记/WX20220514-112926.png)\n\n#### Spring Boot 中的静态资源配置\n核⼼逻辑 \n- WebMvcConfigurer.addResourceHandlers()  \n  \n常⽤配置\n- spring.mvc.static-path-pattern=/**  \n- spring.resources.static-locations=classpath:/META-INF/resources/,classpath:/resources/,classpath:/static/,classpath:/public/ \n\n#### Spring Boot 中的缓存配置\n常⽤配置（默认时间单位都是秒） \n- ResourceProperties.Cache\n- spring.resources.cache.cachecontrol.max-age=时间 \n- spring.resources.cache.cachecontrol.no-cache=true/false \n- spring.resources.cache.cachecontrol.s-max-age=时间\n\n代码仓库：[cache demo](https://gitee.com/geektime-geekbang/geektime-spring-family/tree/master/Chapter%206/cache-demo)\n\n### 7、Spring MVC 中的异常处理机制\n\n#### Spring MVC 的异常解析\n核⼼接⼝\n- HandlerExceptionResolver \n\n实现类 \n- SimpleMappingExceptionResolver\n- DefaultHandlerExceptionResolver  \n- ResponseStatusExceptionResolver  \n- ExceptionHandlerExceptionResolver \n\n#### 异常处理方法\n处理方法\n- @ExceptionHandler \n\n添加位置\n- @Controller / @RestController\n- @ControllerAdvice / @RestControllerAdvice \n\n\n#### 一个异常处理的简单例子\n通过 throw 抛出异常，使用 @ResponseStatus 指定响应的错误码。\n\n代码实例: [exception demo](https://gitee.com/geektime-geekbang/geektime-spring-family/tree/master/Chapter%206/exception-demo)\n\n\n##### 异常调用代码\n```java\n@PostMapping(path = \"/\", consumes = MediaType.APPLICATION_FORM_URLENCODED_VALUE)\n@ResponseBody\n@ResponseStatus(HttpStatus.CREATED)\npublic Coffee addCoffee(@Valid @ModelAttribute NewCoffeeRequest newCoffee, BindingResult result){   //@Valid 是和 NewCoffeeRequest 类中的校验绑定的\n\tif (result.hasErrors()){    // @Valid 抛出的错误，绑定到 BindingResult 上\n\t\tlog.warn(\"Binding Errors: {}\", result);\n\t\tthrow new FormValidationException(result);\n\t}\n\tlog.info(\"Receive addCoffee new Coffee {}\", newCoffee);\n\tCoffee coffee = Coffee.builder()\n\t\t\t.name(newCoffee.getName())\n\t\t\t.price(newCoffee.getPrice())\n\t\t\t.build();\n\treturn coffeeService.saveCoffee(coffee);\n}\n\n@PostMapping(path = \"/\", consumes = MediaType.APPLICATION_JSON_UTF8_VALUE)\n@ResponseBody\npublic Coffee addJsonCoffee(@Valid @RequestBody NewCoffeeRequest newCoffee, BindingResult result){\n\tlog.info(\"Receive addJsonCoffee new Coffee {}\", newCoffee);\n\tif (result.hasErrors()){\n\t\tlog.warn(\"Binding Errors: {}\", result);\n\t\tthrow new ValidationException(result.toString());\n\t}\n\tCoffee coffee = Coffee.builder()\n\t\t\t.name(newCoffee.getName())\n\t\t\t.price(newCoffee.getPrice())\n\t\t\t.build();\n\treturn coffeeService.saveCoffee(coffee);\n}\n```\n\n##### 异常处理类\n```java\npackage com.example.springmvc.controller.exception;\n\nimport lombok.AllArgsConstructor;\nimport lombok.Getter;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.validation.BindingResult;\nimport org.springframework.web.bind.annotation.ResponseStatus;\n\n@ResponseStatus(HttpStatus.BAD_REQUEST)\n@AllArgsConstructor\n@Getter\npublic class FormValidationException extends RuntimeException {\n\n    private BindingResult result;\n}\n```\n\n##### 测试\n- 使用postman 发送 post（`http://localhost:8080/coffee/`） 请求，使用 form 指定 name ，不指定 price 。\n- 使用postman 发送 post（`http://localhost:8080/coffee/`） 请求，使用 json 不指定 name ，指定 price 。\n\n### 8、Spring MVC 的拦截器器\n#### 核⼼接⼝\n- HandlerInteceptor\n  - boolean preHandle()  \n  - void postHandle()  \n  - void afterCompletion() \n\n####  针对 @ResponseBody 和 ResponseEntity 的情况 \n- ResponseBodyAdvice  \n\n#### 针对异步请求的接⼝\n- AsyncHandlerInterceptor  \n- void afterConcurrentHandlingStarted()\n\n异步的时候不会自动执行 postHandle() 、Completion 等方法的。\n\n#### 拦截器的配置⽅式\n常规方法 \n- WebMvcConfigurer.addInterceptors()\n\nSpring Boot 中的配置 \n- 创建⼀个带 @Configuration 的 WebMvcConfigurer 配置类 \n- 不能带 @EnableWebMvc（想彻底⾃己控制 MVC 配置除外）\n\n#### 实例\n\n[SpringMVC实现拦截器-1](https://jiaoqiang2014.github.io/2022/04/15/SpringMVC%E5%AE%9E%E7%8E%B0%E6%8B%A6%E6%88%AA%E5%99%A8-1/)\n\n[SpringMVC实现拦截器_2](https://jiaoqiang2014.github.io/2022/06/08/SpringMVC%E5%AE%9E%E7%8E%B0%E6%8B%A6%E6%88%AA%E5%99%A8-2/)\n\n\n## 第七章 访问 Web 资源\n\n### 通过 RestTemplate 访问 Web 资源\n- Spring Boot 中没有自动配置 RestTemplate\n- Spring Boot 提供了 RestTemplateBuilder\n  - RestTemplateBuilder.build()\n\n#### 常用方法\nGET 请求\n- getForObject() / getForEntity()\n\nPOST 请求\n- postForObject() / postForEntity()\n\nPUT 请求\n- put()\n\nDELETE 请求\n- delete()\n\n#### 构造 URI\n构造 URI\n- UriComponentsBuilder\n\n构造相对于当前请求的 URI\n- ServletUriComponentsBuilder\n\n构造 Controller 的 URI\n- MvcUriComponentBuilder\n\n### RestTemplate 的高阶用法\n\n### 简单定制 RestTemplate\n\n### 通过 WebClient 访问 Web 资源\n\n#### 了解 WebClient\n\nWebClient 是一个以 Reactive 方式处理 HTTP 请求的非阻塞式的客户端。\n\n**支持的底层 HTTP 库**\n- Reactor Netty - ReactorClientHttpConnector\n- Jetty ReactiveStream HttpClient - JettyClientHttpConnector\n\n**创建 WebClient**\n- WebClient.create()\n- WebClient.builder()\n\n**发起请求**\n- get() / post() / put() / delete() / patch()\n\n**获得结果**\n- retrieve() / exchange()\n  \n**处理 HTTP Status**\n- onStatus()\n  \n**应答正文**\n- bodyToMono() / bodyToFlux()\n\n\n## 第八章 Web 开发进阶\n\n### 设计好的 RESTful Web Service\n\n“REST 提供了一组架构约束，当作为一个整体来应用时，强调组件交互的可伸缩性、接口的通⽤性、组件的独⽴部署、以及用来减少交互延迟、增强安全性、封装遗留系统的中间组件。” - Roy Thomas Fielding\n\n### 认识 HTTP ⽅方法\n\n安全是指不改变资源，幂等是指多次请求产生的效果一样。\n\n\n| 动作\t\t|  安全 / 幂等|\t\t用途\t |\n| ---   \t|   ---   \t|     ---\t  |\n| GET \t\t|\tY / Y \t|\t信息获取\t|\n| POST\t\t|\tN / N \t|\t该⽅法⽤途广泛，可⽤用于创建、更新或一次性对多个资源进⾏修改\t|\n| DELETE \t|\tN / Y \t|\t删除资源\t|\n| PUT \t\t|\tN / Y \t|\t更新或者完全替换⼀个资源\t|\n| HEAD \t\t|\tY / Y \t|\t获取与 GET ⼀样的 HTTP 头信息，但没有响应体\t|\n| OPTIONS \t|\tY / Y \t|\t获取资源支持的 HTTP 方法列表\t|\n| TRACE \t|\tY / Y \t|\t让服务器返回其收到的 HTTP 头\t|\n\n### HATEOAS\n\n### 使用 Spring Data REST 实现简单的超媒体服务\n\n#### 认识 HAL\n- Hypertext Application Language \nHAL 是一种简单的格式，为 API 中的资源提供简单一致的链接 \n\n#### HAL 模型 \n- 链接 \n- 内嵌资源 \n- 状态\n\n### Spring Data REST\nSpring Boot 依赖 \n- spring-boot-starter-data-rest\n\n常用注解与类 \n- @RepositoryRestResource  \n- Resource<T>  \n- PagedResource<T> \n\n### 如何访问 HATEOAS 服务\n\n配置 Jackson JSON \n- 注册 HAL ⽀支持 \n\n操作超链接 \n- 找到需要的 Link \n- 访问超链接\n\n### 分布式环境中如何解决 Session 的问题\n\n- 粘性会话 Sticky Session \n- 会话复制 Session Replication \n- 集中会话 Centralized Session\n\n#### 实现原理\n\n定制 HttpSession \n- 通过定制的 HttpServletRequest 返回定制的 HttpSession \n- SessionRepositoryRequestWrapper  \n- SessionRepositoryFilter  \n- DelegatingFilterProxy \n\n#### 基于 Redis 的 HttpSession\n引⼊依赖 \n- spring-session-data-redis \n\n基本配置 \n- @EnableRedisHttpSession  \n- 提供 RedisConnectionFactory \n- 实现 AbstractHttpSessionApplicationInitializer  \n  - 配置 DelegatingFilterProxy\n\n#### Spring Boot 对 Spring Session 的⽀持\napplication.properties \n- spring.session.store-type=redis  \n  - spring.session.timeout=  \n- server.servlet.session.timeout=  \n- spring.session.redis.flush-mode=on-save  \n- spring.session.redis.namespace=spring:session \n\n\n### 使用 WebFlux 代替 Spring MVC\n\n#### 认识 WebFlux\n\n什么是 WebFlux \n- 用于构建基于 Reactive 技术栈之上的 Web 应用程序 \n- 基于 Reactive Streams API ，运行在非阻塞服务器上 \n\n为什么会有 WebFlux \n- 对于⾮阻塞 Web 应⽤的需要 \n- 函数式编程\n\n关于 WebFlux 的性能 \n- 请求的耗时并不不会有很大的改善 \n- 仅需少量固定数量的线程和较少的内存即可实现扩展 \n\n#### WebMVC v.s. WebFlux\n- 已有 Spring MVC 应用，运行正常，就别改了\n- 依赖了⼤量阻塞式持久化 API 和⽹络 API，建议使用 Spring MVC \n- 已经使用了非阻塞技术栈，可以考虑使用 WebFlux \n- 想要使用 Java 8 Lambda 结合轻量级函数式框架，可以考虑 WebFlux\n\n#### WebFlux 中的编程模型\n- 基于注解的控制器\n- 函数式 Endpoints \n\n#### 基于注解的控制器器\n\n常用注解 \n- @Controller  \n- @RequestMapping 及其等价注解 \n- @RequestBody / @ResponseBody\n\n返回值 \n- Mono<T> / Flux<T> \n\n## 第九章 重新认识 Spring Boot\n\nSpring Boot 四大核心\n- 自动配置 - Auto Configuration\n- 起步依赖 - Starter Dependency\n- 命令行界面 - Spring Boot CLI\n- Actuator\n\n### 自动配置\n- 基于添加的 JAR 依赖⾃动对 Spring Boot 应⽤程序进⾏配置\n- 自动配置都在类 spring-boot-autoconﬁguration 中\n\n开启⾃动配置\n- @EnableAutoConfiguration \n  - exclude = Class<?>[] \n- @SpringBootApplication\n\n@SpringBootApplication 注解中包含了 @EnableAutoConﬁguration\n\n[一文搞懂🔥SpringBoot自动配置原理](https://juejin.cn/post/7046554366068654094#heading-17)\n\n### ⾃动配置的实现原理\n\n@EnableAutoConﬁguration\n- AutoConfigurationImportSelector 类\n- META-INF/spring.factories 文件\n  - org.springframework.boot.autoconfigure.EnableAutoConfiguration\n\nAutoConfigurationImportSelector 类通过调用 getCandidateConfigurations 方法，调用 SpringFactoriesLoader 类来加载 META-INF/spring.factories\n\n条件注解\n- @Conditional\n- @ConditionalOnClass\n- @ConditionalOnBean\n- @ConditionalOnMissingBean\n- @ConditionalOnProperty\n- ……\n\n### 以 DataSourceAutoConfiguration 自动配置为例\n- spring.factories 中包含 org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration\n- DataSourceAutoConfiguration 类中 @ConditionalOnClass({ DataSource.class, EmbeddedDatabaseType.class }) ，以 EmbeddedDatabaseType 为例。\n- 代码分析\n\t```java\n\t@Configuration(proxyBeanMethods = false)\n\t@ConditionalOnClass({ DataSource.class, EmbeddedDatabaseType.class })\t// 当类中有。。。\n\t@ConditionalOnMissingBean(type = \"io.r2dbc.spi.ConnectionFactory\")\n\t@AutoConfigureBefore(SqlInitializationAutoConfiguration.class)\n\t@EnableConfigurationProperties(DataSourceProperties.class)\n\t@Import({ DataSourcePoolMetadataProvidersConfiguration.class,\n\t\t\tDataSourceInitializationConfiguration.InitializationSpecificCredentialsDataSourceInitializationConfiguration.class,\n\t\t\tDataSourceInitializationConfiguration.SharedCredentialsDataSourceInitializationConfiguration.class })\n\tpublic class DataSourceAutoConfiguration {\n\n\t\t@Configuration(proxyBeanMethods = false)\n\t\t@Conditional(EmbeddedDatabaseCondition.class)\n\t\t@ConditionalOnMissingBean({ DataSource.class, XADataSource.class })\n\t\t@Import(EmbeddedDataSourceConfiguration.class)\t// 导入 EmbeddedDatabaseConfiguration 的配置\n\t\tprotected static class EmbeddedDatabaseConfiguration {\n\n\t\t}\n\t\t...\n\t}\n\t```\n\n\t```java\n\t@Configuration(proxyBeanMethods = false)\n\t@EnableConfigurationProperties(DataSourceProperties.class)\n\tpublic class EmbeddedDataSourceConfiguration implements BeanClassLoaderAware {\n\n\t\tprivate ClassLoader classLoader;\n\n\t\t@Override\n\t\tpublic void setBeanClassLoader(ClassLoader classLoader) {\n\t\t\tthis.classLoader = classLoader;\n\t\t}\n\n\t\t// 构造出一个 EmbeddedDatabase 数据源的 bean\n\t\t@Bean(destroyMethod = \"shutdown\")\n\t\tpublic EmbeddedDatabase dataSource(DataSourceProperties properties) {\n\t\t\treturn new EmbeddedDatabaseBuilder().setType(EmbeddedDatabaseConnection.get(this.classLoader).getType())\n\t\t\t\t\t.setName(properties.determineDatabaseName()).build();\n\t\t}\n\n\t}\n\t```\n\n### 观察⾃动配置的判断结果\n- 执行的参数中加入`--debug`,就可以打印出自动配置的类。\n\n这个结果是通过 ConditionEvaluationReportLoggingListener 输出的。\n\n#### ConditionEvaluationReportLoggingListener\n- Positive matches\n- Negative matches\n- Exclusions\n- Unconditional classes\n\n### 动⼿实现⾃⼰的⾃动配置\n1、编写 Java Conﬁg\n- @Configuration\n\n2、添加条件\n- @Conditional\n\n3、定位⾃动配置\n- META-INF/spring.factories\n\n#### 条件注解⼤家庭\n\n**条件注解**\n- @Conditional\n\n**类条件**\n- @ConditionalOnClass\n\n当存在一个类时会做什么\n\n- @ConditionalOnMissingClass\n\n当不存在一个类时会做什么\n\n**属性条件**\n- @ConditionalOnProperty\n\n可以使用@ConditionalOnProperty注解来控制@Configuration是否生效.\n\n通过其两个属性name以及havingValue来实现的，其中name用来从application.properties中读取某个属性值。\n如果该值为空，则返回false;\n如果值不为空，则将该值与havingValue指定的值进行比较，如果一样则返回true;否则返回false。\n如果返回值为false，则该configuration不生效；为true则生效。\n**Bean 条件**\n- @ConditionalOnBean\n\n存在某个 Bean 时做什么。\n\n- @ConditionalOnMissingBean\n\n存在某个 Bean 时做什么。\n\n- @ConditionalOnSingleCandidate\n\n上下文中存在一个 Bean 是做什么。\n\n**资源条件**\n- @ConditionalOnResource\n\n**Web 应⽤条件**\n- @ConditionalOnWebApplication\n- @ConditionalOnNotWebApplication\n\n**其他条件**\n- @ConditionalOnExpression\n- @ConditionalOnJava\n- @ConditionalOnJndi\n\n#### ⾃动配置的执⾏顺序\n- @AutoConfigureBefore\n\n指定该自动配置类在某些配置执行之前执行。\n\n- @AutoConfigureAfter\n\n指定该自动配置类在某些配置执行之后执行。\n\n- @AutoConfigureOrder\n\n指定该自动配置类的执行顺序。\n\n\n#### 动⼿实现⾃⼰的⾃动配置代码\n\n[代码](https://github.com/geektime-geekbang/geektime-spring-family/tree/master/Chapter%209)\n\n在类 autoconfigure-demo 启动时，自动实现 geektime 的自动配置。\n\n首先创建一个主工程 autoconfigure-demo，完成对它的自动配置。创建两个模块 geektime 和 geektime-spring-boot-autoconfigure ，通过 geektime-spring-boot-autoconfigure 实现对 geektime 的自动配置。\n\n**在 autoconfigure-demo 的 pom 中引入 对 geektime-spring-boot-autoconfigure 和 geektime 的依赖**\n```html\n<dependency>\n\t<groupId>com</groupId>\n\t<artifactId>geektime</artifactId>\n\t<version>0.0.1-SNAPSHOT</version>\n</dependency>\n<dependency>\n\t<groupId>com.geektimeAutoconfigure</groupId>\n\t<artifactId>geektime-spring-boot-autoconfigure</artifactId>\n\t<version>0.0.1-SNAPSHOT</version>\n</dependency>\n```\n\n**在 geektime 中写一些简单的代码，代表需要自动配置的内容**\n```java\npackage com.geektime;\n@Slf4j\npublic class GreetingApplicationRunner implements ApplicationRunner {\n\tprivate String name;\n\n\tpublic GreetingApplicationRunner(){\n\t\tthis(\"Greeting\");\n\t}\n\n\tpublic GreetingApplicationRunner(String name){\n\t\tthis.name = name;\n\t\tlog.info(\"Initializing GreetingApplicationRunner for {}.\", name);\n\t}\n\n\t@Override\n\tpublic void run(ApplicationArguments args) throws Exception {\n\t\tlog.info(\"Hello everyone! We all like Spring!\");\n\t}\n}\n```\n\n**实现真正的自动配置类** \\\n首先，引入对 geektime 的依赖\n```java\n<dependency>\n\t<groupId>com</groupId>\n\t<artifactId>geektime</artifactId>\n\t<version>0.0.1-SNAPSHOT</version>\n\t<scope>provided</scope>\n</dependency>\n```\n\n然后，在 META-INF/spring.factories 中将 eektime-spring-boot-autoconfigure 添加进去。\n\n```properties\norg.springframework.boot.autoconfigure.EnableAutoConfiguration=\\\ncom.geektimeAutoconfigure.GreetingAutoConfiguration\n```\n\n接下来，实现具体的自动配置类\n```java\npackage com.geektimeAutoconfigure;\n\n@Slf4j\n@Configuration\n// 只用当 classPath 中存在 GreetingApplicationRunner.class 的时候才会生效。\n@ConditionalOnClass(GreetingApplicationRunner.class)\npublic class GreetingAutoConfiguration {\n    @Bean\n//     在GreetingApplicationRunner 上下文不存在这样一个Bean的时候才会继续下面操作。\n    @ConditionalOnMissingBean(GreetingApplicationRunner.class)\n    // 判断 greeting.enabled 的属性，当值为 true 时才会生效，matchIfMissing = true 表示当 greeting.enabled 没有配置时，默认值也为 true。\n\t// greeting.enabled 可以在配置文件中添加：greeting.enabled=true。注意是 autoconfigure-demo 中的配置文件。\n    @ConditionalOnProperty(name = \"greeting.enabled\", havingValue = \"true\", matchIfMissing = true)\n    public GreetingApplicationRunner GreetingAutoConfiguration(){\n        log.info(\"new a GreetingApplicationRunner\");\n        return new GreetingApplicationRunner();\n    }\n}\n```\n\n运行结果\n\n```bash\nc.e.a.AutoconfigureDemoApplication       : No active profile set, falling back to 1 default profile: \"default\"\nc.g.GreetingAutoConfiguration            : new a GreetingApplicationRunner\ncom.geektime.GreetingApplicationRunner   : Initializing GreetingApplicationRunner for Greeting.\nc.e.a.AutoconfigureDemoApplication       : Started AutoconfigureDemoApplication in 1.562 seconds (JVM running for 2.176)\ncom.geektime.GreetingApplicationRunner   : Hello everyone! We all like Spring!\n```\n\n可以看出“Initializing GreetingApplicationRunner for Greeting.” 实现了对 “Hello everyone! We all like Spring!” 的自动配置。\n\n**结论** \\\n从上面的代码可以总结，spring Boot 的自动配置是通过基于条件注解的逻辑实现，需要注意的是 条件注解是在Spring 4 中引进的。\n\n### 如何在低版本 Spring 中快速实现类似自动配置的功能\n\n#### 需求与问题\n\n核⼼的诉求\n- 现存系统，不打算重构\n- Spring 版本3.x，不打算升级版本和引⼊ Spring Boot\n- 期望能够在少改代码的前提下实现⼀些功能增强\n\n⾯临的问题\n- 3.x 的 Spring 没有条件注解\n- ⽆法⾃动定位需要加载的⾃动配置\n\n#### 核⼼解决思路\n\n需要解决的问题一：条件判断\n- 通过 BeanFactoryPostProcessor 进⾏判断\n\n需要解决的问题二：配置加载\n- 编写 Java Conﬁg 类\n- 引⼊配置类\n  - 通过 component-scan\n  - 通过 XML ⽂件 import\n\n#### Spring 的两个扩展点\n\nBeanPostProcessor\n- 针对 Bean 实例\n- 在 Bean 创建后提供定制逻辑回调\n\nBeanFactoryPostProcessor\n- 针对 Bean 定义\n- 在容器创建 Bean 前获取配置元数据\n- Java Conﬁg 中需要定义为 static ⽅法\n\n关于 Bean 的⼀些定制\n\nLifecycle Callback\n- InitializingBean / @PostConstruct / init-method \n- DisposableBean / @PreDestroy / destroy-method \n\n\nXxxAware 接⼝\n- ApplicationContextAware\n- BeanFactoryAware\n- BeanNameAware\n\n#### ⼀些常⽤操作\n\n判断类是否存在\n- ClassUtils.isPresent() \n\n判断 Bean 是否已定义\n- ListableBeanFactory.containsBeanDefinition()\n- ListableBeanFactory.getBeanNamesForType()\n\n注册 Bean 定义\n- BeanDefinitionRegistry.registerBeanDefinition()\n  - GenericBeanDefinition\n- BeanFactory.registerSingleton()\n\n#### 低版本 Spring 中快速实现类似自动配置功能代码\n\n[代码](https://github.com/geektime-geekbang/geektime-spring-family/tree/master/Chapter%209)\n\n在类 autoconfigure-demo 启动时，自动实现 geektime 的自动配置。\n\n首先创建一个主工程 autoconfigure-demo，完成对它的自动配置。创建两个模块 geektime 和 geektime-autoconfigure-backport ，通过 geektime-autoconfigure-backport 实现对 geektime 的自动配置。\n\n\n```java\n\n```\n\n```java\n\n```\n\n```java\n\n```\n\n```java\n\n```\n\n### 了解起步依赖及其实现原理\n\n#### 关于 Maven 依赖管理的一些⼩技巧\n\n了解你的依赖 \n- mvn dependency:tree  \n- IDEA Maven Helper 插件\n\n\n排除特定依赖 \n- exclusion\n\n\n统一管理依赖 \n- dependencyManagement  \n- Bill of Materials - bom\n\n#### Spring Boot 的起步依赖\n\nStarter Dependencies \n- 直接面向功能 \n- 一站获得所有相关依赖，不再复制粘贴 \n\n官方的 Starters \n- spring-boot-starter-* \n\n#### 定制⾃己的起步依赖\n\n\n```java\n\n```\n\n```java\n\n```\n\n```java\n\n```\n\n```java\n\n```","tags":["SpringMVC","SpringBoot","Spring"],"categories":["Spring 全家桶系列"]},{"title":"初识ThreadLocal","url":"/2022/04/16/初识ThreadLocal/","content":"\n# 1、ThreadLocal 使用实例\n来源：[廖雪峰Java教程](https://www.liaoxuefeng.com/wiki/1252599548343744/1306581251653666)\n```java\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.TimeUnit;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        ExecutorService es = Executors.newFixedThreadPool(3);\n        String[] users = new String[] { \"Bob\", \"Alice\", \"Tim\", \"Mike\", \"Lily\", \"Jack\", \"Bush\" };\n        for (String user : users) {\n            es.submit(new Task(user));\n        }\n        es.awaitTermination(3, TimeUnit.SECONDS);\n        es.shutdown();\n    }\n}\n\nclass UserContext implements AutoCloseable {    // \n    private static final ThreadLocal<String> userThreadLocal = new ThreadLocal<>();\n\n    public UserContext(String name) {\n        userThreadLocal.set(name);\n        System.out.printf(\"[%s] init user %s...\\n\", Thread.currentThread().getName(), UserContext.getCurrentUser());\n    }\n\n    public static String getCurrentUser() {\n        return userThreadLocal.get();\n    }\n\n    @Override\n    public void close() {\n        System.out.printf(\"[%s] cleanup for user %s...\\n\", Thread.currentThread().getName(),\n                UserContext.getCurrentUser());\n        userThreadLocal.remove();\n    }\n}\n\nclass Task implements Runnable {\n\n    final String username;\n\n    public Task(String username) {\n        this.username = username;\n    }\n\n    @Override\n    public void run() {\n        try (UserContext ctx = new UserContext(this.username)) {\n            new Task1().process();\n            new Task2().process();\n            new Task3().process();\n        }\n    }\n}\n\nclass Task1 {\n    public void process() {\n        try {\n            Thread.sleep(100);\n        } catch (InterruptedException e) {\n        }\n        System.out.printf(\"[%s] check user %s...\\n\", Thread.currentThread().getName(), UserContext.getCurrentUser());\n    }\n}\n\nclass Task2 {\n    public void process() {\n        try {\n            Thread.sleep(100);\n        } catch (InterruptedException e) {\n        }\n        System.out.printf(\"[%s] %s registered ok.\\n\", Thread.currentThread().getName(), UserContext.getCurrentUser());\n    }\n}\n\nclass Task3 {\n    public void process() {\n        try {\n            Thread.sleep(100);\n        } catch (InterruptedException ignored) {\n        }\n        System.out.printf(\"[%s] work of %s has done.\\n\", Thread.currentThread().getName(),\n                UserContext.getCurrentUser());\n    }\n}\n\n```\n\n# 2、ThreadLocal 结构\n`ThreadLocal`类里边定义了一个`ThreadLocalMap`静态内部类，`ThreadLocalMap`里边又有一个`static class Entry extends WeakReference<ThreadLocal<?>>`{}。除此之外，`ThreadLocalMap`中定义了`private Entry[] table。`因此，`ThreadLocal`的结构如下：\n![](初识ThreadLocal/ThreadLocal.png)\n\n\n```java\npublic class ThreadLocal<T> {\n\n    static ThreadLocalMap createInheritedMap(ThreadLocalMap parentMap) {\n        return new ThreadLocalMap(parentMap);\n    }\n\n    static class ThreadLocalMap {\n        static class Entry extends WeakReference<ThreadLocal<?>> {\n            /** The value associated with this ThreadLocal. */\n            Object value;\n\n            Entry(ThreadLocal<?> k, Object v) {\n                super(k);\n                value = v;\n            }\n        }\n\n        /**\n         * The initial capacity -- MUST be a power of two.\n         */\n        private static final int INITIAL_CAPACITY = 16;\n\n        /**\n         * The table, resized as necessary.\n         * table.length MUST always be a power of two.\n         */\n        private Entry[] table;\n\n        /**\n         * The number of entries in the table.\n         */\n        private int size = 0;\n\n        /**\n         * The next size value at which to resize.\n         */\n        private int threshold; // Default to 0\n\n        ThreadLocalMap(ThreadLocal<?> firstKey, Object firstValue) {\n            table = new Entry[INITIAL_CAPACITY];\n            int i = firstKey.threadLocalHashCode & (INITIAL_CAPACITY - 1);\n            table[i] = new Entry(firstKey, firstValue);\n            size = 1;\n            setThreshold(INITIAL_CAPACITY);\n        }\n        // ...\n    }\n    // ...\n}\n```\n### 内存泄露问题\n`ThreadLocalMap`中的key是一个弱引用，垃圾回收时就会被回收。如果`ThreadLocalMap`对应的线程依旧存活，那么value就依旧具有强引用而不会被回收，从而导致内存泄漏。解决内存泄漏的方法：直接调用remove()方法 (try{}finally{})，将value也置为 NULL。\n\n# 3、结合`Thread`理解`ThreadLoal`\n`Thread`类中包含一个`ThreadLocal.ThreadLocalMap`类型的成员变量`threadLocals`，因此每一个`Thread`都有一个`ThreadLocalMap`。\n```java\npublic class Thread implements Runnable {\n    /* ThreadLocal values pertaining to this thread. This map is maintained\n     * by the ThreadLocal class. */\n    ThreadLocal.ThreadLocalMap threadLocals = null;\n}\n```\n`ThreadLoal`set或get时，会先获取当前的`thread`，其实操作的就是`thread`的`threadLocals`,代码如下：\n```java\npublic class ThreadLocal<T> {\n\n    public T get() {\n        Thread t = Thread.currentThread();\n        ThreadLocalMap map = getMap(t);\n        if (map != null) {\n            ThreadLocalMap.Entry e = map.getEntry(this);\n            if (e != null) {\n                @SuppressWarnings(\"unchecked\")\n                T result = (T)e.value;\n                return result;\n            }\n        }\n        return setInitialValue();\n    }\n\n    public void set(T value) {\n        Thread t = Thread.currentThread();\n        ThreadLocalMap map = getMap(t);\n        if (map != null)\n            map.set(this, value);\n        else\n            createMap(t, value);\n    }\n\n    ThreadLocalMap getMap(Thread t) {\n        return t.threadLocals;\n    }\n}\n```\n在set方法中，最终是`map.set(this, value)`，这儿的this是Thread的一个实例,因此map结构是 (线程 --> Object)。\n\n## 思考：`Entry`类数组的作用？\n\n# 3、ThreadLocal 使用场景\n- ThreadLocal 相当于是线程的本地缓存，因此对可以存储一些属于该线程的数据，防止竞争。\n- 对于当前线程多次使用的的数据可以使用 ThreadLocal 存储，通过 get 方法就可以获得。比如，当前用户的 session 会在程序中多次使用，定义一个 ThreadLocal 存储，每次使用时 get 即可。\n\n### 参考：\n1、[Guide ThreadLocal 关键字解析](https://github.com/Snailclimb/JavaGuide/blob/main/docs/java/concurrent/threadlocal.md)\n","tags":["java","ThreadLocal"],"categories":["java 语言"]},{"title":"秒杀项目总结","url":"/2022/04/16/秒杀项目总结/","content":"\nconfiguration\n---\n该配置文件说明如何在本地搭建起环境，包括启动 mysql、启动虚拟机、启动 redis。\n## 一、Mysql启动\n- 打开navicat 连接 127.0.0.1 即可。 \n- 可以使用 http://www.localhost:8080/demo/db/get 测试\n\n## 二、Redis 启动\nredis 是使用 multipass 安装的虚拟机需要先启动虚拟机，然后在虚拟机中启动redis。\n\n### 1、启动 multipass\n```shell\nmultipass info -all\nmultipass shell XXX(host)\n```\n参考链接：http://www.manongjc.com/detail/21-gtzvxvzjtoaxswf.html\n\n### 2、启动 redis\n```shell\ncd /usr/local/redis\nredis-server redis.conf\nredis-cli\nauth 123456\n```\n可以使用 http://www.localhost:8080/demo/redis/get 测试\n\n## 三、压测\n### 1. 图形化压测\n\n### 2. 命令行压测\n首先，需要将jar包启动（参考`Spring Boot打jar包`）。然后，使用jmeter压测。\n```shell\njmeter.sh -n -t /Users/jq/Desktop/goods_list.jmx -l result.jtl\n```\n如果OOM，可以使用下面命令设置更大的JVM堆栈内存。\n```shell\nJVM_ARGS=\"-Xms512m -Xmx5g\" jmeter.sh -n -t /Users/jq/Desktop/goods_list.jmx -l result.jtl\n```\n\n## 四、Spring Boot打war包。\n### 1. 添加依赖\n```html\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-tomcat</artifactId>\n    <scope>provided</scope>\n</dependency>\n```\n\n### 2. 添加\n```html\n<build>\n    <finalName>${project.artifactId}</finalName>\n    <plugins>\n        <plugin>\n            <groupId>org.apache.maven.plugins</groupId>\n            <artifactId>maven-war-plugin</artifactId>\n            <configuration>\n                <failOnMissingWebXml>false</failOnMissingWebXml>\n            </configuration>\n        </plugin>\n        <plugin>\n            <artifactId>maven-compiler-plugin</artifactId>\n            <version>3.1</version>\n            <configuration>\n                <fork>true</fork\n            </configuration>\n        </plugin>\n    </plugins>\n</build>\n```\n\n### 3. 修改\n```html\n<groupId>org.imooc</groupId>\n<artifactId>miaosha</artifactId>\n<version>1.0-SNAPSHOT</version>\n<packaging>war</packaging>\n```\n同时，把packaging中的jar修改为war。\n\n### 4. 修改MainApplication类\n```java\n@SpringBootApplication\npublic class MainApplication extends SpringBootServletInitializer {\n\n    public static void main(String[] args) {\n        SpringApplication.run(MainApplication.class, args);\n    }\n\n    @Override\n    protected SpringApplicationBuilder configure(SpringApplicationBuilder builder){\n        return builder.sources(MainApplication.class);\n    }\n}\n```\n\n### 5. brew 安装 tomcat@9（和java8匹配) \\\nBrew会默认安装在/opt/homebrew/Cellar/目录下。\n\n### 6. 配置tomcat快速启动\n```shell\nalias tomcatstart=/opt/homebrew/Cellar/tomcat@9/9.0.60/libexec/bin/startup.sh\nalias tomcatstop=/opt/homebrew/Cellar/tomcat@9/9.0.60/libexec/bin/shutdown.sh\n```\n\n### 7. 打成 war 包 \n```shell\nmvn clean package\n```\n\n在miaosha/target目录下生成miasma.war包。将miasma.war拷贝到 /opt/homebrew/Cellar/tomcat@9/9.0.60/libexec/webapps 目录下。\n\n### 8. tomcatstart 启动tomcat。 \\\n输入http://www.localhost:8080测试tomcat是否搭建成功。输入 http://www.localhost:8080/miaosha/login/to_login， 查看登录界面，但目前不能登录，需要在/opt/homebrew/Cellar/tomcat@9/9.0.60/libexec/webapps/Root 目录下添加一些资源。\n\n## 五、Spring Boot打jar包\n### 1、添加依赖\n```html\n<build>\n    <finalName>${project.artifactId}</finalName>\n    <plugins>\n        <plugin>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-maven-plugin</artifactId>\n        </plugin>\n        <plugin>\n            <artifactId>maven-compiler-plugin</artifactId>\n            <version>3.1</version>\n            <configuration>\n                <fork>true</fork>\n            </configuration>\n        </plugin>\n    </plugins>\n</build>\n```\n\n### 2、修改\n```html\n<groupId>org.imooc</groupId>\n<artifactId>miaosha</artifactId>\n<version>1.0-SNAPSHOT</version>\n<packaging>jar</packaging>\n```\n\n\n### 3、打成 jar 包\n```shell\nmvn clean package\n```\n\n在miaosha/target目录下生成miasma.jar包\n\n### 4、运行jar，并输出到nohup文件。\n```shell\nnohup java -jar miaosha.jar &\n```\n\n### 5、测试\n输入 http://www.localhost:8080/miaosha/login/to_login， 查看登录界面，并且进行压测。 \\\n输入 tail -f nohup.out 可以查看日志的末尾输出。\n\n## 五、压测 redis\n```shell\nredis-benchmark -a 123456 -h 127.0.0.1 -p 6379 -c 100 -n 100000\n\nredis-benchmark -a 123456 -h 127.0.0.1 -p 6379 -q -d 100\n\nredis-benchmark -a 123456 -t set,lpush -n 100000 -q\n\n# 只测试单条命令\nredis-benchmark -a 123456 -n 100000 -q script load \"redis.call('set','foo','bar')\"\n```\n\n## 六、页面优化技术\n- 页面缓存 + URL缓存 + 对象缓存 \n- 页面静态化（不需要重复下载页面，只需要下载动态的），前后端分离\n- 静态资源优化\n- CDN优化\n\n### 1、页面缓存\n将 goods_list 页面的信息写入 redis，设置了60s的缓存时间。可以下命令测试：\n```shell\nkeys GoodsKey:gl\nget GoodsKey:gl\n```\n\n### 2、URL 缓存\n和页面缓存大致一样，给 goods_detail 页面添加缓存，不同于 goods_list 页面的是 goods_detail 页面需要加用户的标号：\"1\"（http://www.localhost:8080/goods/to_detail/1）。\n\n### 3、对象缓存\n此处的对象指的是用户对象，通过用户id将用户的信息写入缓存。\n\nMiaoshaUserService 类中的 updatePassword 方法，如何更新数据库密码。\n\n### 4、页面静态化\n将数据存在浏览器中，主要技术有：AngularJS、Vue.js等\n此处使用简单的。\n\n服务端不直接返回html，只返回页面上动态的数据。在前端html页面中接受这些动态的数值即可。\n\n#### 思考：如何验证客户端加载了浏览器的本地缓存而不是服务端的数据？\\\n304状态码表示服务端数据未改变，可直接使用客户端未过期的缓存。304状态码返回时不包含任何响应的主体部分。\n请求首部包含`If-Modified-Since: Mon, 11 Apr 2022 10:07:49 GMT`，服务端会和资源的最近更新时间比较，确定是不是需要返回资源。不需要则返回304状态码，具体如下：\n```html\nHTTP/1.1 304\nLast-Modified: Mon, 11 Apr 2022 10:07:49 GMT\nDate: Mon, 11 Apr 2022 10:10:19 GMT\n```\n#### 进一步优化\n上面虽然没有直接下载服务端的数据，但还是请求了一次服务端。通过在静态资源中添加设置静态资源的有效时间，不访问服务器，直接使用客户端的缓存。\\\n#### 验证\n查看网页请求，发现响应如下：\n```html\nHTTP/1.1 200\nLast-Modified: Mon, 11 Apr 2022 10:07:49 GMT\nContent-Length: 4818\nAccept-Ranges: bytes\nContent-Type: text/html\nCache-Control: max-age=3600\nDate: Mon, 11 Apr 2022 10:43:17 GMT\n```\n`Cache-Control: max-age=3600`字段表示该资源可以在3600ms内复用。\n\n## 问题1：库存会被减成负值\n#### 原因：两个人同时减库存时，调用的sql语句如下：\n```java\n@Update(\"update miaosha_goods set stock_count = stock_count - 1 where goods_id = #{goodsId}”)\n```\n当只有一个库存时会降为-1，此时可以在sql中加库存大于0的判断如下：\n```java\n@Update(\"update miaosha_goods set stock_count = stock_count - 1 where goods_id = #{goodsId} and stock_count > 0”)`）\n```\n\n## 问题2：一个用户购买了两个同一个商品。\n#### 原因：库存为10，同一个用户同时发出两个请求，同时进入了判断库存等方法，导致一个用户买到两个商品。\n解决思路：购买流程是：减库存 -> 下订单，下订单的时候有个订单表，有用户id和商品id，此处在订单表中给这两个字段建立联合唯一索引。这样创建订单时，如此该用户存在一个订单，再下另一个订单时就会出现重复。注意：在创建订单的函数前加`@Transactional`。\n如果只给用户id建立唯一索引可以不？不行，允许用户秒杀其他商品。\n\n### 5、静态资源优化\n1. JS/CSS 压缩，减少流浪；\n2. 多个 JS/CSS 组合\n3. Tengine 在nginx基础上开发的\nCDN:内容分发网络。 \n\n## 七、秒杀接口优化\n### 方案：\n- 把秒杀商品信息加载到redis，减少mysql的访问。\n- 内存标记，减少一次redis查商品库存的访问：使用map（goodsId -> boolean）， false表示还有库存，true表示没有库存，则秒杀结束。接下来的关于goodsId的请求不在访问redis，直接返回。\n- 通过在redis中预减库存，当库存不足，直接返回，不需要进一步查询Redis中的订单信息，以判断是否秒杀成功。减少了redis的访问。\n- 使用rabbitmq实现异步下单，达到削峰的作用。\n### 秒杀流程：\n- 系统初始化，把商品库存数量加载到redis。\n- 收到请求，内存标记，减少redis访问：\n- redis预减库存，如果库存不足，设置该goodsId的map值为true，然后直接返回。\n- 请求入队，立即返回排队中。\n- 请求出队，生成订单，减少库存。\n- 客户端轮询，是否秒杀成功。\n\n#### 环境安装\n安装 RabbitMQ。\n```shell\nsudo apt-get install erlang\nerl\n```\n以上命令能正常输出说明`erlang`安装成功。接下来安装、启动并验证`rabbitmq`是否在监听5672端口。\n```shell\nsudo apt-get install rabbitmq-server\nsudo rabbitmq-server\nnetstat -nap | grep 5672\n```\n关闭`rabbitmq`。\n```shell\nsudo rabbitmqctl stop\n```\n\n#### 设置一个 rabbitmq 的用户名和密码，默认存在一个用户 guest，密码为 guest。\n```shell\nrabbitmqctl add_user YOUR_USERNAME YOUR_PASSWORD\nrabbitmqctl set_user_tags YOUR_USERNAME administrator\nrabbitmqctl set_permissions -p / YOUR_USERNAME \".*\" \".*\" \".*\"\n```\n\n### 扩展\n- Nginx水平扩展。\n- 分库分表\n\n## 八、安全优化\n- 秒杀接口地址隐藏\n- 数学公式验证码（可以削峰）\n- 接口限流放刷\n\n### 1、秒杀接口地址隐藏\n思路：秒杀开始之前，先去请求接口获取秒杀地址。\n- 接口改造，带上PathVariable参数。\n- 添加生成地址的接口。\n- 秒杀收到请求，先验证PathVariable\n\n#### 流程\n秒杀开始，用户点击秒杀按钮时，在后端使用uuid+DM5生成一个str，并且以`用户id_商品id`为键，`str`为值存入redis。前端通过接口请求到这个str，拼接到路径中请求后端。后端取出这个str后和自己生成的oldStr对比（redis中的str），如果一致，则进入秒杀流程。\n##### 问题：\n有人先请求前端的接口得到str，然后去访问秒杀接口，可行吗？？？\n\n### 2、数学公式验证码\n- 添加生成验证码的接口。\n- 在获取秒杀路径的时候，验证验证码。\n- ScriptEngine使用。\n\n#### 流程\n秒杀开始时，前端请求后端生成验证码，然后将生成的验证码信息以`vc_用户id_秒杀商品id -> 验证码结果`的形式存储在redis中，同时将验证码发给前端。前端展示给用户，用户输入结果，点击秒杀按钮。前端发送请求给后端（同时包含秒杀地址参数），后端先从redis中取出验证码结果验证是否正确。正确则开始在redis中生成path，并进行下一步操作。\n\n\n## 总结\n秒杀系统设计 负责项目的设计和开发 2022.4 - 2022.5\n\n• 项目介绍：为了解决秒杀商品时存在高并发的问题，本项目基于SpringBoot开发秒杀系统。本人主要负责登录模块、商品列表模块、商品详情模板、订单详情模块、秒杀接口优化部分、安全模块。\n\n• 个人收获：对于基于SpringBoot项目的开发有了更加完整和深刻的认识。\n\n• 相关技术：SpringBoot、MySql、mybatis、Redis、RabbitMQ、Thymeleaf、jmeter","tags":["java"],"categories":["项目相关"]},{"title":"SpringMVC自定义参数解析器","url":"/2022/04/15/SpringMVC自定义参数解析器/","content":"\n# 1、实现参数解析器的接口`HandlerMethodArgumentResolver`\n`HandlerMethodArgumentResolver`接口包含两个方法`supportsParameter`和`resolveArgument`。\n- supportsParameter方法返回 boolean 值，表示是否启用该解析器，true 表示启用，false 表示不启用；\n- resolveArgument 方法表示方法参数的解析过程，就是你把 HTTP 的请求参数转换为方法参数的过程，返回 Object 对象，即参数的转换结果。\n\n源代码如下：\n```java\npublic interface HandlerMethodArgumentResolver {\n    boolean supportsParameter(MethodParameter var1);\n\n    Object resolveArgument(MethodParameter var1, ModelAndViewContainer var2, NativeWebRequest var3, WebDataBinderFactory var4) throws Exception;\n}\n```\n\n# 2、自定义一个参数解析器\n- 定义一个方法注解\n- 实现`HandlerMethodArgumentResolver`接口。\n- 注册参数解析器\n- 使用参数解析器\n\n## 2.1 定义一个方法注解\n```java\n@Retention(RUNTIME)\n@Target(METHOD)\npublic @interface ParamModel {\n    // 可以定义需要带的参数\n}\n```\n\n## 2.2 实现`HandlerMethodArgumentResolver`接口。\n在`HandlerMethodArgumentResolver`接口中实现具体的参数解析。\n```java\n@Service\npublic class UserArgumentResolvers implements HandlerMethodArgumentResolver {\n\n    @Override\n    public boolean supportsParameter(MethodParameter parameter) {\n        //带有注解就解析，即调用下面的 resolveArgument 方法。\n        return methodParameter.hasParameterAnnotation(ParamModel.class);\n    }\n\n    @Override\n    public Object resolveArgument(MethodParameter methodParameter, ModelAndViewContainer modelAndViewContainer,\n                                  NativeWebRequest webRequest, WebDataBinderFactory webDataBinderFactory) throws Exception {\n       HttpServletRequest request = webRequest.getNativeRequest(HttpServletRequest.class);\n       HttpServletResponse response = webRequest.getNativeResponse(HttpServletResponse.class);\n\n        // 从request和request中解析出对应的Object。\n\n        return null;\n    }\n\n```\n\n## 2.3 注册参数解析器\n```java\n@Configuration\npublic class WebConfig extends WebMvcConfigurerAdapter {\n\n    @Autowired\n    UserArgumentResolvers userArgumentResolver;\n\n    @Override\n    public void addArgumentResolvers(List<HandlerMethodArgumentResolver> argumentResolvers) {\n        argumentResolvers.add(userArgumentResolver);\n    }\n}\n```\n\n## 2.4 使用参数解析器\n\n```java\n\npublic void getMiaoshaPath(@ParamModel int verifyCode) { // 参数解析的结果会赋值给verifyCode。\n    // ...\n}\n```","tags":["java","SpringMVC","参数解析器"],"categories":["SpringMVC 系列"]},{"title":"SpringMVC实现拦截器_2","url":"/2022/04/15/SpringMVC实现拦截器-2/","content":"\n## 使用拦截器实现日志功能\n实现一个执行 controller 时能够输出相应的执行时间。\n\n输出例子如下：\\\n“URI;methed;status;_;xxms;xxms;xxms”\n```bash\n/coffee/4;com.example.springmvc.controller.CoffeeController.getById;200;_,227ms;227ms;0ms\n```\n\n## 实现拦截器\n  - 重写`HandlerInterceptor`类的`preHandle`、`postHandle`和`afterCompletion`方法。\n  - 注册拦截器\n\n### 重写`HandlerInterceptor`类中的方法\n```java\n@Controller\n@Slf4j\npublic class PerformanceInterceptor implements HandlerInterceptor {\n\n    private ThreadLocal<StopWatch> stopWatch = new ThreadLocal<>();\n\n    @Override\n    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {\n        StopWatch sw = new StopWatch();\n        stopWatch.set(sw);\n        sw.start();\n        return true;\n    }\n\n    @Override\n    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable ModelAndView modelAndView) throws Exception {\n        stopWatch.get().stop();\n        stopWatch.get().start();\n    }\n\n    /*\n    * 请求处理完成后的回调，即渲染视图后。\n    * */\n    @Override\n    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable Exception ex) throws Exception {\n        StopWatch sw = stopWatch.get();\n        sw.stop();\n        String method = handler.getClass().getSimpleName();\n        if (handler instanceof HandlerMethod){\n            String beanType = ((HandlerMethod) handler).getBeanType().getName();\n            String methodName = ((HandlerMethod) handler).getMethod().getName();\n            method = beanType + \".\" + methodName;\n        }\n\n        log.info(\"{};{};{};{},{}ms;{}ms;{}ms\", request.getRequestURI(), method, response.getStatus(),\n                ex == null ? \"_\" : ex.getClass().getSimpleName(),\n                sw.getTotalTimeMillis(), sw.getTotalTimeMillis() - sw.getLastTaskTimeMillis(),\n                sw.getLastTaskTimeMillis());\n        stopWatch.remove();\n    }\n}\n```\n\n### 注册拦截器\n```java\n@Configuration\npublic class WebConfig implements WebMvcConfigurer {\n\n    @Autowired\n    PerformanceInterceptor performanceInterceptor;\n\n    /*\n    * 注册拦截器\n    * */\n    @Override\n    public void addInterceptors(InterceptorRegistry registry) {\n        /*\n        * 使用 performanceInterceptor 中配置的拦截器，拦截路径为 \"/coffee/**\" 和 \"/order/**\" 的请求。\n        * */\n        registry.addInterceptor(performanceInterceptor).addPathPatterns(\"/coffee/**\").addPathPatterns(\"/order/**\");\n    }\n}\n```\n\n### 指定使用 Json 输出，使用上海时间\n```java\n/*\n* 设置 json 输出缩紧，使用上海时间，使用 curl 请求测试。\n* 测试方法：curl http://localhost:8080/coffee/4\n* 测试结果如下：\njq@JQmac blog % curl http://localhost:8080/coffee/4\n{\n  \"id\" : 4,\n  \"createTime\" : \"2022-06-08T17:41:26.955+08:00\",\n  \"updateTime\" : \"2022-06-08T17:41:26.955+08:00\",\n  \"name\" : \"mocha\",\n  \"price\" : 30.00\n}% \n* */\n@Bean\npublic Jackson2ObjectMapperBuilderCustomizer jacksonBuilderCustomizer(){\n    return builder -> {\n        builder.indentOutput(true);\n        builder.timeZone(TimeZone.getTimeZone(\"Asia/Shanghai\"));\n    };\n}\n```\n\n### 测试\n在terminal中的输出为：\n```bash\n/coffee/4;com.example.springmvc.controller.CoffeeController.getById;200;_,227ms;227ms;0ms\n```\n\n### 一个关于 StopWatch 的实例\n\n`StopWatch`类实现一个简单的秒表，允许对多个任务进行计时，显示每个命名任务的总运行时间和运行时间。隐藏 System.nanoTime() 的使用，提高应用程序代码的可读性并降低计算错误的可能性。\\\n**请注意** 此对象并非设计为线程安全的，也不使用同步。此类通常用于在概念验证工作和开发过程中验证性能，而不是作为生产应用程序的一部分。\n\n#### 代码\n```java\nimport org.springframework.util.StopWatch;\n\npublic class TestStopWatch {\n    private void test() throws InterruptedException {\n        StopWatch sw = new StopWatch();\n\n        sw.start(\"起床\");\n        Thread.sleep(1000);\n        sw.stop();\n\n        sw.start(\"洗漱\");\n        Thread.sleep(2000);\n        sw.stop();\n\n        sw.start(\"锁门\");\n        Thread.sleep(500);\n        sw.stop();\n\n        System.out.println(sw.prettyPrint());\n        System.out.println(\"-------------------\");\n        System.out.println(sw.getTotalTimeMillis());\n        System.out.println(sw.getLastTaskName());\n        System.out.println(sw.getLastTaskInfo());\n        System.out.println(sw.getTaskCount());\n    }\n\n\n    public static void main(String []argv) throws InterruptedException {\n        TestStopWatch testStopWatch = new TestStopWatch();\n        testStopWatch.test();\n    }\n}\n```\n\n#### 输出为：\n```bash\nStopWatch '': running time (millis) = 3512\n-----------------------------------------\nms     %     Task name\n-----------------------------------------\n01005  029%  起床\n02005  057%  洗漱\n00502  014%  锁门\n\n-------------------\n3512\n锁门\norg.springframework.util.StopWatch$TaskInfo@24d46ca6\n3\n```\n","tags":["java","SpringMVC","拦截器","StopWatch","ThreadLocal"],"categories":["SpringMVC 系列"]},{"title":"SpringMVC实现拦截器_1","url":"/2022/04/15/SpringMVC实现拦截器-1/","content":"\n# 1、功能需求\n在秒杀商品时，需要使用秒杀接口防刷保护程序，可以定义一个拦截器实现。具体使用如下所示：\n```java\n @AccessLimit(seconds = 1, maxCount = 100, needLogin = true)\n```\n这个拦截器需要当前用户登录，且1s内限制最大请求次数为100。\n\n# 2、拦截器的主要类`HandlerInterceptorAdapter`\n`HandlerInterceptorAdapter`提供的方法如下：\n- `preHandle`:方法执行前调用拦截器，返回true，则接续执行，否则不会执行方法。\n- `postHandle`:在方法执行后调用。\n- `afterCompletion`:请求处理完成后的回调，即渲染视图后。\n源代码如下：\n```java\n    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {\n        return true;\n    }\n\n    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {\n    }\n\n    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {\n    }\n```\n\n# 3、实现拦截器\n  - 自定义 @AccessLimit 参数解析器。\n  - 重写`HandlerInterceptorAdapter`类的`preHandle`方法\n  - 注册拦截器\n  - 使用拦截器\n\n## 3.1 自定义 @AccessLimit 注解。\n```java\n/*\n* 定义一个注解\n*/\n@Retention(RUNTIME)\n@Target(METHOD)\npublic @interface AccessLimit {\n    int seconds();\n    int maxCount();\n    boolean needLogin() default true;\n}\n```\n\n## 3.2 重写`preHandle`方法\n```java\n\n/*\n*  满足拦截条件 return false;\n*  不满足拦截条件 return true;\n*/\n@Service\npublic class AccessInterceptor extends HandlerInterceptorAdapter {\n\n    @Override\n    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {\n\n        if (handler instanceof HandlerMethod){\n            MiaoshaUser user = getUser(request, response);\n\n            // 存储user\n            UserContext.setUser(user); // 当前线程就可以取用。\n\n            HandlerMethod hm = (HandlerMethod) handler;\n            AccessLimit accessLimit = hm.getMethodAnnotation(AccessLimit.class);    // 获取注解\n            if (accessLimit == null) {    // 如果没有限制\n                return true;\n            }\n            int seconds = accessLimit.seconds();\n            int maxCount = accessLimit.maxCount();\n            boolean needLogin = accessLimit.needLogin();\n            // 具体的拦截逻辑\n        }\n        return true;\n    }\n}\n```\n## 3.3 注册拦截器\n```java\n@Configuration\npublic class WebConfig extends WebMvcConfigurerAdapter {\n    @Autowired\n    AccessInterceptor accessInterceptor;\n\n    @Override\n    public void addArgumentResolvers(List<HandlerMethodArgumentResolver> argumentResolvers) {\n        argumentResolvers.add(userArgumentResolver);\n    }\n\n    // 注册拦截器\n    @Override\n    public void addInterceptors(InterceptorRegistry registry) {\n        registry.addInterceptor(accessInterceptor);\n    }\n}\n```\n## 3.4 使用拦截器\n```java\n@AccessLimit(seconds = 1, maxCount = 100, needLogin = true)\npublic void test(){\n    // ...\n}\n```\n\n","tags":["java","SpringMVC","拦截器"],"categories":["SpringMVC 系列"]},{"title":"java杂项","url":"/2022/04/15/java杂项/","content":"## ThreadLcoal 的用法\n\n在秒杀功能中，定义一个`static`的`ThreadLcoal`存储`MiaoshaUser`。当用户点击秒杀按钮时将其存储在`ThreadLocal`中，该线程以后使用时就可以直接get。\n\n```java\nprivate static ThreadLocal<MiaoshaUser> userHolder = new ThreadLocal<>();\n```\n\n如果不这样做，需要每次从请求中解析`MiaoshaUser`对象,代码如下：\n```java\n@Service\npublic class UserArgumentResolvers implements HandlerMethodArgumentResolver {\n\n    @Autowired\n    MiaoshaUserService userService;\n\n    @Override\n    public boolean supportsParameter(MethodParameter parameter) {\n        // 当为 MiaoshaUser 类型时就执行参数解析，即调用下面的 resolveArgument 方法。\n        Class<?> clazz = parameter.getParameterType();\n        return clazz == MiaoshaUser.class;\n    }\n\n    @Override\n    public Object resolveArgument(MethodParameter methodParameter, ModelAndViewContainer modelAndViewContainer,\n                                  NativeWebRequest webRequest, WebDataBinderFactory webDataBinderFactory) throws Exception {\n       HttpServletRequest request = webRequest.getNativeRequest(HttpServletRequest.class);\n       HttpServletResponse response = webRequest.getNativeResponse(HttpServletResponse.class);\n\n       String paramToken = request.getParameter(MiaoshaUserService.COOKI_NAME_TOKEN);\n       String cookieToken = getCookieValue(request, MiaoshaUserService.COOKI_NAME_TOKEN);\n\n       if (StringUtils.isEmpty(cookieToken) && StringUtils.isEmpty(paramToken)){\n           return null;\n       }\n       String token = StringUtils.isEmpty(paramToken) ? cookieToken : paramToken;\n       return userService.getByToken(response,token);\n    }\n\n   private String getCookieValue(HttpServletRequest request, String cookieName) {\n       Cookie[] cookies = request.getCookies();\n       if (cookies == null || cookies.length <= 0){\n           return null;\n       }\n       for (Cookie cookie : cookies) {\n           if (cookie.getName().equals(cookieName)){\n               return cookie.getValue();\n           }\n       }\n       return null;\n   }\n}\n```\n\n## ThreadLcoal 实例2\n[SpringMVC实现拦截器-2](https://jiaoqiang2014.github.io/2022/06/08/SpringMVC%E5%AE%9E%E7%8E%B0%E6%8B%A6%E6%88%AA%E5%99%A8-2/)","tags":["java"],"categories":["杂项"]},{"title":"杂项","url":"/2022/04/08/杂项/","content":"\n## 配置环境变量\n\n### export\nexport 表示将该路径添加到环境变量中，打开 vim .zshrc ，添加jmeter的快速启动路径\n> export JMETER_HOME=/usr/local/apache-jmeter-5.4.3\n> export PATH=$JAVA_HOME/bin:$PATH:.:$JMETER_HOME/bin:$PATH\n> export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JMETER_HOME/lib/ext/ApacheJMeter_core.jar:$JMETER_HOME/lib/jorphan.jar:$JMETER_HOME/lib/logkit-2.0.jar\n\nsource .zshrc 使.zshrc生效。\n使用 export -p 可以查看当前的环境中的路径。\n\n### alias\nalias 为指定路径起别名。\n> export PATH=/usr/local/mysql/bin:$PATH\n> #快速启动、结束MySQL服务, 可以使用alias命令\n> alias mysqlstart='sudo /usr/local/mysql/support-files/mysql.server start'\n> alias mysqlstop='sudo /usr/local/mysql/support-files/mysql.server stop'\n\n### mac 默认使用 zsh 还是 bash\n\n打开terminal 标题上可以看到使用的的是bash还是zsh。只用zsh情况下 `~/.zshrc` 的路径才会生效。可以使用官方推荐的命令 `chsh -s /bin/zsh`默认使用 zsh 。为了避免原先 bash 的命令失效，可以在`.zshrc`中添加`source ~/.bash_profile`生效`~/.bash_profile`中的命令。\n\nIDEA 或者 vscode 默认是 bash 想使用 zsh 需要在编辑器中设置。\n---\n\n## macOS目录的作用\n\n### 系统硬件相关\n/cores 内核转储文件存放目录。当一个进程崩溃时，如果系统允许则会产生转储文件。\n/dev 设备文件存放目录，如何代表硬盘的/dev/disk0。\n/Network 网络节点存放目录；\n/Volumes 文件系统挂载点存放目录。\n\n### 系统配置相关\n/etc. 标准unix系统配置文件存放目录，如用户密码文件/etc/passwd。此目录实际为指向/private/etc的链接。\n\n### 系统程序相关\n/Applications 应用程序目录，默认所有的GUI应用程序都安装在这里；\n/Library 系统的数据文件、帮助文件、文档等等；\n/System 只包含一个名为Library的目录，这个子目录中存放了系统的绝大部分组件，如各种framework，以及内核模块，字体文件等等。\n\n### 系统命令相关\n/bin 传统unix命令的存放目录，如ls，rm，mv等。\n/sbin 传统unix管理类命令存放目录，如fdisk，ifconfig等等。\n\n### 用户信息相关\n/Users 存放用户的个人资料和配置。每个用户有自己的单独目录。\n\n### 用户经常使用\n/usr 第三方程序安装目录。\n/usr/bin, /usr/sbin, /usr/lib，其中/usr/lib目录中存放了共享库（动态链接库）。\n/var 存放经常变化的文件，如日志文件。此目录实际为指向/private/var的链接。\n\n/opt/homebrew brew安装的程序一般放这儿。\n\n/private 里面的子目录存放了/tmp, /var, /etc等链接目录的目标目录。\n/tmp 临时文件存放目录，其权限为所有人任意读写。此目录实际为指向/private/tmp的链接。\n\n### 其他\n/installer.failurerequests 可能是用来记录发生crash时的日志。\n\n---\n\n## linux 命令拾遗\n\n### lsof（list open files）\nlsof 列出当前系统打开文件的工具。lsof -i :8080 可以查看当前占用8080端口的进程。\n\n### ls（list）\nls默认情况下用来打印出当前目录的列表。\n\n---\n\n## git流程\n将写了一半的项目git到空github上。\n1. github上创建同名仓库\n2. git clone到本地\n3. 将隐藏的.git文件复制到已经写了一半的project中\n4. git add .\n5. git status\n6. git commit -m “提交说明”\n7. git push\n8. git fetch\n9. git pull origin master:mybranch  // git pull <远程主机名> <远程分支名>:<mybranch>\n    \n### commit 之后的回滚\n只需将本地仓库commit的代码回滚\n1. git log      //  查看当前的git 日志\n2. git reset --hard commit_id // 将指针指向 commit_id 的位置，没有push，因此不需要修改远程的push\n\n\n\n### push 之后的回滚\n需要将远程朴实的代码回滚\n1. git log      //  查看当前的git 日志\n2. git reset --hard commit_id // 将指针指向 commit_id 的位置\n3. git push origin HEAD --force // HEAD 表示当前指针指向的头，将代码回滚到 HEAD 的位置\n\n\nps：HEAD^ 上次提交的指针位置，HEAD^^ 上上次提交的指针位置，HEAD~n 前 n 次提交的指针位置\n---\n\n\nssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQDN80pyUsUKUofj5LEwzcP8GjnCIZF3rG6GGC3wPcQ5bxuwzEwCXQIyYjBv3ohJ/nSsMo5fvom3Du4uF4fv4Dw83/vmONflr2FvLtrlrCWo1qR2HhxLTrqo7VAoBxHvKJG4oshMkV0CmdrpE8TrPKYj7L1Rn8Awp56bYEKtD8mg/rFsj4PvVMMLEHp/C79Nru+fCqLJP07WYDviOixrGc8x3EO9/i4wZqBFSfbOb32W/6vHrH6dNZfanufgFN1n9A4LT/U0FNGR5S7oBFBQ9g2746rtMn43ginAEP2FfXtnYH1bj3am45zDx+2P//IEKPK7PL4n2hmeTUYSDjBgGq8gpAIOeH9RJzcqtt+KAc0KsB8eG6dG0a6m4U0IQanZLg64ABp2WCm4NQbgbh7jh+KPHOTaDS5i1IzBw/qFZlO6Y7seGRMMxl+/tK0O76Nb3+khpzqGbFsngGnmN9qmeE5JTi3L1yXzLS2ZEmpCAhNMzf4VVHpXSB+vDj9WTWqHdJ0= jiaoqiang2014@163.com\n","tags":["git","linux","macOS"],"categories":["杂项"]},{"title":"hexo github配置博客","url":"/2022/04/06/hexo github配置博客/","content":"\n## 1、 配置环境流程\n\n### 1.1 安装node.js\n\n官网下载node.js\nnode -v\nnmp -v\n\n\n### 1.2 创建blog目录\n\nmkdir /Users/jq/blog\n\n\n### 1.3 安装hexo\n\nnmp install hexo -g hexo-cli\nhexo -v\n\n\n### 1.4 VPN设置\n\n如果设置了VPN，需要设置环境变量；\nvim ./~zshrc\n```shell\nexport https_proxy=http://127.0.0.1:7890 http_proxy=http://127.0.0.1:7890 all_proxy=socks5://127.0.0.1:7890\n\nsource ./~zshrc\n```\n\n### 1.5 初始化hexo\n\nsudo su\nsudo hexo init\n\n## 2、写一个博客流程\n\n### 2.1 开始hexo\n\nhexo s\n\n### 2.2 创建一个新博客\n\nhexo n “XXXX”\n\n使用vsconde等编写内容。\n\n### 2.3 清理\n\nhexo clean\n\n### 2.4 生成博客\n\nhexo g\n\n### 2.5 浏览刚才写的博客\n\nhexo s\n\n\n## 3、配置github\n\n### 3.1 在博客目录下面`_config.yml`最后添加\n\n```html\ndeploy:\n  type: git\n  repository: git@github.com:jiaoqiang2014/jiaoqiang2014.github.io.git\n  branch: master\n```\n## 4、换主题\n### 4.1 下载主题\n```\ngit clone git@github.com:litten/hexo-theme-yilia.git themes/yilia\ngit@github.com:yscoder/hexo-theme-indigo.git\n```\n### 4.2 修改_config.yml配置\n```\ntheme: yilia\n```\n\nHexo clean\n\nHexo g\n\nHero s\n\n## 5、[代码折叠功能](https://www.toimc.com/hexo-usage-2/#%E6%B7%BB%E5%8A%A0jquery)\n\n## 6、[hexo引用本地图片无法显示问题](https://juejin.cn/post/7006594302604214280)\n使用格式为：`![图片描述](md文件夹名字/example.jpg)`\n\n### 参考博客：\n**[1、 hexo增加分类、标签](https://tohugo.com/2021/01/26/%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE/Hexo%E6%B7%BB%E5%8A%A0%E5%88%86%E7%B1%BB%E5%8F%8A%E6%A0%87%E7%AD%BE%EF%BC%88%E5%9C%A8Next%E4%B8%BB%E9%A2%98%E4%B8%8B%EF%BC%89/)**\n**[2、 hexo主题美化](https://www.fangdongdemao.com/2020/05/23/hexo-Next%E4%B8%BB%E9%A2%98%E7%BE%8E%E5%8C%96/)**\n**[3 https://github.com/Neveryu/Neveryu.github.io/blob/](https://github.com/Neveryu/Neveryu.github.io/blob/)**\n","tags":["hexo"],"categories":["杂项"]}]