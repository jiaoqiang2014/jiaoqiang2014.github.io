[{"title":"java8新特性","url":"/2022/04/28/java8新特性/","content":"\n## java8 新特性\n\n- 接口的默认方法(Default Methods for Interfaces)\n- Lambda表达式\n- 函数式接口\n- Streams(流)\n- Parallel Streams(并行流)\n- Maps\n- Date API(日期相关API)\n- Annotations(注解)\n\n链接总结的很棒[java8 新特性](https://github.com/Snailclimb/JavaGuide/blob/main/docs/java/new-features/java8-tutorial-translate.md)。\n\n### 1、接口的默认方法(Default Methods for Interfaces)\n\n```java\npackage com.learnjava.java8;\n\npublic class java8 {\n    public static void main(String[] args) {\n        Formula formula = new Formula() {\n            @Override\n            public double calculate(double a, double b) {\n                return a + b;\n            }\n        };\n        System.out.println(formula.calculate(10, 12));\n\n        //使用 default 关键字向接口添加的非抽象方法可以直接调用\n        System.out.println(formula.mul(10, 12));\n    }\n}\n\n@FunctionalInterface\ninterface Formula{\n    double calculate(double a, double b);\n    // Java 8使我们能够通过使用 default 关键字向接口添加非抽象方法实现。 此功能也称为虚拟扩展方法。\n   default double mul(int a, int b){\n       return a*b;\n   }\n}\n```\n\n### 2、Lambda 表达式\n```java\npublic void lambda() {\n\t\tList<String> names = Arrays.asList(\"peter\", \"anna\", \"mike\", \"xenia\");\n\n\t\t// 写法一\n\t\tCollections.sort(names, new Comparator<String>() {\n\t\t\t@Override\n\t\t\tpublic int compare(String o1, String o2) {\n\t\t\t\treturn o2.compareTo(o1);\n\t\t\t}\n\t\t});\n\t\tnames.forEach(c -> log.info(c + \"  \"));\n\n\t\t// 写法二\n\t\tCollections.sort(names, (a, b) -> {\n\t\t\treturn b.compareTo(a);\n\t\t});\n\n\t\t// 写法三\n\t\tnames.sort((a, b) -> b.compareTo(a));\n\t}\n```\n\n### 3、函数式接口\n\n```java\n\n```\n\n\n\n```java\n\n```\n\n\n\n```java\n\n```\n\n\n\n```java\n\n```\n\n\n\n```java\n\n```\n\n\n\n```java\n\n```"},{"title":"gulimall配置","url":"/2022/04/20/gulimall配置/","content":"\n## 1、环境配置\n\n- 项目结构搭建\n- 配置Mysql\n- 配置renren-fast和renren-fast-vue\n\n\n\n高版本的springboot默认不加载bootstrap.yml文件，需要在pom里加上依赖。\n\n```java\n  <dependency>\n   <groupId>org.springframework.cloud</groupId>\n   <artifactId>spring-cloud-starter-bootstrap</artifactId>\n  </dependency>\n```\n"},{"title":"开发环境安装杂项","url":"/2022/04/18/开发环境安装杂项/","content":"\n## 1、配置git\n\n- 生成ssh\n- 配置到github\n- 测试\n\n### 生成ssh\n\n```shell\nssh-keygen -t rsa -C \"jiaoqiang2014@163.com\"\n```\n\n### 配置到github\n\n在`~/.ssh`目录下生成`id_rsa.pub`和`id_rsa`公钥和私钥。打开公钥，复制到github\n\n```shell\ncat /Users/jq/.ssh/id_rsa.pub\n```\n\n### 测试连接\n\n```shell\nsudo ssh -T git@github.com\n```\n\n如果显示`Hi jiaoqiang2014! You've successfully authenticated, but GitHub does not provide shell access.`表示，使用https没有使用ssh，切换到项目`.git`同级目录下，设置一下使用ssh就行。\n\n```shell\ngit remote set-url origin git@github.com:lut/EvolutionApp.git\n```\n\n## 2、docker 安装\n\n使用官方 docker doc 说明安装。\n\n### 设置docker开机自启动\n\n```shell\nsudo systemctl enable docker\n```\n\n### docker安装mysql\n\n#### 正常芯片\n\n```shell\nsudo docker pull mysql:8.0.28\n```\n\n#### M1芯片\n\n```shell\nsudo docker pull --platform linux/x86_64 mysql:8.0.28\n```\n\n### 查看安装的服务\n\n```shell\nsudo docker images\n```\n\n### docker 启动 mysql\n\n```shell\nsudo docker run -p 3306:3306 --name mysql \\\n-v /var/mysql/log:/var/log/mysql \\\n-v /var/mysql/data:/var/lib/mysql \\\n-v /var/mysql/conf:/etc/mysql \\\n-e MYSQL_ROOT_PASSWORD=123456aa \\\n-d mysql:8\n```\n\n上面代码不知道为啥启动不了\n\n```shell\ndocker run -p 3306:3306 --name mysql -e MYSQL_ROOT_PASSWORD=123456aa -d mysql:8\n```\n\n### 启动mysql容器\n\n```shell\ndocker start mysql\n```\n\n### 进入 Mysql 容器\n\n```shell\ndocker exec -it mysql bash\n```\n\n### navicat 连接 docker mysql\n\n在腾讯云选择该服务器——>管理->防火墙中需要添加 mysql 3306端口的规则，不然会被屏蔽。\n\n### 安装redis\n\n```shell\ndocker pull redis\nmkdir -p /mydata/redis/conf\ntouch /mydata/redis/conf\n```\n\n启动 redis 镜像\n\n```shell\ndocker run -p 6379:6379 --name redis \\\n-v /mydata/redis/data:/data \\\n-v /mydata/redis/conf/redis.conf:/etc/redis/redis.conf \\\n-d redis redis-server /etc/redis/redis.conf\n```\n\n检查redis安装是否成功\n\n```shell\ndocker exec -it redis redis-cli\nauth 123456\nset key1 111\nget key1\n```\n\n#### 持久化redis\n\nredis重启之后会丢失内存中的数据，可以设置持久化到磁盘中。\n\n```shell\nvim /mydata/redis/conf/redis.conf\n```\n\n添加以下内容。\n\n```shell\nappendonly yes\nbind 0.0.0.0 -::1\nrequirepass 123456\n```\n\n给redis存值，重启，检查是否还存在。开启服务端TCP的6379端口。\n\n### docker 服务器重启自动启动程序\n\n```shell\nsudo docker update mysql --restart=always\n```\n\n## 3、前端项目配置杂项\n\n在项目目录下下载需要的组件。\n\n```shell\nnmp install\n```\n\n报错\n\n```shell\nnpm ERR! command failed\nnpm ERR! command sh -c node install.js\nnpm ERR! Only Mac 64 bits supported.\n```\n\n使用下面命令可以解决。\n\n```shell\nnpm install --ignore-scripts\nnpm uninstall node-saas      //卸载node -saas\nnpm install node-sass --save-dev      //重新安装node -saas\n```\n\n运行前端项目\n\n```shell\nnpm run dev\n```\n\n如果报错可以试试下面代码。\n\n```shell\nnpm cache --force clean && npm install --force node-sass\n```\n\n## 4、renrenfast生成","tags":["杂项"]},{"title":"玩转Spring全家桶学习笔记","url":"/2022/04/17/玩转Spring全家桶学习笔记/","content":"\n## 第二章 JDBC必知必会\n\n### 1、配置单个数据源\n\n建立h2、web、lombak的springboot。\n```java\npackage com.example.learn;\nimport com.example.learn.config.ProfileProperties;\nimport com.example.learn.service.LibraryProperties;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.beans.factory.InitializingBean;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.CommandLineRunner;\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.EnableAutoConfiguration;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration;\nimport org.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration;\nimport org.springframework.boot.autoconfigure.jdbc.JdbcTemplateAutoConfiguration;\nimport org.springframework.boot.context.properties.EnableConfigurationProperties;\nimport org.springframework.jdbc.core.JdbcTemplate;\n\nimport javax.sql.DataSource;\nimport java.sql.Connection;\nimport java.sql.SQLException;\n\n@SpringBootApplication()\npublic class DemoApplication implements CommandLineRunner {\n\n\tprivate static final Logger log = LoggerFactory.getLogger(DemoApplication.class);\n\n\t@Autowired\n\tDataSource dataSource;\n\n\t@Autowired\n\tJdbcTemplate jdbcTemplate;\n\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(DemoApplication.class, args);\n\n\t}\n\n\t@Override\n\tpublic void run(String... args) throws Exception {\n\t\tshowConnection();\n\t\tshowData();\n\t}\n\n\tprivate void showData() {\n\t\tjdbcTemplate.queryForList(\"SELECT * FROM FOO\").forEach(row -> log.info(row.toString()));\n\t}\n\n\tprivate void showConnection() throws SQLException {\n\t\tlog.info(dataSource.toString());\n\t\tConnection conn = dataSource.getConnection();\n\t\tlog.info(conn.toString());\n\t\tconn.close();\n\t}\n}\n```\n在resource目录先创建schema.sql文件，写入：\n```sql\nCREATE TABLE FOO (ID INT IDENTITY, BAR VARCHAR(64));\n```\n\n在resource目录先创建data.sql文件，写入：\n```sql\nINSERT INTO FOO (ID, BAR) VALUES(1, 'aaa')\nINSERT INTO FOO (ID, BAR) VALUES(2, 'bbb')\n```\n\n\n### 2、配置多个数据源\n\n配置文件`application.properties`中写入数据源的信息。\n```java\nfoo.datasource.url=jdbc:h2:mem:foo\nfoo.datasource.username=sa\nfoo.datasource.password=\n\nbar.datasource.url=jdbc:h2:mem:bar\nbar.datasource.username=sa\nbar.datasource.password=\n```\n\n需要指定使用什么连接池：COMMONS-DBCP、TOMCAT-JDBC、HIKARICP。\n```xml\n\t\t<dependency>\n\t\t\t<groupId>com.zaxxer</groupId>\n\t\t\t<artifactId>HikariCP</artifactId>\n\t\t\t<version>3.2.0</version>\n\t\t</dependency>\n```\n\n配置数据源\n```java\npackage multiDatasource;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.CommandLineRunner;\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration;\nimport org.springframework.boot.autoconfigure.jdbc.DataSourceProperties;\nimport org.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration;\nimport org.springframework.boot.autoconfigure.jdbc.JdbcTemplateAutoConfiguration;\nimport org.springframework.boot.context.properties.ConfigurationProperties;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.jdbc.core.JdbcTemplate;\nimport org.springframework.jdbc.datasource.DataSourceTransactionManager;\nimport org.springframework.transaction.PlatformTransactionManager;\n\nimport javax.annotation.Resource;\nimport javax.sql.DataSource;\nimport java.sql.Connection;\nimport java.sql.SQLException;\n\n// 排除自动配置，进行手动配置\n@SpringBootApplication(exclude = {DataSourceAutoConfiguration.class,\n\t\tDataSourceTransactionManagerAutoConfiguration.class,\n\t\tJdbcTemplateAutoConfiguration.class})\npublic class MultiDataSourceApplication {\n\n\tprivate static final Logger log = LoggerFactory.getLogger(MultiDataSourceApplication.class);\n\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(MultiDataSourceApplication.class, args);\n\n\t}\n\n\t@Bean\n\t@ConfigurationProperties(\"foo.datasource\")\n\tpublic DataSourceProperties fooDataSourceProperties(){\n\t\treturn new DataSourceProperties();\n\t}\n\n\t@Bean\n\tpublic DataSource fooDataSource(){\n\t\tDataSourceProperties dataSourceProperties = fooDataSourceProperties();\n\t\tlog.info(\"foo datasource:{}\", dataSourceProperties.getUrl());\n\t\treturn dataSourceProperties.initializeDataSourceBuilder().build();\n\t}\n\n\t@Bean\n\t@Resource\n\tpublic PlatformTransactionManager fooTxManager(DataSource fooDataSource){\n\t\treturn new DataSourceTransactionManager(fooDataSource);\n\t}\n\n\n\t@Bean\n\t@ConfigurationProperties(\"bar.datasource\")\n\tpublic DataSourceProperties barDataSourceProperties(){\n\t\treturn new DataSourceProperties();\n\t}\n\n\t@Bean\n\tpublic DataSource barDataSource(){\n\t\tDataSourceProperties dataSourceProperties = barDataSourceProperties();\n\t\tlog.info(\"bar datasource:{}\", dataSourceProperties.getUrl());\n\t\treturn dataSourceProperties.initializeDataSourceBuilder().build();\n\t}\n\n\t@Bean\n\t@Resource\n\tpublic PlatformTransactionManager barTxManager(DataSource barDataSource){\n\t\treturn new DataSourceTransactionManager(barDataSource);\n\t}\n}\n```\n\n### 3、数据库连接池推荐\n- druid：快\n- HikariCP：监控、SQL防注入\n\n### 4、JdbcTemplate 的使用\n\n首先，添加H2数据库的依赖。\n```xml\n\t\t<dependency>\n\t\t\t<groupId>com.h2database</groupId>\n\t\t\t<artifactId>h2</artifactId>\n\t\t\t<scope>runtime</scope>\n\t\t</dependency>\n```\n\n然后,创建和表对应的Entiy。\n```java\n@Data\n@Builder\npublic class Foo {\n\n    private Long id;\n    private String bar;\n}\n```\n\n接下来，完成数据库的查询，添加等功能。\n```java\npackage simplejdbcdemo;\n\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.jdbc.core.JdbcTemplate;\nimport org.springframework.jdbc.core.RowMapper;\nimport org.springframework.jdbc.core.simple.SimpleJdbcInsert;\nimport org.springframework.stereotype.Repository;\n\nimport javax.swing.*;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\n\n@Slf4j\n@Repository\npublic class FooDao {\n    @Autowired\n    private JdbcTemplate jdbcTemplate;\n    @Autowired\n    private SimpleJdbcInsert simpleJdbcInsert;\n\n    public void insertData(){\n\t\t// 方法一：使用jdbcTemplate\n        Arrays.asList(\"a\", \"b\").forEach(bar -> {\n            jdbcTemplate.update(\"insert into Foo (bar) values (?)\", bar);\n        });\n\n\t\t//方法二：使用simpleJdbcInsert\n\t\tHashMap<String, String> row = new HashMap<>();\n        row.put(\"bar\", \"d\");\n        Number id = simpleJdbcInsert.executeAndReturnKey(row);\n        log.info(\"ID of d: {}\", id.longValue());\n    }\n\n    public void listData(){\n        log.info(\"Count: {}\",jdbcTemplate.queryForObject(\"select count(*) from foo\", Long.class));\n\n        List<String> list = jdbcTemplate.queryForList(\"select bar from foo\", String.class);\n        list.forEach(s -> {log.info(\"Bar: {}\", s);});\n\n        List<Foo> fooList = jdbcTemplate.query(\"select * from foo\", new RowMapper<Foo>() {\n            @Override\n            public Foo mapRow(ResultSet rs, int rowNum) throws SQLException {\n                return Foo.builder().id(rs.getLong(1)).bar(rs.getString(2)).build();\n            }\n        });\n        fooList.forEach(f -> log.info(\"Foo: {}\", f));\n    }\n}\n```\n\n最后，在程序入口调用数据库操作。\n```java\npackage simplejdbcdemo;\n\nimport lombok.extern.slf4j.Slf4j;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.CommandLineRunner;\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.jdbc.core.JdbcTemplate;\nimport org.springframework.jdbc.core.simple.SimpleJdbcInsert;\n\n@Slf4j\n@SpringBootApplication\npublic class SiampleJdbcDemoApplication implements CommandLineRunner {\n\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(SiampleJdbcDemoApplication.class, args);\n\t}\n\n\t@Autowired\n\tFooDao fooDao;\n\n\t@Bean\n\t@Autowired\n\tpublic SimpleJdbcInsert simpleJdbcInsert(JdbcTemplate jdbcTemplate) {\n\t\t// 将 FOO 和 ID 绑定。\n\t\treturn new SimpleJdbcInsert(jdbcTemplate)\n\t\t\t\t.withTableName(\"FOO\").usingGeneratedKeyColumns(\"ID\");\n\t}\n\n\t@Override\n\tpublic void run(String... args) throws Exception {\n\t\tfooDao.insertData();\n\t\tfooDao.listData();\n\t}\n}\n```\n\n### 5、NamedParameterJdbcTemplate\n\n\n### 6、事务\n- 编程式事务\n- 声明式事务（推荐使用）\n#### 编程式事务\n- TransactionTemplate\n- PlatformTransactionTemplate  \n\n引入H2数据库的依赖。\n```java\npackage transaction;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.CommandLineRunner;\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.jdbc.core.JdbcTemplate;\nimport org.springframework.transaction.TransactionStatus;\nimport org.springframework.transaction.support.TransactionCallbackWithoutResult;\nimport org.springframework.transaction.support.TransactionTemplate;\n\nimport javax.sql.DataSource;\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\n\n@SpringBootApplication()\npublic class TransactionDemoApplication implements CommandLineRunner {\n\n\tprivate static final Logger log = LoggerFactory.getLogger(TransactionDemoApplication.class);\n\n\t@Autowired\n\tJdbcTemplate jdbcTemplate;\n\t@Autowired\n\tTransactionTemplate transactionTemplate;\n\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(TransactionDemoApplication.class, args);\n\n\t}\n\n\t@Override\n\tpublic void run(String... args) throws Exception {\n\t\tlog.info(\"count before transaction: {}\", getCount());\n\n\t\ttransactionTemplate.execute(new TransactionCallbackWithoutResult() {\n\t\t\t@Override\n\t\t\tprotected void doInTransactionWithoutResult(TransactionStatus status) {\n\t\t\t\tjdbcTemplate.execute(\"INSERT INTO FOO (ID, BAR) VALUES (1, 'AAA')\");\n\t\t\t\tlog.info(\"count in transaction: {}\", getCount());\n\t\t\t\tstatus.setRollbackOnly();\n\t\t\t}\n\t\t});\n\n\t\tlog.info(\"count after transaction: {}\", getCount());\n\t}\n\n\tprivate long getCount(){\n//\t\tList<Integer> list = jdbcTemplate.queryForList(\"select count(*) as cnt from FOO\", Integer.class);\n//\t\tlog.info(String.valueOf(list.get(0)));\n\t\treturn (long)jdbcTemplate.queryForList(\"select count(*) as cnt from FOO\").get(0).get(\"cnt\");\n\t}\n}\n\n```\n\n#### 声明式事务\n在 XML 配置文件中配置或者基于注解，实际是通过 AOP 实现（基于@Transactional 的全注解方式使用最多）。\n\n测试声明式事务核心方法。\n```java\npackage DeclarativeTransaction;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.jdbc.core.JdbcTemplate;\nimport org.springframework.stereotype.Component;\nimport org.springframework.transaction.annotation.Transactional;\n\n@Component\npublic class FooServiceImpl implements FooService {\n\n    @Autowired\n    JdbcTemplate jdbcTemplate;\n\n\t@Autowired\n    FooService fooService;\n\n    @Override\n    @Transactional\n    public void insertRecord() {\n        jdbcTemplate.execute(\"INSERT INTO FOO (BAR) VALUES ('AAA')\");\n    }\n\n    @Override\n    @Transactional(rollbackFor = RollbackException.class)\n    public void insertThenRollback() throws RollbackException {\n        jdbcTemplate.execute(\"INSERT INTO FOO (BAR) VALUES ('BBB')\");\n        throw new RollbackException();\n    }\n\n    @Override\n    public void invokeInsertThenRollback() throws RollbackException {\n                // 思考这两个方法的不同。\n//        insertThenRollback();\n        fooService.insertThenRollback();\n    }\n}\n```\n\n开始调用时需要开启事务注解。\n```java\npackage DeclarativeTransaction;\n\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.CommandLineRunner;\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.context.annotation.AdviceMode;\nimport org.springframework.jdbc.core.JdbcTemplate;\nimport org.springframework.transaction.annotation.EnableTransactionManagement;\n\n@SpringBootApplication\n@Slf4j\n@EnableTransactionManagement(mode = AdviceMode.PROXY)   // 开启事务注解\npublic class DeclarativeTransactionDemoApplication implements CommandLineRunner {\n\n    @Autowired\n    FooService fooService;\n\n    @Autowired\n    JdbcTemplate jdbcTemplate;\n\n    public static void main(String[] args) {\n        SpringApplication.run(DeclarativeTransactionDemoApplication.class, args);\n\n    }\n\n    @Override\n    public void run(String... args) throws Exception {\n        fooService.insertRecord();\n        log.info(\"AAA: {}\", jdbcTemplate. queryForObject(\"SELECT COUNT(*) FROM FOO WHERE BAR='AAA'\", Long.class));\n\n        try {\n            fooService.insertThenRollback();\n        } catch (RollbackException e) {\n            log.info(\"BBB {}\",jdbcTemplate.queryForObject(\"SELECT COUNT(*) FROM FOO WHERE BAR='BBB'\", Long.class));\n        }\n\n        try {\n            fooService.invokeInsertThenRollback();\n        } catch (RollbackException e) {\n            log.info(\"BBB {}\",jdbcTemplate.queryForObject(\"SELECT COUNT(*) FROM FOO WHERE BAR='BBB'\", Long.class));\n        }\n    }\n}\n```\n\n定义的接口。\n```java\npackage DeclarativeTransaction;\n\npublic interface FooService {\n\n    public void insertRecord();\n    public void insertThenRollback() throws RollbackException;\n    public void invokeInsertThenRollback() throws RollbackException;\n}\n```\n\n定义的异常。\n```java\npackage DeclarativeTransaction;\n\npublic class RollbackException extends Throwable {\n}\n```\n\n#### 事务的传播特性\n**TransactionDefinition.PROPAGATION_REQUIRED**\n使用的最多的一个事务传播行为，我们平时经常使用的@Transactional注解默认使用就是这个事务传播行为。\n如果当前存在事务，则加入该事务，不会创建新事务；如果当前没有事务，则创建一个新的事务。\n\n**TransactionDefinition.PROPAGATION_REQUIRES_NEW**\n始终新起一个事务，两个事务没有关联。\n\n**TransactionDefinition.PROPAGATION_NESTED**\n- 有事务：在原事务内启动一个内嵌事务。两个事务有关联，外部事务回滚，内嵌事务也会回滚。\n\n**TransactionDefinition.PROPAGATION_MANDATORY**\n如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。（mandatory：强制性）\n\n代码实例如下：\n```java\npackage DeclarativeTransaction;\n\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.jdbc.core.JdbcTemplate;\nimport org.springframework.stereotype.Component;\nimport org.springframework.transaction.annotation.Propagation;\nimport org.springframework.transaction.annotation.Transactional;\n\n@Slf4j\n@Component\npublic class FooServiceImpl implements FooService {\n\n    @Autowired\n    JdbcTemplate jdbcTemplate;\n\n    @Autowired\n    FooService fooService;\n\n    @Override\n    @Transactional(rollbackFor = RollbackException.class, propagation = Propagation.REQUIRES_NEW)\n    public void insertThenRollback() throws RollbackException {\n        jdbcTemplate.execute(\"INSERT INTO FOO (BAR) VALUES ('BBB')\");\n        // throw new RollbackException();\n    }\n\n    @Override\n    @Transactional(rollbackFor = RollbackException.class)\n    public void invokeInsertThenRollback() throws RollbackException {\n        jdbcTemplate.execute(\"INSERT INTO FOO (BAR) VALUES ('AAA')\");\n        try {\n            fooService.insertThenRollback();\n        }catch (RollbackException e){\n            log.error(\"RollbackException\", e);\n        }\n        throw new RollbackException();\n    }\n}\n```\n\n![事务的传播特性](../../images/8d1542c72a220d01da05ce791304e2803b1fb05f16400305babfafdf9b0289bb.png)\n\n\n![事务的传播特性2](../../images/fe7f6ebc510e9a192a19749197febf38cb9950cebdeae177e6a9c8daf9d89287.png)  \n\n### 7、慢 SQL 日志\n\n开启慢 SQL 日志，设置超过 100ms 的sql为慢sql。\n```java\nspring.datasource.druid.filter.stat.log-slow-sql=true\nspring.datasource.druid.filter.stat.slow-sql-millis=100\n```\n\n测试代码如下：\n\n```java\n@Override\n@Transactional\npublic void selectForUpdate(){\n\tjdbcTemplate.queryForObject(\"select id from foo where id = 1 for update\", Long.class);\n\ttry{\n\t\tThread.sleep(200);\n\t}catch (InterruptedException e){\n\t}\n}\n```\n\n调用代码如下：\n```java\npackage DeclarativeTransaction;\n\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.CommandLineRunner;\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.context.annotation.AdviceMode;\nimport org.springframework.jdbc.core.JdbcTemplate;\nimport org.springframework.transaction.annotation.EnableTransactionManagement;\n\nimport javax.sql.DataSource;\n\n@SpringBootApplication\n@Slf4j\n@EnableTransactionManagement(mode = AdviceMode.PROXY)   // 开启事务注解\npublic class DeclarativeTransactionDemoApplication implements CommandLineRunner {\n\n    @Autowired\n    FooService fooService;\n\n    @Autowired\n    JdbcTemplate jdbcTemplate;\n\n    @Autowired\n    DataSource dataSource;\n\n    public static void main(String[] args) {\n        SpringApplication.run(DeclarativeTransactionDemoApplication.class, args);\n    }\n\n    @Override\n    public void run(String... args) throws Exception {\n        log.info(dataSource.toString());\n        new Thread(() -> fooService.selectForUpdate()).start();\n        new Thread(() -> fooService.selectForUpdate()).start();\n    }\n}\n```\n\n控制台输出\n```java\nc.alibaba.druid.filter.stat.StatFilter: slow sql 212 millis. select id from foo where id = 1 for update[]\n```\n\n## 第三章 O/R Mapping 实践\n\n ORM（Object/Relational Mapping）\"对象-关系映射\"。简单说，ORM 就是通过实例对象的语法，完成关系型数据库的操作的技术。\\\n 推荐阅读: [JPA、Hibernate、Spring Data JPA之间的关系](https://zhuanlan.zhihu.com/p/115507328)\n\n### 1、Spring Data JPA\nJava 持久层框架访问数据库的方式大致分为两种。一种以 SQL 核心，封装一定程度的 JDBC 操作，比如： MyBatis。另一种是以 Java 实体类为核心，将实体类的和数据库表之间建立映射关系，也就是我们说的ORM框架，如：Hibernate、Spring Data JPA（Java Persistence API Java持久层API）。\n\n#### Spring Data JPA 提供的支持\n- @EnableJpaRepositories\n- Repository 接口：\n  - CrudRepository<T, ID>\n  - PagingAndSortingRepository<T, ID>\n  - JpaRepository<T, ID>\n- Repository 实现类：\n  - SimpleJpaRepository\n  - QueryDslJpaRepository\n\n### 2、使用 Spring Data JPA 操作数据库\n\n#### 创建实体（表）\n使用SpringBoot内嵌的H2数据库。创建一个咖啡表和一个咖啡订单表。\\\n**咖啡表**\n```java\npackage com.jq.coffe.model;\n\nimport lombok.*;\nimport lombok.extern.slf4j.Slf4j;\nimport org.hibernate.annotations.CreationTimestamp;\nimport org.hibernate.annotations.Type;\nimport org.hibernate.annotations.UpdateTimestamp;\nimport org.joda.money.Money;\n\nimport javax.persistence.*;\nimport java.io.Serializable;\nimport java.util.Date;\n\n@Data\n@Entity\t// 实体\n@Table(name = \"T_MENU\")\n@Builder  // @Builder声明表示实体可以使用Builder方式初始化\n@Slf4j\n@NoArgsConstructor\n@AllArgsConstructor\n@ToString(callSuper = true)\npublic class Coffee extends BaseEntity implements Serializable {\n\n    private String name;\n\n    @Column\n    @Type(type = \"org.jadira.usertype.moneyandcurrency.joda.PersistentMoneyMinorAmount\",\n    parameters = {@org.hibernate.annotations.Parameter(name = \"currencyCode\", value = \"CNY\")})\n    private Money price;\n}\n```\n\n**咖啡订单表**\n```java\npackage com.jq.coffe.model;\n\nimport com.jq.coffe.model.BaseEntity;\nimport com.jq.coffe.model.Coffee;\nimport com.jq.coffe.model.OrderState;\nimport lombok.AllArgsConstructor;\nimport lombok.Builder;\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\nimport lombok.ToString;\n\nimport javax.persistence.Column;\nimport javax.persistence.Entity;\nimport javax.persistence.Enumerated;\nimport javax.persistence.JoinTable;\nimport javax.persistence.ManyToMany;\nimport javax.persistence.OrderBy;\nimport javax.persistence.Table;\nimport java.io.Serializable;\nimport java.util.List;\n\n@Entity\n@Table(name = \"T_ORDER\")\n@Data\n@ToString(callSuper = true)\n@NoArgsConstructor\n@AllArgsConstructor\n@Builder\npublic class CoffeeOrder extends BaseEntity implements Serializable {\n    private String customer;\n    @ManyToMany\n    @JoinTable(name = \"T_ORDER_COFFEE\")\t// 创建一个 T_ORDER_COFFEE 表\n    @OrderBy(\"id\")\n    private List<Coffee> items;\n    @Enumerated\n    @Column(nullable = false)\t// 可以为空\n    private OrderState state;\n}\n```\n\n**父类**\n```java\npackage com.jq.coffe.model;\n\nimport lombok.AllArgsConstructor;\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\nimport org.hibernate.annotations.CreationTimestamp;\nimport org.hibernate.annotations.Type;\nimport org.hibernate.annotations.UpdateTimestamp;\nimport org.joda.money.Money;\n\nimport javax.persistence.*;\nimport java.io.Serializable;\nimport java.util.Date;\n\n// 编写一个父类,将这些共同属性放到这个父类中, 并且在父类上加上@MappedSuperclass注解.注意:标注为@MappedSuperclass的类将不是一个完整的实体类，他将不会映射到数据库表，但是他的属性都将映射到其子类的数据库字段中。\n@MappedSuperclass\t\n@Data\n@NoArgsConstructor\n@AllArgsConstructor\npublic class BaseEntity implements Serializable {\n    @Id\t// 表示主键\n    @GeneratedValue\t// 主键生成规则\n    private Long id;\n    @Column(updatable = false)\t// 不可以更新\n    @CreationTimestamp\n    private Date createTime;\n    @UpdateTimestamp\n    private Date updateTime;\n}\n```\n\n#### 实现 操作数据库的接口\n这些接口的命名是固定好的，只要按规定格式命名，Spring Boot JPA 就会帮我们做具体操作数据库的逻辑。\n```java\npackage com.jq.coffe.repository;\nimport org.springframework.data.repository.NoRepositoryBean;\nimport org.springframework.data.repository.PagingAndSortingRepository;\nimport java.util.List;\n\n@NoRepositoryBean   // 表示不会作为一个Bean\npublic interface BaseRepository<T, Long> extends PagingAndSortingRepository<T, Long> {\n    List<T> findTop3ByOrderByUpdateTimeDescIdAsc();\n}\n```\n\n**操作咖啡表的接口**\n```java\npackage com.jq.coffe.repository;\nimport com.jq.coffe.model.Coffee;\n\npublic interface CoffeeRepository extends BaseRepository<Coffee, Long> {\n}\n```\n\n**操作咖啡订单表的接口**\n```java\npackage com.jq.coffe.repository;\nimport com.jq.coffe.model.CoffeeOrder;\nimport org.springframework.data.repository.CrudRepository;\nimport java.util.List;\n\npublic interface CoffeeOrderRepository extends BaseRepository<CoffeeOrder, Long> {\n    List<CoffeeOrder> findByCustomerOrderById(String customer);\n    List<CoffeeOrder> findByItems_Name(String name);\n}\n```\n\n#### 测试代码\n```java\npackage com.jq.coffe;\n\nimport com.jq.coffe.model.Coffee;\nimport com.jq.coffe.model.CoffeeOrder;\nimport com.jq.coffe.model.OrderState;\nimport com.jq.coffe.repository.CoffeeOrderRepository;\nimport com.jq.coffe.repository.CoffeeRepository;\nimport lombok.extern.slf4j.Slf4j;\nimport org.joda.money.CurrencyUnit;\nimport org.joda.money.Money;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.ApplicationArguments;\nimport org.springframework.boot.ApplicationRunner;\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.data.domain.Sort;\nimport org.springframework.data.jpa.repository.config.EnableJpaRepositories;\nimport org.springframework.transaction.annotation.EnableTransactionManagement;\nimport org.springframework.transaction.annotation.Transactional;\n\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.stream.Collectors;\n\n@SpringBootApplication\n@Slf4j\n@EnableJpaRepositories\n@EnableTransactionManagement\npublic class CoffeApplication implements ApplicationRunner {\n\n\t@Autowired\n\tCoffeeRepository coffeeRepository;\n\n\t@Autowired\n\tCoffeeOrderRepository orderRepository;\n\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(CoffeApplication.class, args);\n\t}\n\n\t@Override\n\t@Transactional\n\tpublic void run(ApplicationArguments args) throws Exception {\n\t\tinitOrders();\n\t\tfindOrders();\n\t}\n\n\tprivate void initOrders(){\n\t\tCoffee espresso = Coffee.builder().name(\"espresso\")\n\t\t\t\t.price(Money.of(CurrencyUnit.of(\"CNY\"), 20.0))\n\t\t\t\t.build();\n\t\tcoffeeRepository.save(espresso);\n\t\tlog.info(\"Coffee: {}\", espresso);\n\n\t\tCoffee latte = Coffee.builder().name(\"latte\")\n\t\t\t\t.price(Money.of(CurrencyUnit.of(\"CNY\"), 30.0))\n\t\t\t\t.build();\n\t\tcoffeeRepository.save(latte);\n\t\tlog.info(\"Coffee: {}\", latte);\n\n\t\tCoffeeOrder order = CoffeeOrder.builder()\n\t\t\t\t.customer(\"Li Lei\")\n\t\t\t\t.items(Collections.singletonList(espresso))\t// 创建不可变List的单个元素\n\t\t\t\t.state(OrderState.INIT)\n\t\t\t\t.build();\n\t\torderRepository.save(order);\n\t\tlog.info(\"Order: {}\", order);\n\n\t\torder = CoffeeOrder.builder()\n\t\t\t\t.customer(\"Li Lei\")\n\t\t\t\t.items(Arrays.asList(espresso, latte))\n\t\t\t\t.state(OrderState.INIT)\n\t\t\t\t.build();\n\t\torderRepository.save(order);\n\t\tlog.info(\"Order: {}\", order);\n\t}\n\n\tprivate void findOrders() {\n\t\tcoffeeRepository\n\t\t\t\t.findAll(Sort.by(Sort.Direction.DESC, \"id\"))\n\t\t\t\t.forEach(c -> log.info(\"Loading {}\", c));\n\n\t\tList<CoffeeOrder> list = orderRepository.findTop3ByOrderByUpdateTimeDescIdAsc();\n\t\tlog.info(\"findTop3ByOrderByUpdateTimeDescIdAsc: {}\", getJoinedOrderId(list));\n\n\t\tlist = orderRepository.findByCustomerOrderById(\"Li Lei\");\n\t\tlog.info(\"findByCustomerOrderById: {}\", getJoinedOrderId(list));\n\n\t\t// 不开启事务会因为没Session而报LazyInitializationException\n\t\tlist.forEach(o -> {\n\t\t\tlog.info(\"Order {}\", o.getId());\n\t\t\to.getItems().forEach(i -> log.info(\"  Item {}\", i));\n\t\t});\n\n\t\tlist = orderRepository.findByItems_Name(\"latte\");\n\t\tlog.info(\"findByItems_Name: {}\", getJoinedOrderId(list));\n\t}\n\n\tprivate String getJoinedOrderId(List<CoffeeOrder> list) {\n\t\treturn list.stream().map(o -> o.getId().toString())\n\t\t\t\t.collect(Collectors.joining(\",\"));\n\t}\n}\n```\n\n\n### 3、MyBatis 操作数据库\n- [代码仓库](https://gitee.com/geektime-geekbang/geektime-spring-family/tree/master/Chapter%203/mybatis-demo)\n  \n一款持久化框架，支持定制化SQL、存储过程和高级映射。JPA中SQL是框架自动生成的，MyBatis是自己手写的。\n\n定义`Coffee`，其中 Price 使用`Joda-Money`。\n```java\npackage com.example.mybatis.model;\n\nimport lombok.AllArgsConstructor;\nimport lombok.Builder;\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\nimport org.joda.money.Money;\n\nimport java.util.Date;\n\n@Data\n@AllArgsConstructor\n@NoArgsConstructor\n@Builder\npublic class Coffee {\n\n    private Long id;\n    private String name;\n    private Money price;\n    private Date createTime;\n    private Date updateTime;\n}\n```\n\n创建表：新建 schema.sql 文件\n```sql\ncreate table t_coffee (\n    id bigint not null auto_increment,\n    name varchar(255),\n    price bigint not null,\n    create_time timestamp,\n    update_time timestamp,\n    primary key (id)\n);\n```\n\n Mapper sql语句\n```java\npackage com.example.mybatis.mapper;\n\nimport com.example.mybatis.model.Coffee;\nimport org.apache.ibatis.annotations.*;\n\n@Mapper\npublic interface CoffeeMapper {\n\n    // insert into t_coffee (name, price, create_time, update_time) values (\"latte\",30.0, '2022-05-06', '2022-05-06');\n    @Insert(\"insert into t_coffee (name, price, create_time, update_time) values (#{name}, #{price}, #{createTime}, #{updateTime})\")\n    @Options(useGeneratedKeys = true, keyColumn = \"id\", keyProperty = \"id\") // 指定在数据库中的字段名 id，实例对象中主键的属性名 id。\n    int save(Coffee coffee);    // 返回的是变动记录的条数\n\n    // select * from t_coffee where id = #{id}\n    @Select(\"select * from t_coffee where id = #{id}\")\n    @Results({\n            @Result(id = true, column = \"id\", property = \"id\"),\n            @Result(column = \"create_time\", property = \"createTime\"), // 实例对象名字为 create_time，数据库中名字为 createTime。\n            // map-underscore-to-camel-case = true 可以实现一样的效果\n            // @Result(column = \"update_time\", property = \"updateTime\")\n    })\n    // @Param(\"id\")对应where id = #{id}里的#{id}，给个例子，万一大家以后变量名和参数名不一样，也好知道怎么写。\n    Coffee findById(@Param(\"id\") Long id);\n}\n```\n\n引入类型转换的配置\n```java\n# 表示是类型转化时包的前缀\nmybatis.type-handlers-package=com.example.mybatis.handler\n# 将下划线转化为驼峰规则\nmybatis.configuration.map-underscore-to-camel-case=true\n```\n\n定义自己的handle，用于处理Money的类型转换（类中使用 Money 类型的price，数据库中使用 bigint 类型的price）\n```java\npackage com.example.mybatis.handler;\n\nimport org.apache.ibatis.type.BaseTypeHandler;\nimport org.apache.ibatis.type.JdbcType;\nimport org.joda.money.CurrencyUnit;\nimport org.joda.money.Money;\n\nimport java.sql.CallableStatement;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\n\n/**\n * 类中使用 Money 类型的price，数据库中使用 bigint 类型的price。\n * mybatis在没有配置handler时，会根据参数或者返回结果的不同，默认为我们选择合适的TypeHandler处理。\n * 当我们需要特殊的字段处理时，可以配置自己的handler。\n * 首先，在配置文件中引入 配置的包。\n * 然后，实现 BaseTypeHandler 接口完成自己的类。\n * 在 Money 与 Long 之间转换的 TypeHandler，处理 CNY 人民币\n */\npublic class MoneyTypeHandler extends BaseTypeHandler<Money> {\n    @Override\n    public void setNonNullParameter(PreparedStatement ps, int i, Money parameter, JdbcType jdbcType) throws SQLException {\n        ps.setLong(i, parameter.getAmountMinorLong());\n    }\n\n    @Override\n    public Money getNullableResult(ResultSet rs, String columnName) throws SQLException {\n        return parseMoney(rs.getLong(columnName));\n    }\n\n    @Override\n    public Money getNullableResult(ResultSet rs, int columnIndex) throws SQLException {\n        return parseMoney(rs.getLong(columnIndex));\n    }\n\n    @Override\n    public Money getNullableResult(CallableStatement cs, int columnIndex) throws SQLException {\n        return parseMoney(cs.getLong(columnIndex));\n    }\n\n    private Money parseMoney(Long value) {\n        return Money.of(CurrencyUnit.of(\"CNY\"), value / 100.0);\n    }\n}\n```\n\n调用代码\n```java\npackage com.example.mybatis;\n\nimport com.example.mybatis.mapper.CoffeeMapper;\nimport com.example.mybatis.model.Coffee;\nimport lombok.extern.slf4j.Slf4j;\nimport org.apache.ibatis.annotations.Mapper;\nimport org.joda.money.CurrencyUnit;\nimport org.joda.money.Money;\nimport org.mybatis.spring.annotation.MapperScan;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.ApplicationArguments;\nimport org.springframework.boot.ApplicationRunner;\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\n@SpringBootApplication\n@Slf4j\n@MapperScan(\"com.example.mybatis.mapper\")\t// 扫描对应包里边的mapper映射\npublic class MybatisApplication implements ApplicationRunner {\n\n\t@Autowired\n\tCoffeeMapper coffeeMapper;\n\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(MybatisApplication.class, args);\n\t}\n\n\t@Override\n\tpublic void run(ApplicationArguments args) throws Exception {\n\n\t\t// 将 name 的值设置为 espresso，将price的值设置为 20.0。和sql中的${name}和${price}对应。\n\t\t// @Insert(\"insert into t_coffee (name, price, create_time, update_time) values (#{name}, #{price}, now(), now())\")\n\t\tCoffee coffee = Coffee.builder().name(\"espresso\")\n\t\t\t\t.price(Money.of(CurrencyUnit.of(\"CNY\"), 20.0))\n\t\t\t\t.createTime(new Date())\n\t\t\t\t.updateTime(new Date())\n\t\t\t\t.build();\n\t\tint count = coffeeMapper.save(coffee);\n\t\tlog.info(\"Save {} Coffee: {}\", count, coffee);\n\n\t\tcoffee = Coffee.builder().name(\"latte\")\n\t\t\t\t.price(Money.of(CurrencyUnit.of(\"CNY\"), 25.0))\n\t\t\t\t.createTime(new Date())\n\t\t\t\t.updateTime(new Date()).build();\n\t\tcount = coffeeMapper.save(coffee);\n\t\tlog.info(\"Save {} Coffee: {}\", count, coffee);\n\n\t\tcoffeeMapper.findById(coffee.getId());\n\t\tlog.info(\"Find Coffee: {}\", coffee);\n\t}\n}\n```\n\n### 4、MaBatis Generator\n\n[代码仓库](https://gitee.com/geektime-geekbang/geektime-spring-family/tree/master/Chapter%203/mybatis-generator-demo)\n\n### 5、MaBatis PageHelper\n\n[代码仓库](https://gitee.com/geektime-geekbang/geektime-spring-family/tree/master/Chapter%203/mybatis-pagehelper-demo)\n\n## 第四章 NoSQL 实践\n\n### 1、docker 的一些环境安装\n```shell\ndocker run --name mongo -p 27017:27017 -v ~/docker-data/mongo:/data/db -e MONGO_INITDB_ROOT_USERNAME=admin -e MONGO_INITDB_ROOT_PASSWORD=admin -d mongo\n```\n\n### 2、MongoDB\nMongoDB 是一款开源的文档型数据库。Spring 对 MongoDB 的支持：\n- Spring Data MongoDB\n   - MongoTemplate\n   - Repository 支持\n- 注解\n   - @Document 和 @Entity 类似，表示类是一个文档（@Entity中是表）\n   - @Id 每个文档都会对应一个 Id ，通过@Id表明类中哪一个属性是id。加上 @Id 之后，Spring Data Mongo 会将属性的类型转化为 MongoDB 中的 object ID。\n- MongoTemplate\n  - save / remove\n  - Criteria / Query / Update\n- Spring Data MongoDB 的 Repository\n  - @EnableMongoRepositories\n  - 对应接口\n    - MongoRepository<T, ID>\n    - PagingAndSortingRepository<T, ID>\n    - CrudRepository<T, ID>\n\n### 3、Spring 中访问 MongoDB\n[代码仓库](https://gitee.com/geektime-geekbang/geektime-spring-family/tree/master/Chapter%204/mongo-demo)\n#### 3.1 安装 MongoDB\n使用 docker 安装。\n```shell\ndocker pull Mongo\ndocker exec -it mongo bash\nmongo -u admin -p admin\n\n// 显示当前存在的库\nshow dbs\n\n// 使用springbucks库，没有会默认创建一个\nuse springbucks\n\n// 创建 createUser，用户名和密码都为springbucks。\ndb.createUser(\n\t{\n\t\tuser: \"springbucks\",\n\t\tpwd: \"springbucks\",\n\t\troles: [\n\t\t\t{role: \"readWrite\", db: \"springbucks\"}\n\t\t]\n\t}\n)\n\nshow users\n\nshow collections;\n\ndb.coffee.find();\n\n// 删除 coffee 中所有名为 espresso 的 Document 。\ndb.coffee.remove({\"name\":\"espresso\"});\n```\n#### 3.2 基于 MongoTemplate 的方法\n##### 创建 Coffee 类\n```java\npackage com.example.mongo.model;\n\nimport lombok.AllArgsConstructor;\nimport lombok.Builder;\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\nimport org.joda.money.Money;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.data.annotation.Id;\nimport org.springframework.data.mongodb.core.mapping.Document;\nimport java.util.Date;\n\n// 表示类是一个文档\n@Document\n@Data\n@AllArgsConstructor\n@NoArgsConstructor\n@Builder\npublic class Coffee {\n    @Id\n    private String id;  // 加上 @Id 之后，Spring Data Mongo 会将String类型转化为 MongoDB 中的 object ID。\n    private String name;\n    private Money price;\n    private Date createTime;\n    private Date updateTime;\n}\n```\n\n##### 配置 MongoDB\n```java\n# 用户名密码对应 springbucks:springbucks ，使用 springbucks 库。\nspring.data.mongodb.uri=mongodb://springbucks:springbucks@124.220.171.2:27017/springbucks\nspring.main.allow-circular-references=true\n```\n\n##### 编写特殊类型 Money 的转化代码（ Mongo -> Money 类型）\n从 Money 类型转化为 Mongo 中的 Document 是自动转化的，不需要我们自己手写。其实就是转化为 Dson 类型（和json相似）。\n**mongo 中存储的 Coffee 对象格式如下，这是一条 Document**\n```json        \n\t{ \"_id\" : ObjectId(\"626b59f24eb80121ff790475\"),\n\t\"name\" : \"espresso\",\n\t\"price\" :\n\t\t{ \"money\" :\n\t\t\t{ \"currency\" :\n\t\t\t\t{ \"code\" : \"CNY\",\n\t\t\t\t\t\"numericCode\" : 156,\n\t\t\t\t\t\"decimalPlaces\" : 2\n\t\t\t\t\t},\n\t\t\t\t\"amount\" : \"20.00\"\n\t\t\t\t}\n\t\t\t},\n\t\"createTime\" : ISODate(\"2022-04-29T03:22:26.240Z\"),\n\t\"updateTime\" : ISODate(\"2022-04-29T03:22:26.240Z\"),\n\t\"_class\" : \"com.example.mongo.model.Coffee\" }\n```\n\n**Mongo -> Money 类型**\n```java\npackage com.example.mongo.converter;\n\nimport org.bson.Document;\nimport org.joda.money.CurrencyUnit;\nimport org.joda.money.Money;\nimport org.springframework.core.convert.converter.Converter;\n\n/*\n* Document 转化为 Money。\n* */\npublic class MoneyReadConverter implements Converter<Document, Money> {\n    @Override\n    public Money convert(Document source) {\n        // Mongo 取出 Document 的数据，从中取出 money。\n        Document money = (Document) source.get(\"money\");\n        // 从 money 中解析出金额。\n        double amount = Double.parseDouble(money.getString(\"amount\"));\n        String currency = ((Document) money.get(\"currency\")).getString(\"code\");\n        return Money.of(CurrencyUnit.of(currency), amount);\n    }\n}\n```\n\n##### 调用代码\n```java\npackage com.example.mongo;\n\nimport com.example.mongo.converter.MoneyReadConverter;\nimport com.example.mongo.model.Coffee;\nimport com.mongodb.client.result.UpdateResult;\nimport com.mongodb.internal.bulk.UpdateRequest;\nimport lombok.extern.slf4j.Slf4j;\nimport org.joda.money.CurrencyUnit;\nimport org.joda.money.Money;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.ApplicationArguments;\nimport org.springframework.boot.ApplicationRunner;\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.data.mongodb.ClientSessionException;\nimport org.springframework.data.mongodb.core.MongoTemplate;\nimport org.springframework.data.mongodb.core.convert.MongoCustomConversions;\nimport org.springframework.data.mongodb.core.query.Criteria;\nimport org.springframework.data.mongodb.core.query.Query;\nimport org.springframework.data.mongodb.core.query.Update;\n\nimport java.util.Arrays;\nimport java.util.Date;\nimport java.util.List;\n\nimport static org.springframework.data.mongodb.core.query.Criteria.where;\nimport static org.springframework.data.mongodb.core.query.Query.query;\n\n@SpringBootApplication\n@Slf4j\npublic class MongoApplication implements ApplicationRunner {\n\n\t@Autowired\n\tMongoTemplate mongoTemplate;\n\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(MongoApplication.class, args);\n\t}\n\n\t// 查看 spring-boot-autoconfigure -> data -> mongo -> MongoDataAutoConfiguration.class\n\t// 可以看出构造一个 MongoCustomConversions 类型的 bean ，可以替代 MongoDataAutoConfiguration 中的一部分配置。\n\t@Bean\n\tpublic MongoCustomConversions mongoCustomConversions(){\n\t\treturn new MongoCustomConversions(Arrays.asList(new MoneyReadConverter()));\n\t}\n\n\t@Override\n\tpublic void run(ApplicationArguments args) throws Exception {\n\t\t//插入\n\t\tCoffee espresso = Coffee.builder()\n\t\t\t\t.name(\"espresso\")\n\t\t\t\t.price(Money.of(CurrencyUnit.of(\"CNY\"), 20.0))\n\t\t\t\t.createTime(new Date())\n\t\t\t\t.updateTime(new Date()).build();\n\t\tCoffee saved = mongoTemplate.save(espresso);\n\t\tlog.info(\"Coffee {}\", saved);\n\n\t\t// 查询\n\t\tList<Coffee> list = mongoTemplate.find(query(where(\"name\").is(\"espresso\")), Coffee.class);\n\t\tlog.info(\"Find {} Coffee\", list.size());\n\t\tlist.forEach(c -> log.info(\"Coffee {}\", c));\n\n\t\t// 更新\n\t\tThread.sleep(1000); // 为了看更新时间 1s\n\t\tUpdateResult result = mongoTemplate.updateFirst(query(where(\"name\").is(\"espresso\")),\n\t\t\t\t new Update().set(\"price\", Money.ofMajor(CurrencyUnit.of(\"CNY\"), 30))\n\t\t\t\t\t\t .currentDate(\"updateTime\"),\n\t\t\t\t Coffee.class);\n\t\t log.info(\"Update Result: {}\", result.getModifiedCount());\n\n\t\t Coffee updateOne = mongoTemplate.findById(saved.getId(), Coffee.class);\n\t\t log.info(\"Update Result: {}\", updateOne);\n\n\t\t// 删除\n\t\t mongoTemplate.remove(updateOne);\n\t}\n}\n```\n\n#### 3.3 基于 Spring Data MongoDB 的 Repository 的方法\n[代码仓库](https://gitee.com/geektime-geekbang/geektime-spring-family/tree/master/Chapter%204/mongo-repository-demo)\n**在基于 MongoTemplate 的方法基础上实现 MongoRepository 接口**\n```java\npackage com.example.mongo.repository;\n\nimport com.example.mongo.model.Coffee;\nimport org.springframework.data.mongodb.repository.MongoRepository;\n\nimport java.util.List;\n\npublic interface CoffeeRepository extends MongoRepository<Coffee, String> {\n    List<Coffee> findByName(String name);\n}\n```\n\n**添加`@EnableMongoRepositories`注解，修改调用代码如下**\n```java\npackage com.example.mongo;\n\nimport com.example.mongo.converter.MoneyReadConverter;\nimport com.example.mongo.model.Coffee;\nimport com.example.mongo.repository.CoffeeRepository;\nimport com.mongodb.client.result.UpdateResult;\nimport com.mongodb.internal.bulk.UpdateRequest;\nimport lombok.extern.slf4j.Slf4j;\nimport org.joda.money.CurrencyUnit;\nimport org.joda.money.Money;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.ApplicationArguments;\nimport org.springframework.boot.ApplicationRunner;\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.data.domain.Sort;\nimport org.springframework.data.mongodb.ClientSessionException;\nimport org.springframework.data.mongodb.core.MongoTemplate;\nimport org.springframework.data.mongodb.core.convert.MongoCustomConversions;\nimport org.springframework.data.mongodb.core.query.Criteria;\nimport org.springframework.data.mongodb.core.query.Query;\nimport org.springframework.data.mongodb.core.query.Update;\nimport org.springframework.data.mongodb.repository.config.EnableMongoRepositories;\n\nimport java.util.Arrays;\nimport java.util.Date;\nimport java.util.List;\n\nimport static org.springframework.data.mongodb.core.query.Criteria.where;\nimport static org.springframework.data.mongodb.core.query.Query.query;\n\n@SpringBootApplication\n@Slf4j\n@EnableMongoRepositories\npublic class MongoApplication implements ApplicationRunner {\n\n\t@Autowired\n\tCoffeeRepository coffeeRepository;\n\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(MongoApplication.class, args);\n\t}\n\n\t// 查看 spring-boot-autoconfigure -> data -> mongo -> MongoDataAutoConfiguration.class\n\t// 可以看出构造一个 MongoCustomConversions 类型的 bean ，可以替代 MongoDataAutoConfiguration 中的一部分配置。\n\t@Bean\n\tpublic MongoCustomConversions mongoCustomConversions(){\n\t\treturn new MongoCustomConversions(Arrays.asList(new MoneyReadConverter()));\n\t}\n\n\t@Override\n\tpublic void run(ApplicationArguments args) throws Exception {\n\t\t//插入\n\t\tCoffee espresso = Coffee.builder()\n\t\t\t\t.name(\"espresso\")\n\t\t\t\t.price(Money.of(CurrencyUnit.of(\"CNY\"), 20.0))\n\t\t\t\t.createTime(new Date())\n\t\t\t\t.updateTime(new Date()).build();\n\t\tCoffee latte = Coffee.builder()\n\t\t\t\t.name(\"latte\")\n\t\t\t\t.price(Money.of(CurrencyUnit.of(\"CNY\"), 30.0))\n\t\t\t\t.createTime(new Date())\n\t\t\t\t.updateTime(new Date()).build();\n\n\t\tcoffeeRepository.insert(Arrays.asList(espresso, latte));\n\t\tcoffeeRepository.findAll(Sort.by(\"name\")).forEach(c -> log.info(\"Saved Coffee {}\", c));\n\n\t\tThread.sleep(1000);\n\t\tlatte.setPrice(Money.of(CurrencyUnit.of(\"CNY\"), 35.0));\n\t\tlatte.setUpdateTime(new Date());\n\t\tcoffeeRepository.save(latte);\n\t\tcoffeeRepository.findByName(\"latte\").forEach(c -> log.info(\"Coffee {}\", c));\n\t\tcoffeeRepository.deleteAll();\n\t}\n}\n\n```\n\n\n### 3、Redis\nSpring 对 Redis 的支持 -- Spring Data Redis\n- 支持客户端Jedis / Lettuce\n- RedisTemplate\n- Repository 支持\n\nJedis 客户端的简单实用\n- Jedis 不是线程安全的\n- 通过 JedisPool 获得 Jedis 实例。\\\n  **原因：** Jedis 不安全，不能在多个线程中中使用同一个 jeid ，因此使用 JedisPool 管理 jedis，没次使用时从 JedisPool 中取。\n- 直接使用 Jedis 中的方法\n\n#### Redis 的两种部署方式\n- 哨兵模式\n- 集群模式\n\n##### 哨兵模式\nRedis Sentinel 是 Redis 的一种高可用方案。\n- 监控、通知、自动故障转移、服务发现\n  \nJedisSentinePool\n\n\n```java\n\n```\n\n\n```java\n\n```\n\n```java\n\n```\n\n\n```java\n\n```\n\n\n```java\n\n```\n\n```java\n\n```\n\n### 4、","categories":["Spring"]},{"url":"/2022/04/16/秒杀项目总结/","content":"configuration\n---\n该配置文件说明如何在本地搭建起环境，包括启动 mysql、启动虚拟机、启动 redis。\n## 一、Mysql启动\n- 打开navicat 连接 127.0.0.1 即可。 \n- 可以使用 http://www.localhost:8080/demo/db/get 测试\n\n## 二、Redis 启动\nredis 是使用 multipass 安装的虚拟机需要先启动虚拟机，然后在虚拟机中启动redis。\n\n### 1、启动 multipass\n```shell\nmultipass info -all\nmultipass shell XXX(host)\n```\n参考链接：http://www.manongjc.com/detail/21-gtzvxvzjtoaxswf.html\n\n### 2、启动 redis\n```shell\ncd /usr/local/redis\nredis-server redis.conf\nredis-cli\nauth 123456\n```\n可以使用 http://www.localhost:8080/demo/redis/get 测试\n\n## 三、压测\n### 1. 图形化压测\n\n### 2. 命令行压测\n首先，需要将jar包启动（参考`Spring Boot打jar包`）。然后，使用jmeter压测。\n```shell\njmeter.sh -n -t /Users/jq/Desktop/goods_list.jmx -l result.jtl\n```\n如果OOM，可以使用下面命令设置更大的JVM堆栈内存。\n```shell\nJVM_ARGS=\"-Xms512m -Xmx5g\" jmeter.sh -n -t /Users/jq/Desktop/goods_list.jmx -l result.jtl\n```\n\n## 四、Spring Boot打war包。\n### 1. 添加依赖\n```html\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-tomcat</artifactId>\n    <scope>provided</scope>\n</dependency>\n```\n\n### 2. 添加\n```html\n<build>\n    <finalName>${project.artifactId}</finalName>\n    <plugins>\n        <plugin>\n            <groupId>org.apache.maven.plugins</groupId>\n            <artifactId>maven-war-plugin</artifactId>\n            <configuration>\n                <failOnMissingWebXml>false</failOnMissingWebXml>\n            </configuration>\n        </plugin>\n        <plugin>\n            <artifactId>maven-compiler-plugin</artifactId>\n            <version>3.1</version>\n            <configuration>\n                <fork>true</fork\n            </configuration>\n        </plugin>\n    </plugins>\n</build>\n```\n\n### 3. 修改\n```html\n<groupId>org.imooc</groupId>\n<artifactId>miaosha</artifactId>\n<version>1.0-SNAPSHOT</version>\n<packaging>war</packaging>\n```\n同时，把packaging中的jar修改为war。\n\n### 4. 修改MainApplication类\n```java\n@SpringBootApplication\npublic class MainApplication extends SpringBootServletInitializer {\n\n    public static void main(String[] args) {\n        SpringApplication.run(MainApplication.class, args);\n    }\n\n    @Override\n    protected SpringApplicationBuilder configure(SpringApplicationBuilder builder){\n        return builder.sources(MainApplication.class);\n    }\n}\n```\n\n### 5. brew 安装 tomcat@9（和java8匹配) \\\nBrew会默认安装在/opt/homebrew/Cellar/目录下。\n\n### 6. 配置tomcat快速启动\n```shell\nalias tomcatstart=/opt/homebrew/Cellar/tomcat@9/9.0.60/libexec/bin/startup.sh\nalias tomcatstop=/opt/homebrew/Cellar/tomcat@9/9.0.60/libexec/bin/shutdown.sh\n```\n\n### 7. 打成 war 包 \n```shell\nmvn clean package\n```\n\n在miaosha/target目录下生成miasma.war包。将miasma.war拷贝到 /opt/homebrew/Cellar/tomcat@9/9.0.60/libexec/webapps 目录下。\n\n### 8. tomcatstart 启动tomcat。 \\\n输入http://www.localhost:8080测试tomcat是否搭建成功。输入 http://www.localhost:8080/miaosha/login/to_login， 查看登录界面，但目前不能登录，需要在/opt/homebrew/Cellar/tomcat@9/9.0.60/libexec/webapps/Root 目录下添加一些资源。\n\n## 五、Spring Boot打jar包\n### 1、添加依赖\n```html\n<build>\n    <finalName>${project.artifactId}</finalName>\n    <plugins>\n        <plugin>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-maven-plugin</artifactId>\n        </plugin>\n        <plugin>\n            <artifactId>maven-compiler-plugin</artifactId>\n            <version>3.1</version>\n            <configuration>\n                <fork>true</fork>\n            </configuration>\n        </plugin>\n    </plugins>\n</build>\n```\n\n### 2、修改\n```html\n<groupId>org.imooc</groupId>\n<artifactId>miaosha</artifactId>\n<version>1.0-SNAPSHOT</version>\n<packaging>jar</packaging>\n```\n\n\n### 3、打成 jar 包\n```shell\nmvn clean package\n```\n\n在miaosha/target目录下生成miasma.jar包\n\n### 4、运行jar，并输出到nohup文件。\n```shell\nnohup java -jar miaosha.jar &\n```\n\n### 5、测试\n输入 http://www.localhost:8080/miaosha/login/to_login， 查看登录界面，并且进行压测。 \\\n输入 tail -f nohup.out 可以查看日志的末尾输出。\n\n## 五、压测 redis\n```shell\nredis-benchmark -a 123456 -h 127.0.0.1 -p 6379 -c 100 -n 100000\n\nredis-benchmark -a 123456 -h 127.0.0.1 -p 6379 -q -d 100\n\nredis-benchmark -a 123456 -t set,lpush -n 100000 -q\n\n# 只测试单条命令\nredis-benchmark -a 123456 -n 100000 -q script load \"redis.call('set','foo','bar')\"\n```\n\n## 六、页面优化技术\n- 页面缓存 + URL缓存 + 对象缓存 \n- 页面静态化（不需要重复下载页面，只需要下载动态的），前后端分离\n- 静态资源优化\n- CDN优化\n\n### 1、页面缓存\n将 goods_list 页面的信息写入 redis，设置了60s的缓存时间。可以下命令测试：\n```shell\nkeys GoodsKey:gl\nget GoodsKey:gl\n```\n\n### 2、URL 缓存\n和页面缓存大致一样，给 goods_detail 页面添加缓存，不同于 goods_list 页面的是 goods_detail 页面需要加用户的标号：\"1\"（http://www.localhost:8080/goods/to_detail/1）。\n\n### 3、对象缓存\n此处的对象指的是用户对象，通过用户id将用户的信息写入缓存。\n\nMiaoshaUserService 类中的 updatePassword 方法，如何更新数据库密码。\n\n### 4、页面静态化\n将数据存在浏览器中，主要技术有：AngularJS、Vue.js等\n此处使用简单的。\n\n服务端不直接返回html，只返回页面上动态的数据。在前端html页面中接受这些动态的数值即可。\n\n#### 思考：如何验证客户端加载了浏览器的本地缓存而不是服务端的数据？\\\n304状态码表示服务端数据未改变，可直接使用客户端未过期的缓存。304状态码返回时不包含任何响应的主体部分。\n请求首部包含`If-Modified-Since: Mon, 11 Apr 2022 10:07:49 GMT`，服务端会和资源的最近更新时间比较，确定是不是需要返回资源。不需要则返回304状态码，具体如下：\n```html\nHTTP/1.1 304\nLast-Modified: Mon, 11 Apr 2022 10:07:49 GMT\nDate: Mon, 11 Apr 2022 10:10:19 GMT\n```\n#### 进一步优化\n上面虽然没有直接下载服务端的数据，但还是请求了一次服务端。通过在静态资源中添加设置静态资源的有效时间，不访问服务器，直接使用客户端的缓存。\\\n#### 验证\n查看网页请求，发现响应如下：\n```html\nHTTP/1.1 200\nLast-Modified: Mon, 11 Apr 2022 10:07:49 GMT\nContent-Length: 4818\nAccept-Ranges: bytes\nContent-Type: text/html\nCache-Control: max-age=3600\nDate: Mon, 11 Apr 2022 10:43:17 GMT\n```\n`Cache-Control: max-age=3600`字段表示该资源可以在3600ms内复用。\n\n## 问题1：库存会被减成负值\n#### 原因：两个人同时减库存时，调用的sql语句如下：\n```java\n@Update(\"update miaosha_goods set stock_count = stock_count - 1 where goods_id = #{goodsId}”)\n```\n当只有一个库存时会降为-1，此时可以在sql中加库存大于0的判断如下：\n```java\n@Update(\"update miaosha_goods set stock_count = stock_count - 1 where goods_id = #{goodsId} and stock_count > 0”)`）\n```\n\n## 问题2：一个用户购买了两个同一个商品。\n#### 原因：库存为10，同一个用户同时发出两个请求，同时进入了判断库存等方法，导致一个用户买到两个商品。\n解决思路：购买流程是：减库存 -> 下订单，下订单的时候有个订单表，有用户id和商品id，此处在订单表中给这两个字段建立联合唯一索引。这样创建订单时，如此该用户存在一个订单，再下另一个订单时就会出现重复。注意：在创建订单的函数前加`@Transactional`。\n如果只给用户id建立唯一索引可以不？不行，允许用户秒杀其他商品。\n\n### 5、静态资源优化\n1. JS/CSS 压缩，减少流浪；\n2. 多个 JS/CSS 组合\n3. Tengine 在nginx基础上开发的\nCDN:内容分发网络。 \n\n## 七、秒杀接口优化\n### 方案：\n- 把秒杀商品信息加载到redis，减少mysql的访问。\n- 内存标记，减少一次redis查商品库存的访问：使用map（goodsId -> boolean）， false表示还有库存，true表示没有库存，则秒杀结束。接下来的关于goodsId的请求不在访问redis，直接返回。\n- 通过在redis中预减库存，当库存不足，直接返回，不需要进一步查询Redis中的订单信息，以判断是否秒杀成功。减少了redis的访问。\n- 使用rabbitmq实现异步下单，达到削峰的作用。\n### 秒杀流程：\n- 系统初始化，把商品库存数量加载到redis。\n- 收到请求，内存标记，减少redis访问：\n- redis预减库存，如果库存不足，设置该goodsId的map值为true，然后直接返回。\n- 请求入队，立即返回排队中。\n- 请求出队，生成订单，减少库存。\n- 客户端轮询，是否秒杀成功。\n\n#### 环境安装\n安装 RabbitMQ。\n```shell\nsudo apt-get install erlang\nerl\n```\n以上命令能正常输出说明`erlang`安装成功。接下来安装、启动并验证`rabbitmq`是否在监听5672端口。\n```shell\nsudo apt-get install rabbitmq-server\nsudo rabbitmq-server\nnetstat -nap | grep 5672\n```\n关闭`rabbitmq`。\n```shell\nsudo rabbitmqctl stop\n```\n\n#### 设置一个 rabbitmq 的用户名和密码，默认存在一个用户 guest，密码为 guest。\n```shell\nrabbitmqctl add_user YOUR_USERNAME YOUR_PASSWORD\nrabbitmqctl set_user_tags YOUR_USERNAME administrator\nrabbitmqctl set_permissions -p / YOUR_USERNAME \".*\" \".*\" \".*\"\n```\n\n### 扩展\n- Nginx水平扩展。\n- 分库分表\n\n## 八、安全优化\n- 秒杀接口地址隐藏\n- 数学公式验证码（可以削峰）\n- 接口限流放刷\n\n### 1、秒杀接口地址隐藏\n思路：秒杀开始之前，先去请求接口获取秒杀地址。\n- 接口改造，带上PathVariable参数。\n- 添加生成地址的接口。\n- 秒杀收到请求，先验证PathVariable\n\n#### 流程\n秒杀开始，用户点击秒杀按钮时，在后端使用uuid+DM5生成一个str，并且以`用户id_商品id`为键，`str`为值存入redis。前端通过接口请求到这个str，拼接到路径中请求后端。后端取出这个str后和自己生成的oldStr对比（redis中的str），如果一致，则进入秒杀流程。\n##### 问题：\n有人先请求前端的接口得到str，然后去访问秒杀接口，可行吗？？？\n\n### 2、数学公式验证码\n- 添加生成验证码的接口。\n- 在获取秒杀路径的时候，验证验证码。\n- ScriptEngine使用。\n\n#### 流程\n秒杀开始时，前端请求后端生成验证码，然后将生成的验证码信息以`vc_用户id_秒杀商品id -> 验证码结果`的形式存储在redis中，同时将验证码发给前端。前端展示给用户，用户输入结果，点击秒杀按钮。前端发送请求给后端（同时包含秒杀地址参数），后端先从redis中取出验证码结果验证是否正确。正确则开始在redis中生成path，并进行下一步操作。\n\n\n## 总结\n秒杀系统设计 负责项目的设计和开发 2022.4 - 2022.5\n\n• 项目介绍：为了解决秒杀商品时存在高并发的问题，本项目基于SpringBoot开发秒杀系统。本人主要负责登录模块、商品列表模块、商品详情模板、订单详情模块、秒杀接口优化部分、安全模块。\n\n• 个人收获：对于基于SpringBoot项目的开发有了更加完整和深刻的认识。\n\n• 相关技术：SpringBoot、MySql、mybatis、Redis、RabbitMQ、Thymeleaf、jmeter"},{"title":"初识ThreadLocal","url":"/2022/04/16/初识ThreadLocal/","content":"\n# 1、ThreadLocal 使用实例\n来源：[廖雪峰Java教程](https://www.liaoxuefeng.com/wiki/1252599548343744/1306581251653666)\n```java\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.TimeUnit;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        ExecutorService es = Executors.newFixedThreadPool(3);\n        String[] users = new String[] { \"Bob\", \"Alice\", \"Tim\", \"Mike\", \"Lily\", \"Jack\", \"Bush\" };\n        for (String user : users) {\n            es.submit(new Task(user));\n        }\n        es.awaitTermination(3, TimeUnit.SECONDS);\n        es.shutdown();\n    }\n}\n\nclass UserContext implements AutoCloseable {    // \n    private static final ThreadLocal<String> userThreadLocal = new ThreadLocal<>();\n\n    public UserContext(String name) {\n        userThreadLocal.set(name);\n        System.out.printf(\"[%s] init user %s...\\n\", Thread.currentThread().getName(), UserContext.getCurrentUser());\n    }\n\n    public static String getCurrentUser() {\n        return userThreadLocal.get();\n    }\n\n    @Override\n    public void close() {\n        System.out.printf(\"[%s] cleanup for user %s...\\n\", Thread.currentThread().getName(),\n                UserContext.getCurrentUser());\n        userThreadLocal.remove();\n    }\n}\n\nclass Task implements Runnable {\n\n    final String username;\n\n    public Task(String username) {\n        this.username = username;\n    }\n\n    @Override\n    public void run() {\n        try (UserContext ctx = new UserContext(this.username)) {\n            new Task1().process();\n            new Task2().process();\n            new Task3().process();\n        }\n    }\n}\n\nclass Task1 {\n    public void process() {\n        try {\n            Thread.sleep(100);\n        } catch (InterruptedException e) {\n        }\n        System.out.printf(\"[%s] check user %s...\\n\", Thread.currentThread().getName(), UserContext.getCurrentUser());\n    }\n}\n\nclass Task2 {\n    public void process() {\n        try {\n            Thread.sleep(100);\n        } catch (InterruptedException e) {\n        }\n        System.out.printf(\"[%s] %s registered ok.\\n\", Thread.currentThread().getName(), UserContext.getCurrentUser());\n    }\n}\n\nclass Task3 {\n    public void process() {\n        try {\n            Thread.sleep(100);\n        } catch (InterruptedException ignored) {\n        }\n        System.out.printf(\"[%s] work of %s has done.\\n\", Thread.currentThread().getName(),\n                UserContext.getCurrentUser());\n    }\n}\n\n```\n\n# 2、ThreadLocal 结构\n`ThreadLocal`类里边定义了一个`ThreadLocalMap`静态内部类，`ThreadLocalMap`里边又有一个`static class Entry extends WeakReference<ThreadLocal<?>>`{}。除此之外，`ThreadLocalMap`中定义了`private Entry[] table。`因此，`ThreadLocal`的结构如下：\n![](初识ThreadLocal/ThreadLocal.png)\n\n\n```java\npublic class ThreadLocal<T> {\n\n    static ThreadLocalMap createInheritedMap(ThreadLocalMap parentMap) {\n        return new ThreadLocalMap(parentMap);\n    }\n\n    static class ThreadLocalMap {\n        static class Entry extends WeakReference<ThreadLocal<?>> {\n            /** The value associated with this ThreadLocal. */\n            Object value;\n\n            Entry(ThreadLocal<?> k, Object v) {\n                super(k);\n                value = v;\n            }\n        }\n\n        /**\n         * The initial capacity -- MUST be a power of two.\n         */\n        private static final int INITIAL_CAPACITY = 16;\n\n        /**\n         * The table, resized as necessary.\n         * table.length MUST always be a power of two.\n         */\n        private Entry[] table;\n\n        /**\n         * The number of entries in the table.\n         */\n        private int size = 0;\n\n        /**\n         * The next size value at which to resize.\n         */\n        private int threshold; // Default to 0\n\n        ThreadLocalMap(ThreadLocal<?> firstKey, Object firstValue) {\n            table = new Entry[INITIAL_CAPACITY];\n            int i = firstKey.threadLocalHashCode & (INITIAL_CAPACITY - 1);\n            table[i] = new Entry(firstKey, firstValue);\n            size = 1;\n            setThreshold(INITIAL_CAPACITY);\n        }\n        // ...\n    }\n    // ...\n}\n```\n### 内存泄露问题\n`ThreadLocalMap`中的key是一个弱引用，垃圾回收时就会被回收。如果`ThreadLocalMap`对应的线程依旧存活，那么value就依旧具有强引用而不会被回收，从而导致内存泄漏。解决内存泄漏的方法：直接调用remove()方法 (try{}finally{})，将value也置为 NULL。\n\n# 3、结合`Thread`理解`ThreadLoal`\n`Thread`类中包含一个`ThreadLocal.ThreadLocalMap`类型的成员变量`threadLocals`，因此每一个`Thread`都有一个`ThreadLocalMap`。\n```java\npublic class Thread implements Runnable {\n    /* ThreadLocal values pertaining to this thread. This map is maintained\n     * by the ThreadLocal class. */\n    ThreadLocal.ThreadLocalMap threadLocals = null;\n}\n```\n`ThreadLoal`set或get时，会先获取当前的`thread`，其实操作的就是`thread`的`threadLocals`,代码如下：\n```java\npublic class ThreadLocal<T> {\n\n    public T get() {\n        Thread t = Thread.currentThread();\n        ThreadLocalMap map = getMap(t);\n        if (map != null) {\n            ThreadLocalMap.Entry e = map.getEntry(this);\n            if (e != null) {\n                @SuppressWarnings(\"unchecked\")\n                T result = (T)e.value;\n                return result;\n            }\n        }\n        return setInitialValue();\n    }\n\n    public void set(T value) {\n        Thread t = Thread.currentThread();\n        ThreadLocalMap map = getMap(t);\n        if (map != null)\n            map.set(this, value);\n        else\n            createMap(t, value);\n    }\n\n    ThreadLocalMap getMap(Thread t) {\n        return t.threadLocals;\n    }\n}\n```\n在set方法中，最终是`map.set(this, value)`，这儿的this是Thread的一个实例,因此map结构是 (线程 --> Object)。\n\n## 思考：`Entry`类数组的作用？\n\n# 3、ThreadLocal 使用场景\n- ThreadLocal 相当于是线程的本地缓存，因此对可以存储一些属于该线程的数据，防止竞争。\n- 对于当前线程多次使用的的数据可以使用 ThreadLocal 存储，通过 get 方法就可以获得。比如，当前用户的 session 会在程序中多次使用，定义一个 ThreadLocal 存储，每次使用时 get 即可。\n\n### 参考：\n1、[Guide ThreadLocal 关键字解析](https://github.com/Snailclimb/JavaGuide/blob/main/docs/java/concurrent/threadlocal.md)\n","categories":["java"]},{"title":"SpringMVC自定义参数解析器","url":"/2022/04/15/SpringMVC自定义参数解析器/","content":"\n# 1、实现参数解析器的接口`HandlerMethodArgumentResolver`\n`HandlerMethodArgumentResolver`接口包含两个方法`supportsParameter`和`resolveArgument`。\n- supportsParameter方法返回 boolean 值，表示是否启用该解析器，true 表示启用，false 表示不启用；\n- resolveArgument 方法表示方法参数的解析过程，就是你把 HTTP 的请求参数转换为方法参数的过程，返回 Object 对象，即参数的转换结果。\n\n源代码如下：\n```java\npublic interface HandlerMethodArgumentResolver {\n    boolean supportsParameter(MethodParameter var1);\n\n    Object resolveArgument(MethodParameter var1, ModelAndViewContainer var2, NativeWebRequest var3, WebDataBinderFactory var4) throws Exception;\n}\n```\n\n# 2、自定义一个参数解析器\n- 定义一个方法注解\n- 实现`HandlerMethodArgumentResolver`接口。\n- 注册参数解析器\n- 使用参数解析器\n\n## 2.1 定义一个方法注解\n```java\n@Retention(RUNTIME)\n@Target(METHOD)\npublic @interface ParamModel {\n    // 可以定义需要带的参数\n}\n```\n\n## 2.2 实现`HandlerMethodArgumentResolver`接口。\n在`HandlerMethodArgumentResolver`接口中实现具体的参数解析。\n```java\n@Service\npublic class UserArgumentResolvers implements HandlerMethodArgumentResolver {\n\n    @Override\n    public boolean supportsParameter(MethodParameter parameter) {\n        //带有注解就解析，即调用下面的 resolveArgument 方法。\n        return methodParameter.hasParameterAnnotation(ParamModel.class);\n    }\n\n    @Override\n    public Object resolveArgument(MethodParameter methodParameter, ModelAndViewContainer modelAndViewContainer,\n                                  NativeWebRequest webRequest, WebDataBinderFactory webDataBinderFactory) throws Exception {\n       HttpServletRequest request = webRequest.getNativeRequest(HttpServletRequest.class);\n       HttpServletResponse response = webRequest.getNativeResponse(HttpServletResponse.class);\n\n        // 从request和request中解析出对应的Object。\n\n        return null;\n    }\n\n```\n\n## 2.3 注册参数解析器\n```java\n@Configuration\npublic class WebConfig extends WebMvcConfigurerAdapter {\n\n    @Autowired\n    UserArgumentResolvers userArgumentResolver;\n\n    @Override\n    public void addArgumentResolvers(List<HandlerMethodArgumentResolver> argumentResolvers) {\n        argumentResolvers.add(userArgumentResolver);\n    }\n}\n```\n\n## 2.4 使用参数解析器\n\n```java\n\npublic void getMiaoshaPath(@ParamModel int verifyCode) { // 参数解析的结果会赋值给verifyCode。\n    // ...\n}\n```","tags":["java、SpringMVC、参数解析器"],"categories":["SpringMVC"]},{"title":"SpringMVC实现拦截器","url":"/2022/04/15/SpringMVC实现拦截器/","content":"\n# 1、功能需求\n在秒杀商品时，需要使用秒杀接口防刷保护程序，可以定义一个拦截器实现。具体使用如下所示：\n```java\n @AccessLimit(seconds = 1, maxCount = 100, needLogin = true)\n```\n这个拦截器需要当前用户登录，且1s内限制最大请求次数为100。\n\n# 2、拦截器的主要类`HandlerInterceptorAdapter`\n`HandlerInterceptorAdapter`提供的方法如下：\n- `preHandle`:方法执行前调用拦截器，返回true，则接续执行，否则不会执行方法。\n- `postHandle`:在方法执行后调用。\n- `afterCompletion`\n源代码如下：\n```java\n    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {\n        return true;\n    }\n\n    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {\n    }\n\n    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {\n    }\n```\n\n# 3、实现拦截器\n  - 自定义 @AccessLimit 参数解析器。\n  - 重写`HandlerInterceptorAdapter`类的`preHandle`方法\n  - 注册拦截器\n  - 使用拦截器\n\n## 3.1 自定义 @AccessLimit 注解。\n```java\n/*\n* 定义一个注解\n*/\n@Retention(RUNTIME)\n@Target(METHOD)\npublic @interface AccessLimit {\n    int seconds();\n    int maxCount();\n    boolean needLogin() default true;\n}\n```\n\n## 3.2 重写`preHandle`方法\n```java\n\n/*\n*  满足拦截条件 return false;\n*  不满足拦截条件 return true;\n*/\n@Service\npublic class AccessInterceptor extends HandlerInterceptorAdapter {\n\n    @Override\n    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {\n\n        if (handler instanceof HandlerMethod){\n            MiaoshaUser user = getUser(request, response);\n\n            // 存储user\n            UserContext.setUser(user); // 当前线程就可以取用。\n\n            HandlerMethod hm = (HandlerMethod) handler;\n            AccessLimit accessLimit = hm.getMethodAnnotation(AccessLimit.class);    // 获取注解\n            if (accessLimit == null) {    // 如果没有限制\n                return true;\n            }\n            int seconds = accessLimit.seconds();\n            int maxCount = accessLimit.maxCount();\n            boolean needLogin = accessLimit.needLogin();\n            // 具体的拦截逻辑\n        }\n        return true;\n    }\n}\n```\n## 3.3 注册拦截器\n```java\n@Configuration\npublic class WebConfig extends WebMvcConfigurerAdapter {\n    @Autowired\n    AccessInterceptor accessInterceptor;\n\n    @Override\n    public void addArgumentResolvers(List<HandlerMethodArgumentResolver> argumentResolvers) {\n        argumentResolvers.add(userArgumentResolver);\n    }\n\n    // 注册拦截器\n    @Override\n    public void addInterceptors(InterceptorRegistry registry) {\n        registry.addInterceptor(new);\n    }\n}\n```\n## 3.4 使用拦截器\n```java\n@AccessLimit(seconds = 1, maxCount = 100, needLogin = true)\npublic void test(){\n    // ...\n}\n```\n\n","tags":["java，SpringMVC，拦截器"],"categories":["SpringMVC"]},{"title":"java杂项","url":"/2022/04/15/java杂项/","content":"## ThreadLcoal 的用法\n\n在秒杀功能中，定义一个`static`的`ThreadLcoal`存储`MiaoshaUser`。当用户点击秒杀按钮时将其存储在`ThreadLocal`中，该线程以后使用时就可以直接get。\n\n```java\nprivate static ThreadLocal<MiaoshaUser> userHolder = new ThreadLocal<>();\n```\n\n如果不这样做，需要每次从请求中解析`MiaoshaUser`对象,代码如下：\n```java\n@Service\npublic class UserArgumentResolvers implements HandlerMethodArgumentResolver {\n\n    @Autowired\n    MiaoshaUserService userService;\n\n    @Override\n    public boolean supportsParameter(MethodParameter parameter) {\n        // 当为 MiaoshaUser 类型时就执行参数解析，即调用下面的 resolveArgument 方法。\n        Class<?> clazz = parameter.getParameterType();\n        return clazz == MiaoshaUser.class;\n    }\n\n    @Override\n    public Object resolveArgument(MethodParameter methodParameter, ModelAndViewContainer modelAndViewContainer,\n                                  NativeWebRequest webRequest, WebDataBinderFactory webDataBinderFactory) throws Exception {\n       HttpServletRequest request = webRequest.getNativeRequest(HttpServletRequest.class);\n       HttpServletResponse response = webRequest.getNativeResponse(HttpServletResponse.class);\n\n       String paramToken = request.getParameter(MiaoshaUserService.COOKI_NAME_TOKEN);\n       String cookieToken = getCookieValue(request, MiaoshaUserService.COOKI_NAME_TOKEN);\n\n       if (StringUtils.isEmpty(cookieToken) && StringUtils.isEmpty(paramToken)){\n           return null;\n       }\n       String token = StringUtils.isEmpty(paramToken) ? cookieToken : paramToken;\n       return userService.getByToken(response,token);\n    }\n\n   private String getCookieValue(HttpServletRequest request, String cookieName) {\n       Cookie[] cookies = request.getCookies();\n       if (cookies == null || cookies.length <= 0){\n           return null;\n       }\n       for (Cookie cookie : cookies) {\n           if (cookie.getName().equals(cookieName)){\n               return cookie.getValue();\n           }\n       }\n       return null;\n   }\n}\n```\n\n","tags":["杂项"],"categories":["java"]},{"title":"杂项","url":"/2022/04/08/杂项/","content":"\n## 配置环境变量\n\n### export\nexport 表示将该路径添加到环境变量中，打开 vim .zshrc ，添加jmeter的快速启动路径\n> export JMETER_HOME=/usr/local/apache-jmeter-5.4.3\n> export PATH=$JAVA_HOME/bin:$PATH:.:$JMETER_HOME/bin:$PATH\n> export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JMETER_HOME/lib/ext/ApacheJMeter_core.jar:$JMETER_HOME/lib/jorphan.jar:$JMETER_HOME/lib/logkit-2.0.jar\n\nsource .zshrc 使.zshrc生效。\n使用 export -p 可以查看当前的环境中的路径。\n\n### alias\nalias 为指定路径起别名。\n> export PATH=/usr/local/mysql/bin:$PATH\n> #快速启动、结束MySQL服务, 可以使用alias命令\n> alias mysqlstart='sudo /usr/local/mysql/support-files/mysql.server start'\n> alias mysqlstop='sudo /usr/local/mysql/support-files/mysql.server stop'\n\n---\n\n## macOS目录的作用\n\n### 系统硬件相关\n/cores 内核转储文件存放目录。当一个进程崩溃时，如果系统允许则会产生转储文件。\n/dev 设备文件存放目录，如何代表硬盘的/dev/disk0。\n/Network 网络节点存放目录；\n/Volumes 文件系统挂载点存放目录。\n\n### 系统配置相关\n/etc. 标准unix系统配置文件存放目录，如用户密码文件/etc/passwd。此目录实际为指向/private/etc的链接。\n\n### 系统程序相关\n/Applications 应用程序目录，默认所有的GUI应用程序都安装在这里；\n/Library 系统的数据文件、帮助文件、文档等等；\n/System 只包含一个名为Library的目录，这个子目录中存放了系统的绝大部分组件，如各种framework，以及内核模块，字体文件等等。\n\n### 系统命令相关\n/bin 传统unix命令的存放目录，如ls，rm，mv等。\n/sbin 传统unix管理类命令存放目录，如fdisk，ifconfig等等。\n\n### 用户信息相关\n/Users 存放用户的个人资料和配置。每个用户有自己的单独目录。\n\n### 用户经常使用\n/usr 第三方程序安装目录。\n/usr/bin, /usr/sbin, /usr/lib，其中/usr/lib目录中存放了共享库（动态链接库）。\n/var 存放经常变化的文件，如日志文件。此目录实际为指向/private/var的链接。\n\n/opt/homebrew brew安装的程序一般放这儿。\n\n/private 里面的子目录存放了/tmp, /var, /etc等链接目录的目标目录。\n/tmp 临时文件存放目录，其权限为所有人任意读写。此目录实际为指向/private/tmp的链接。\n\n### 其他\n/installer.failurerequests 可能是用来记录发生crash时的日志。\n\n---\n\n## linux 命令拾遗\n\n### lsof（list open files）\nlsof 列出当前系统打开文件的工具。lsof -i :8080 可以查看当前占用8080端口的进程。\n\n### ls（list）\nls默认情况下用来打印出当前目录的列表。\n\n---\n\n## git流程\n将写了一半的项目git到空github上。\n1. github上创建同名仓库\n2. git clone到本地\n3. 将隐藏的.git文件复制到已经写了一半的project中\n4. git add .\n5. git status\n6. git commit -m “提交说明”\n7. git push\n\n---\n\n","tags":["杂项"]},{"title":"hexo github配置博客","url":"/2022/04/06/hexo github配置博客/","content":"\n## 1、 配置环境流程\n\n### 1.1 安装node.js\n\n官网下载node.js\nnode -v\nnmp -v\n\n\n### 1.2 创建blog目录\n\nmkdir /Users/jq/blog\n\n\n### 1.3 安装hexo\n\nnmp install hexo -g hexo-cli\nhexo -v\n\n\n### 1.4 VPN设置\n\n如果设置了VPN，需要设置环境变量；\nvim ./~zshrc\n```shell\nexport https_proxy=http://127.0.0.1:7890 http_proxy=http://127.0.0.1:7890 all_proxy=socks5://127.0.0.1:7890\n\nsource ./~zshrc\n```\n\n### 1.5 初始化hexo\n\nsudo su\nsudo hexo init\n\n## 2、写一个博客流程\n\n### 2.1 开始hexo\n\nhexo s\n\n### 2.2 创建一个新博客\n\nhexo n “XXXX”\n\n使用vsconde等编写内容。\n\n### 2.3 清理\n\nhexo clean\n\n### 2.4 生成博客\n\nhexo g\n\n### 2.5 浏览刚才写的博客\n\nhexo s\n\n\n## 3、配置github\n\n### 3.1 在最后添加\n\n```html\ndeploy:\n  type: git\n  repository: git@github.com:jiaoqiang2014/jiaoqiang2014.github.io.git\n  branch: master\n```\n## 4、换主题\n### 4.1 下载主题\n```\ngit clone git@github.com:litten/hexo-theme-yilia.git themes/yilia\ngit@github.com:yscoder/hexo-theme-indigo.git\n```\n### 4.2 修改_config.yml配置\n```\ntheme: yilia\n```\n\nHexo clean\n\nHexo g\n\nHero s\n\n## 5、[代码折叠功能](https://www.toimc.com/hexo-usage-2/#%E6%B7%BB%E5%8A%A0jquery)\n\n## 6、[hexo引用本地图片无法显示问题](https://juejin.cn/post/7006594302604214280)\n使用格式为：`![图片描述](md文件夹名字/example.jpg)`\n\n### 参考博客：\n**[1、 hexo增加分类、标签](https://tohugo.com/2021/01/26/%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE/Hexo%E6%B7%BB%E5%8A%A0%E5%88%86%E7%B1%BB%E5%8F%8A%E6%A0%87%E7%AD%BE%EF%BC%88%E5%9C%A8Next%E4%B8%BB%E9%A2%98%E4%B8%8B%EF%BC%89/)**\n**[2、 hexo主题美化](https://www.fangdongdemao.com/2020/05/23/hexo-Next%E4%B8%BB%E9%A2%98%E7%BE%8E%E5%8C%96/)**\n**[3 https://github.com/Neveryu/Neveryu.github.io/blob/](https://github.com/Neveryu/Neveryu.github.io/blob/)**\n","tags":["hexo"],"categories":["hexo"]}]