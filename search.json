[{"title":"SpringBoot自定义参数解析器","url":"/2022/04/15/SpringBoot自定义参数解析器/","content":"\n# 1、实现参数解析器的接口`HandlerMethodArgumentResolver`\n`HandlerMethodArgumentResolver`接口包含两个方法`supportsParameter`和`resolveArgument`。\n- supportsParameter方法返回 boolean 值，表示是否启用该解析器，true 表示启用，false 表示不启用；\n- resolveArgument 方法表示方法参数的解析过程，就是你把 HTTP 的请求参数转换为方法参数的过程，返回 Object 对象，即参数的转换结果。\n\n源代码如下：\n```java\npublic interface HandlerMethodArgumentResolver {\n    boolean supportsParameter(MethodParameter var1);\n\n    Object resolveArgument(MethodParameter var1, ModelAndViewContainer var2, NativeWebRequest var3, WebDataBinderFactory var4) throws Exception;\n}\n```\n\n# 2、自定义一个参数解析器\n- 定义一个方法注解\n- 实现`HandlerMethodArgumentResolver`接口。\n- 注册参数解析器\n- 使用参数解析器\n## 2.1 定义一个方法注解\n```java\n@Retention(RUNTIME)\n@Target(METHOD)\npublic @interface ParamModel {\n    // 可以定义需要带的参数\n}\n```\n\n## 2.2 实现`HandlerMethodArgumentResolver`接口。\n在`HandlerMethodArgumentResolver`接口中实现具体的参数解析。\n```java\n@Service\npublic class UserArgumentResolvers implements HandlerMethodArgumentResolver {\n\n    @Override\n    public boolean supportsParameter(MethodParameter parameter) {\n        //带有注解就解析，即调用下面的 resolveArgument 方法。\n        return methodParameter.hasParameterAnnotation(ParamModel.class);\n    }\n\n    @Override\n    public Object resolveArgument(MethodParameter methodParameter, ModelAndViewContainer modelAndViewContainer,\n                                  NativeWebRequest webRequest, WebDataBinderFactory webDataBinderFactory) throws Exception {\n       HttpServletRequest request = webRequest.getNativeRequest(HttpServletRequest.class);\n       HttpServletResponse response = webRequest.getNativeResponse(HttpServletResponse.class);\n\n        // 从request和request中解析出对应的Object。\n\n        return null;\n    }\n\n```\n\n## 2.3 注册参数解析器\n```java\n@Configuration\npublic class WebConfig extends WebMvcConfigurerAdapter {\n\n    @Autowired\n    UserArgumentResolvers userArgumentResolver;\n\n    @Override\n    public void addArgumentResolvers(List<HandlerMethodArgumentResolver> argumentResolvers) {\n        argumentResolvers.add(userArgumentResolver);\n    }\n}\n```\n\n## 2.4 使用参数解析器\n\n```java\n\npublic void getMiaoshaPath(@ParamModel int verifyCode) { // 参数解析的结果会赋值给verifyCode。\n    // ...\n}\n```","tags":["java、SpringBoot、参数解析器"],"categories":["SpringBoot"]},{"title":"SpringBoot实现拦截器","url":"/2022/04/15/SpringBoot实现拦截器/","content":"\n## 1、功能需求，在秒杀商品时，需要使用秒杀接口防刷保护程序，可以定义一个拦截器实现。具体使用如下所示：\n```java\n@AccessLimit(seconds = 1, maxCount = 100, needLogin = true)\n```\n这个拦截器需要当前用户登录，且1s内限制最大请求次数为100。\\\n拦截器的实现是基于参数解析器的，关于参数解析器的部分参考博客参数解析器的说明。\n\n## 2、拦截器的主要类`HandlerInterceptorAdapter`\n`HandlerInterceptorAdapter`提供的方法如下：\n- `preHandle`:方法执行前调用拦截器，返回true，则接续执行，否则不会执行方法。\n- `postHandle`:在方法执行后调用。\n- `afterCompletion`\n源代码如下：\n```java\n    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {\n        return true;\n    }\n\n    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {\n    }\n\n    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {\n    }\n```\n## 2、实现拦截器\n  - 自定义 @AccessLimit 参数解析器。\n  - 重写`HandlerInterceptorAdapter`类的`preHandle`方法\n  - 注册拦截器\n  - 使用拦截器\n\n### 2.1 自定义 @AccessLimit 参数解析器。\n```java\n/*\n* 定义一个注解\n*/\n@Retention(RUNTIME)\n@Target(METHOD)\npublic @interface AccessLimit {\n    int seconds();\n    int maxCount();\n    boolean needLogin() default true;\n}\n\n/*\n* 实现参数解析\n*/\n@Service\npublic class UserArgumentResolvers implements HandlerMethodArgumentResolver {\n\n    @Autowired\n    MiaoshaUserService userService;\n\n    @Override\n    public boolean supportsParameter(MethodParameter parameter) {\n        return true;\n    }\n\n    @Override\n    public Object resolveArgument(MethodParameter methodParameter, ModelAndViewContainer modelAndViewContainer,\n                                  NativeWebRequest webRequest, WebDataBinderFactory webDataBinderFactory) throws Exception {\n\n        return null;\n    }\n}\n\n/*\n* 注册参数解析器\n*/\n@Configuration\npublic class WebConfig extends WebMvcConfigurerAdapter {\n\n    @Autowired\n    UserArgumentResolvers userArgumentResolver;\n\n    @Override\n    public void addArgumentResolvers(List<HandlerMethodArgumentResolver> argumentResolvers) {\n        argumentResolvers.add(userArgumentResolver);\n    }\n}\n```\n### 2.2 重写`preHandle`方法\n```java\n\n/*\n*  满足拦截条件 return false;\n*  不满足拦截条件 return true;\n*/\n@Service\npublic class AccessInterceptor extends HandlerInterceptorAdapter {\n\n    @Override\n    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {\n\n        if (handler instanceof HandlerMethod){\n            MiaoshaUser user = getUser(request, response);\n\n            // 存储user\n            UserContext.setUser(user); // 当前线程就可以取用。\n\n            HandlerMethod hm = (HandlerMethod) handler;\n            AccessLimit accessLimit = hm.getMethodAnnotation(AccessLimit.class);    // 获取注解\n            if (accessLimit == null) {    // 如果没有限制\n                return true;\n            }\n            int seconds = accessLimit.seconds();\n            int maxCount = accessLimit.maxCount();\n            boolean needLogin = accessLimit.needLogin();\n            // 具体的拦截逻辑\n        }\n        return true;\n    }\n}\n```\n### 2.3 注册拦截器\n```java\n@Configuration\npublic class WebConfig extends WebMvcConfigurerAdapter {\n    @Autowired\n    AccessInterceptor accessInterceptor;\n\n    @Override\n    public void addArgumentResolvers(List<HandlerMethodArgumentResolver> argumentResolvers) {\n        argumentResolvers.add(userArgumentResolver);\n    }\n\n    // 注册拦截器\n    @Override\n    public void addInterceptors(InterceptorRegistry registry) {\n        registry.addInterceptor(new);\n    }\n}\n```\n### 2.4 使用拦截器\n```java\n@AccessLimit(seconds = 1, maxCount = 100, needLogin = true)\npublic void test(){\n    // ...\n}\n```\n\n","tags":["java，SpringBoot，拦截器"],"categories":["SpringBoot"]},{"title":"java杂项","url":"/2022/04/15/java杂项/","content":"## ThreadLcoal 的用法\n\n在秒杀功能中，使用`ThreadLcoal`存储`MiaoshaUser`，用户点击秒杀按钮时需要对判断用户是不是秒杀用户，\n\n```java\npackage com.imooc.miaosha.access;\n\nimport com.imooc.miaosha.domain.MiaoshaUser;\n\npublic class UserContext {\n\n    private static ThreadLocal<MiaoshaUser> userHolder = new ThreadLocal<>();\n\n    public static void setUser(MiaoshaUser user){\n        userHolder.set(user);\n    }\n\n    public static MiaoshaUser getUser(){\n        return userHolder.get();\n    }\n\n}\n```","tags":["杂项"],"categories":["java"]},{"title":"杂项","url":"/2022/04/08/杂项/","content":"\n## 配置环境变量\n\n### export\nexport 表示将该路径添加到环境变量中，打开 vim .zshrc ，添加jmeter的快速启动路径\n> export JMETER_HOME=/usr/local/apache-jmeter-5.4.3\n> export PATH=$JAVA_HOME/bin:$PATH:.:$JMETER_HOME/bin:$PATH\n> export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JMETER_HOME/lib/ext/ApacheJMeter_core.jar:$JMETER_HOME/lib/jorphan.jar:$JMETER_HOME/lib/logkit-2.0.jar\n\nsource .zshrc 使.zshrc生效。\n使用 export -p 可以查看当前的环境中的路径。\n\n### alias\nalias 为指定路径起别名。\n> export PATH=/usr/local/mysql/bin:$PATH\n> #快速启动、结束MySQL服务, 可以使用alias命令\n> alias mysqlstart='sudo /usr/local/mysql/support-files/mysql.server start'\n> alias mysqlstop='sudo /usr/local/mysql/support-files/mysql.server stop'\n\n---\n\n## macOS目录的作用\n\n### 系统硬件相关\n/cores 内核转储文件存放目录。当一个进程崩溃时，如果系统允许则会产生转储文件。\n/dev 设备文件存放目录，如何代表硬盘的/dev/disk0。\n/Network 网络节点存放目录；\n/Volumes 文件系统挂载点存放目录。\n\n### 系统配置相关\n/etc. 标准unix系统配置文件存放目录，如用户密码文件/etc/passwd。此目录实际为指向/private/etc的链接。\n\n### 系统程序相关\n/Applications 应用程序目录，默认所有的GUI应用程序都安装在这里；\n/Library 系统的数据文件、帮助文件、文档等等；\n/System 只包含一个名为Library的目录，这个子目录中存放了系统的绝大部分组件，如各种framework，以及内核模块，字体文件等等。\n\n### 系统命令相关\n/bin 传统unix命令的存放目录，如ls，rm，mv等。\n/sbin 传统unix管理类命令存放目录，如fdisk，ifconfig等等。\n\n### 用户信息相关\n/Users 存放用户的个人资料和配置。每个用户有自己的单独目录。\n\n### 用户经常使用\n/usr 第三方程序安装目录。\n/usr/bin, /usr/sbin, /usr/lib，其中/usr/lib目录中存放了共享库（动态链接库）。\n/var 存放经常变化的文件，如日志文件。此目录实际为指向/private/var的链接。\n\n/opt/homebrew brew安装的程序一般放这儿。\n\n/private 里面的子目录存放了/tmp, /var, /etc等链接目录的目标目录。\n/tmp 临时文件存放目录，其权限为所有人任意读写。此目录实际为指向/private/tmp的链接。\n\n### 其他\n/installer.failurerequests 可能是用来记录发生crash时的日志。\n\n---\n\n## linux 命令拾遗\n\n### lsof（list open files）\nlsof 列出当前系统打开文件的工具。lsof -i :8080 可以查看当前占用8080端口的进程。\n\n### ls（list）\nls默认情况下用来打印出当前目录的列表。\n\n---\n\n## git流程\n将写了一半的项目git到空github上。\n1. github上创建同名仓库\n2. git clone到本地\n3. 将隐藏的.git文件复制到已经写了一半的project中\n4. git add .\n5. git status\n6. git commit -m “提交说明”\n7. git push\n\n---\n\n","tags":["杂项"]},{"title":"hexo github配置博客","url":"/2022/04/06/hexo github配置博客/","content":"\n## 配置环境流程\n\n### 安装node.js\n\n官网下载node.js\nnode -v\nnmp -v\n\n\n### 创建blog目录\n\nmkdir /Users/jq/blog\n\n\n### 安装hexo\n\nnmp install hexo -g hexo-cli\nhexo -v\n\n\n### VPN设置\n\n如果设置了VPN，需要设置环境变量；\nvim ./~zshrc\n\nexport https_proxy=http://127.0.0.1:7890 http_proxy=http://127.0.0.1:7890 all_proxy=socks5://127.0.0.1:7890\n\nsource ./~zshrc\n\n\n### 初始化hexo\n\nsudo su\nsudo hexo init\n\n## 写一个博客流程\n\n### 开始hexo\n\nhexo s\n\n### 创建一个新博客\n\nhexo n “XXXX”\n\n使用vsconde等编写内容。\n\n### 清理\n\nhexo clean\n\n### 生成博客\n\nhexo g\n\n### 浏览刚才写的博客\n\nhexo s\n\n\n## 配置github\n\n### 在最后添加\n\n```\ndeploy:\n  type: git\n  repository: git@github.com:jiaoqiang2014/jiaoqiang2014.github.io.git\n  branch: master\n```\n## 换主题\n### 下载主题\n```\ngit clone git@github.com:litten/hexo-theme-yilia.git themes/yilia\ngit@github.com:yscoder/hexo-theme-indigo.git\n```\n### 修改_config.yml配置\n```\ntheme: yilia\n```\n\nHexo clean\n\nHexo g\n\nHero s\n\n### 参考博客：\n**[1、 hexo增加分类、标签](https://tohugo.com/2021/01/26/%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE/Hexo%E6%B7%BB%E5%8A%A0%E5%88%86%E7%B1%BB%E5%8F%8A%E6%A0%87%E7%AD%BE%EF%BC%88%E5%9C%A8Next%E4%B8%BB%E9%A2%98%E4%B8%8B%EF%BC%89/)**\n**[2、 hexo主题美化](https://www.fangdongdemao.com/2020/05/23/hexo-Next%E4%B8%BB%E9%A2%98%E7%BE%8E%E5%8C%96/)**\n**[3 https://github.com/Neveryu/Neveryu.github.io/blob/](https://github.com/Neveryu/Neveryu.github.io/blob/)**\n","tags":["hexo"],"categories":["hexo"]}]